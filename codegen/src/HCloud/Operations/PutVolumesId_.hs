-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE DeriveGeneric #-}

-- | Contains the different functions to run the operation putVolumes_Id_
module HCloud.Operations.PutVolumesId_ where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Either
import qualified Data.Functor
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Generics
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified HCloud.Common
import HCloud.Types

-- | > PUT /volumes/{id}
-- 
-- Updates the Volume properties.
-- 
-- Note that when updating labels, the volumeâ€™s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.
putVolumes_Id_ :: forall m s . (HCloud.Common.MonadHTTP m, HCloud.Common.SecurityScheme s) => HCloud.Common.Configuration s  -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text                                                                                                    -- ^ id: ID of the Volume to update
  -> GHC.Maybe.Maybe PutVolumesIdRequestBody                                                                                    -- ^ The request body to send
  -> m (Data.Either.Either Network.HTTP.Client.Types.HttpException (Network.HTTP.Client.Types.Response PutVolumesIdResponse))   -- ^ Monad containing the result of the operation
putVolumes_Id_ config
               id
               body = GHC.Base.fmap (GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either PutVolumesIdResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> PutVolumesIdResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                        PutVolumesIdResponseBody200)
                                                                                                                                                                            | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0)) (HCloud.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") (Data.Text.pack ("/volumes/" GHC.Base.++ (Data.ByteString.Char8.unpack (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Data.ByteString.Char8.pack GHC.Base.$ HCloud.Common.stringifyModel id)) GHC.Base.++ ""))) [] body HCloud.Common.RequestBodyEncodingJSON)
-- | > PUT /volumes/{id}
-- 
-- The same as 'putVolumes_Id_' but returns the raw 'Data.ByteString.Char8.ByteString'
putVolumes_Id_Raw :: forall m s . (HCloud.Common.MonadHTTP m,
                                   HCloud.Common.SecurityScheme s) =>
                     HCloud.Common.Configuration s ->
                     Data.Text.Internal.Text ->
                     GHC.Maybe.Maybe PutVolumesIdRequestBody ->
                     m (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                           (Network.HTTP.Client.Types.Response Data.ByteString.Internal.ByteString))
putVolumes_Id_Raw config
                  id
                  body = GHC.Base.id (HCloud.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") (Data.Text.pack ("/volumes/" GHC.Base.++ (Data.ByteString.Char8.unpack (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Data.ByteString.Char8.pack GHC.Base.$ HCloud.Common.stringifyModel id)) GHC.Base.++ ""))) [] body HCloud.Common.RequestBodyEncodingJSON)
-- | > PUT /volumes/{id}
-- 
-- Monadic version of 'putVolumes_Id_' (use with 'HCloud.Common.runWithConfiguration')
putVolumes_Id_M :: forall m s . (HCloud.Common.MonadHTTP m,
                                 HCloud.Common.SecurityScheme s) =>
                   Data.Text.Internal.Text ->
                   GHC.Maybe.Maybe PutVolumesIdRequestBody ->
                   Control.Monad.Trans.Reader.ReaderT (HCloud.Common.Configuration s)
                                                      m
                                                      (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                                                          (Network.HTTP.Client.Types.Response PutVolumesIdResponse))
putVolumes_Id_M id
                body = GHC.Base.fmap (GHC.Base.fmap (\response_2 -> GHC.Base.fmap (Data.Either.either PutVolumesIdResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> PutVolumesIdResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         PutVolumesIdResponseBody200)
                                                                                                                                                                             | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_2) response_2)) (HCloud.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") (Data.Text.pack ("/volumes/" GHC.Base.++ (Data.ByteString.Char8.unpack (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Data.ByteString.Char8.pack GHC.Base.$ HCloud.Common.stringifyModel id)) GHC.Base.++ ""))) [] body HCloud.Common.RequestBodyEncodingJSON)
-- | > PUT /volumes/{id}
-- 
-- Monadic version of 'putVolumes_Id_Raw' (use with 'HCloud.Common.runWithConfiguration')
putVolumes_Id_RawM :: forall m s . (HCloud.Common.MonadHTTP m,
                                    HCloud.Common.SecurityScheme s) =>
                      Data.Text.Internal.Text ->
                      GHC.Maybe.Maybe PutVolumesIdRequestBody ->
                      Control.Monad.Trans.Reader.ReaderT (HCloud.Common.Configuration s)
                                                         m
                                                         (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                                                             (Network.HTTP.Client.Types.Response Data.ByteString.Internal.ByteString))
putVolumes_Id_RawM id
                   body = GHC.Base.id (HCloud.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") (Data.Text.pack ("/volumes/" GHC.Base.++ (Data.ByteString.Char8.unpack (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Data.ByteString.Char8.pack GHC.Base.$ HCloud.Common.stringifyModel id)) GHC.Base.++ ""))) [] body HCloud.Common.RequestBodyEncodingJSON)
-- | Defines the data type for the schema putVolumes_Id_RequestBody
-- 
-- 
data PutVolumesIdRequestBody = PutVolumesIdRequestBody {
  -- | labels: User-defined labels (key-value pairs)
  putVolumesIdRequestBodyLabels :: (GHC.Maybe.Maybe PutVolumesIdRequestBodyLabels)
  -- | name: New Volume name
  , putVolumesIdRequestBodyName :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PutVolumesIdRequestBody
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "labels" (putVolumesIdRequestBodyLabels obj) : (Data.Aeson..=) "name" (putVolumesIdRequestBodyName obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "labels" (putVolumesIdRequestBodyLabels obj) GHC.Base.<> (Data.Aeson..=) "name" (putVolumesIdRequestBodyName obj))
instance Data.Aeson.Types.FromJSON.FromJSON PutVolumesIdRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutVolumesIdRequestBody" (\obj -> (GHC.Base.pure PutVolumesIdRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "labels")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name"))
-- | Defines the data type for the schema putVolumes_Id_RequestBodyLabels
-- 
-- User-defined labels (key-value pairs)
data PutVolumesIdRequestBodyLabels = PutVolumesIdRequestBodyLabels {
  -- | labelkey
  putVolumesIdRequestBodyLabelsLabelkey :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PutVolumesIdRequestBodyLabels
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "labelkey" (putVolumesIdRequestBodyLabelsLabelkey obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "labelkey" (putVolumesIdRequestBodyLabelsLabelkey obj))
instance Data.Aeson.Types.FromJSON.FromJSON PutVolumesIdRequestBodyLabels
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutVolumesIdRequestBodyLabels" (\obj -> GHC.Base.pure PutVolumesIdRequestBodyLabels GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "labelkey"))
-- | Represents a response of the operation 'putVolumes_Id_'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'PutVolumesIdResponseError' is used.
data PutVolumesIdResponse =                              
   PutVolumesIdResponseError GHC.Base.String             -- ^ Means either no matching case available or a parse error
  | PutVolumesIdResponse200 PutVolumesIdResponseBody200  -- ^ The \`volume\` key contains the updated volume
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the data type for the schema PutVolumesIdResponseBody200
-- 
-- 
data PutVolumesIdResponseBody200 = PutVolumesIdResponseBody200 {
  -- | volume
  putVolumesIdResponseBody200Volume :: PutVolumesIdResponseBody200Volume
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PutVolumesIdResponseBody200
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "volume" (putVolumesIdResponseBody200Volume obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "volume" (putVolumesIdResponseBody200Volume obj))
instance Data.Aeson.Types.FromJSON.FromJSON PutVolumesIdResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutVolumesIdResponseBody200" (\obj -> GHC.Base.pure PutVolumesIdResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "volume"))
-- | Defines the data type for the schema PutVolumesIdResponseBody200Volume
-- 
-- 
data PutVolumesIdResponseBody200Volume = PutVolumesIdResponseBody200Volume {
  -- | created: Point in time when the Resource was created (in ISO-8601 format)
  putVolumesIdResponseBody200VolumeCreated :: Data.Text.Internal.Text
  -- | format: Filesystem of the Volume if formatted on creation, null if not formatted on creation
  , putVolumesIdResponseBody200VolumeFormat :: Data.Text.Internal.Text
  -- | id: ID of the Resource
  , putVolumesIdResponseBody200VolumeId :: GHC.Integer.Type.Integer
  -- | labels: User-defined labels (key-value pairs)
  , putVolumesIdResponseBody200VolumeLabels :: PutVolumesIdResponseBody200VolumeLabels
  -- | linux_device: Device path on the file system for the Volume
  , putVolumesIdResponseBody200VolumeLinuxDevice :: Data.Text.Internal.Text
  -- | location: Location of the Volume. Volume can only be attached to Servers in the same Location.
  , putVolumesIdResponseBody200VolumeLocation :: PutVolumesIdResponseBody200VolumeLocation
  -- | name: Name of the Resource. Must be unique per Project.
  , putVolumesIdResponseBody200VolumeName :: Data.Text.Internal.Text
  -- | protection: Protection configuration for the Resource
  , putVolumesIdResponseBody200VolumeProtection :: PutVolumesIdResponseBody200VolumeProtection
  -- | server: ID of the Server the Volume is attached to, null if it is not attached at all
  , putVolumesIdResponseBody200VolumeServer :: GHC.Integer.Type.Integer
  -- | size: Size in GB of the Volume
  , putVolumesIdResponseBody200VolumeSize :: GHC.Types.Double
  -- | status: Current status of the Volume
  , putVolumesIdResponseBody200VolumeStatus :: PutVolumesIdResponseBody200VolumeStatus
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PutVolumesIdResponseBody200Volume
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "created" (putVolumesIdResponseBody200VolumeCreated obj) : (Data.Aeson..=) "format" (putVolumesIdResponseBody200VolumeFormat obj) : (Data.Aeson..=) "id" (putVolumesIdResponseBody200VolumeId obj) : (Data.Aeson..=) "labels" (putVolumesIdResponseBody200VolumeLabels obj) : (Data.Aeson..=) "linux_device" (putVolumesIdResponseBody200VolumeLinuxDevice obj) : (Data.Aeson..=) "location" (putVolumesIdResponseBody200VolumeLocation obj) : (Data.Aeson..=) "name" (putVolumesIdResponseBody200VolumeName obj) : (Data.Aeson..=) "protection" (putVolumesIdResponseBody200VolumeProtection obj) : (Data.Aeson..=) "server" (putVolumesIdResponseBody200VolumeServer obj) : (Data.Aeson..=) "size" (putVolumesIdResponseBody200VolumeSize obj) : (Data.Aeson..=) "status" (putVolumesIdResponseBody200VolumeStatus obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "created" (putVolumesIdResponseBody200VolumeCreated obj) GHC.Base.<> ((Data.Aeson..=) "format" (putVolumesIdResponseBody200VolumeFormat obj) GHC.Base.<> ((Data.Aeson..=) "id" (putVolumesIdResponseBody200VolumeId obj) GHC.Base.<> ((Data.Aeson..=) "labels" (putVolumesIdResponseBody200VolumeLabels obj) GHC.Base.<> ((Data.Aeson..=) "linux_device" (putVolumesIdResponseBody200VolumeLinuxDevice obj) GHC.Base.<> ((Data.Aeson..=) "location" (putVolumesIdResponseBody200VolumeLocation obj) GHC.Base.<> ((Data.Aeson..=) "name" (putVolumesIdResponseBody200VolumeName obj) GHC.Base.<> ((Data.Aeson..=) "protection" (putVolumesIdResponseBody200VolumeProtection obj) GHC.Base.<> ((Data.Aeson..=) "server" (putVolumesIdResponseBody200VolumeServer obj) GHC.Base.<> ((Data.Aeson..=) "size" (putVolumesIdResponseBody200VolumeSize obj) GHC.Base.<> (Data.Aeson..=) "status" (putVolumesIdResponseBody200VolumeStatus obj)))))))))))
instance Data.Aeson.Types.FromJSON.FromJSON PutVolumesIdResponseBody200Volume
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutVolumesIdResponseBody200Volume" (\obj -> ((((((((((GHC.Base.pure PutVolumesIdResponseBody200Volume GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "format")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "labels")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "linux_device")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "location")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "protection")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "server")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "size")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status"))
-- | Defines the data type for the schema PutVolumesIdResponseBody200VolumeLabels
-- 
-- User-defined labels (key-value pairs)
data PutVolumesIdResponseBody200VolumeLabels = PutVolumesIdResponseBody200VolumeLabels {
  
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PutVolumesIdResponseBody200VolumeLabels
    where toJSON obj = Data.Aeson.object []
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "string" ("string" :: GHC.Base.String))
instance Data.Aeson.Types.FromJSON.FromJSON PutVolumesIdResponseBody200VolumeLabels
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutVolumesIdResponseBody200VolumeLabels" (\obj -> GHC.Base.pure PutVolumesIdResponseBody200VolumeLabels)
-- | Defines the data type for the schema PutVolumesIdResponseBody200VolumeLocation
-- 
-- Location of the Volume. Volume can only be attached to Servers in the same Location.
data PutVolumesIdResponseBody200VolumeLocation = PutVolumesIdResponseBody200VolumeLocation {
  -- | city: City the Location is closest to
  putVolumesIdResponseBody200VolumeLocationCity :: Data.Text.Internal.Text
  -- | country: ISO 3166-1 alpha-2 code of the country the Location resides in
  , putVolumesIdResponseBody200VolumeLocationCountry :: Data.Text.Internal.Text
  -- | description: Description of the Location
  , putVolumesIdResponseBody200VolumeLocationDescription :: Data.Text.Internal.Text
  -- | id: ID of the Location
  , putVolumesIdResponseBody200VolumeLocationId :: GHC.Types.Double
  -- | latitude: Latitude of the city closest to the Location
  , putVolumesIdResponseBody200VolumeLocationLatitude :: GHC.Types.Double
  -- | longitude: Longitude of the city closest to the Location
  , putVolumesIdResponseBody200VolumeLocationLongitude :: GHC.Types.Double
  -- | name: Unique identifier of the Location
  , putVolumesIdResponseBody200VolumeLocationName :: Data.Text.Internal.Text
  -- | network_zone: Name of network zone this Location resides in
  , putVolumesIdResponseBody200VolumeLocationNetworkZone :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PutVolumesIdResponseBody200VolumeLocation
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "city" (putVolumesIdResponseBody200VolumeLocationCity obj) : (Data.Aeson..=) "country" (putVolumesIdResponseBody200VolumeLocationCountry obj) : (Data.Aeson..=) "description" (putVolumesIdResponseBody200VolumeLocationDescription obj) : (Data.Aeson..=) "id" (putVolumesIdResponseBody200VolumeLocationId obj) : (Data.Aeson..=) "latitude" (putVolumesIdResponseBody200VolumeLocationLatitude obj) : (Data.Aeson..=) "longitude" (putVolumesIdResponseBody200VolumeLocationLongitude obj) : (Data.Aeson..=) "name" (putVolumesIdResponseBody200VolumeLocationName obj) : (Data.Aeson..=) "network_zone" (putVolumesIdResponseBody200VolumeLocationNetworkZone obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "city" (putVolumesIdResponseBody200VolumeLocationCity obj) GHC.Base.<> ((Data.Aeson..=) "country" (putVolumesIdResponseBody200VolumeLocationCountry obj) GHC.Base.<> ((Data.Aeson..=) "description" (putVolumesIdResponseBody200VolumeLocationDescription obj) GHC.Base.<> ((Data.Aeson..=) "id" (putVolumesIdResponseBody200VolumeLocationId obj) GHC.Base.<> ((Data.Aeson..=) "latitude" (putVolumesIdResponseBody200VolumeLocationLatitude obj) GHC.Base.<> ((Data.Aeson..=) "longitude" (putVolumesIdResponseBody200VolumeLocationLongitude obj) GHC.Base.<> ((Data.Aeson..=) "name" (putVolumesIdResponseBody200VolumeLocationName obj) GHC.Base.<> (Data.Aeson..=) "network_zone" (putVolumesIdResponseBody200VolumeLocationNetworkZone obj))))))))
instance Data.Aeson.Types.FromJSON.FromJSON PutVolumesIdResponseBody200VolumeLocation
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutVolumesIdResponseBody200VolumeLocation" (\obj -> (((((((GHC.Base.pure PutVolumesIdResponseBody200VolumeLocation GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "city")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "country")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "latitude")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "longitude")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "network_zone"))
-- | Defines the data type for the schema PutVolumesIdResponseBody200VolumeProtection
-- 
-- Protection configuration for the Resource
data PutVolumesIdResponseBody200VolumeProtection = PutVolumesIdResponseBody200VolumeProtection {
  -- | delete: If true, prevents the Resource from being deleted
  putVolumesIdResponseBody200VolumeProtectionDelete :: GHC.Types.Bool
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PutVolumesIdResponseBody200VolumeProtection
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "delete" (putVolumesIdResponseBody200VolumeProtectionDelete obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "delete" (putVolumesIdResponseBody200VolumeProtectionDelete obj))
instance Data.Aeson.Types.FromJSON.FromJSON PutVolumesIdResponseBody200VolumeProtection
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutVolumesIdResponseBody200VolumeProtection" (\obj -> GHC.Base.pure PutVolumesIdResponseBody200VolumeProtection GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "delete"))
-- | Defines the enum schema PutVolumesIdResponseBody200VolumeStatus
-- 
-- Current status of the Volume
data PutVolumesIdResponseBody200VolumeStatus
    = PutVolumesIdResponseBody200VolumeStatusEnumOther Data.Aeson.Types.Internal.Value
    | PutVolumesIdResponseBody200VolumeStatusEnumTyped Data.Text.Internal.Text
    | PutVolumesIdResponseBody200VolumeStatusEnumStringAvailable
    | PutVolumesIdResponseBody200VolumeStatusEnumStringCreating
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON PutVolumesIdResponseBody200VolumeStatus
    where toJSON (PutVolumesIdResponseBody200VolumeStatusEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PutVolumesIdResponseBody200VolumeStatusEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PutVolumesIdResponseBody200VolumeStatusEnumStringAvailable) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "available"
          toJSON (PutVolumesIdResponseBody200VolumeStatusEnumStringCreating) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "creating"
instance Data.Aeson.FromJSON PutVolumesIdResponseBody200VolumeStatus
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "available")
                                          then PutVolumesIdResponseBody200VolumeStatusEnumStringAvailable
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "creating")
                                                then PutVolumesIdResponseBody200VolumeStatusEnumStringCreating
                                                else PutVolumesIdResponseBody200VolumeStatusEnumOther val)
