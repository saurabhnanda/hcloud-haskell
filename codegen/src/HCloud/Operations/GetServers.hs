-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE DeriveGeneric #-}

-- | Contains the different functions to run the operation getServers
module HCloud.Operations.GetServers where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Either
import qualified Data.Functor
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Generics
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified HCloud.Common
import HCloud.Types

-- | > GET /servers
-- 
-- Returns all existing Server objects
getServers :: forall m s . (HCloud.Common.MonadHTTP m, HCloud.Common.SecurityScheme s) => HCloud.Common.Configuration s  -- ^ The configuration to use in the request
  -> GHC.Maybe.Maybe Data.Text.Internal.Text                                                                                -- ^ name: Can be used to filter resources by their name. The response will only contain the resources matching the specified name
  -> GHC.Maybe.Maybe Data.Text.Internal.Text                                                                                -- ^ label_selector: Can be used to filter resources by labels. The response will only contain resources matching the label selector.
  -> GHC.Maybe.Maybe Data.Text.Internal.Text                                                                                -- ^ sort: Can be used multiple times.
  -> GHC.Maybe.Maybe Data.Text.Internal.Text                                                                                -- ^ status: Can be used multiple times. The response will only contain Server matching the status
  -> m (Data.Either.Either Network.HTTP.Client.Types.HttpException (Network.HTTP.Client.Types.Response GetServersResponse)) -- ^ Monad containing the result of the operation
getServers config
           name
           labelSelector
           sort
           status = GHC.Base.fmap (GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either GetServersResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetServersResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                  GetServersResponseBody200)
                                                                                                                                                                        | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0)) (HCloud.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack "/servers") ((Data.Text.pack "name",
                                                                                                                                                                                                                                                                                                                                                                                                            HCloud.Common.stringifyModel Data.Functor.<$> name) : ((Data.Text.pack "label_selector",
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     HCloud.Common.stringifyModel Data.Functor.<$> labelSelector) : ((Data.Text.pack "sort",
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       HCloud.Common.stringifyModel Data.Functor.<$> sort) : ((Data.Text.pack "status",
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                HCloud.Common.stringifyModel Data.Functor.<$> status) : [])))))
-- | > GET /servers
-- 
-- The same as 'getServers' but returns the raw 'Data.ByteString.Char8.ByteString'
getServersRaw :: forall m s . (HCloud.Common.MonadHTTP m,
                               HCloud.Common.SecurityScheme s) =>
                 HCloud.Common.Configuration s ->
                 GHC.Maybe.Maybe Data.Text.Internal.Text ->
                 GHC.Maybe.Maybe Data.Text.Internal.Text ->
                 GHC.Maybe.Maybe Data.Text.Internal.Text ->
                 GHC.Maybe.Maybe Data.Text.Internal.Text ->
                 m (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                       (Network.HTTP.Client.Types.Response Data.ByteString.Internal.ByteString))
getServersRaw config
              name
              labelSelector
              sort
              status = GHC.Base.id (HCloud.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack "/servers") ((Data.Text.pack "name",
                                                                                                                                                                    HCloud.Common.stringifyModel Data.Functor.<$> name) : ((Data.Text.pack "label_selector",
                                                                                                                                                                                                                             HCloud.Common.stringifyModel Data.Functor.<$> labelSelector) : ((Data.Text.pack "sort",
                                                                                                                                                                                                                                                                                               HCloud.Common.stringifyModel Data.Functor.<$> sort) : ((Data.Text.pack "status",
                                                                                                                                                                                                                                                                                                                                                        HCloud.Common.stringifyModel Data.Functor.<$> status) : [])))))
-- | > GET /servers
-- 
-- Monadic version of 'getServers' (use with 'HCloud.Common.runWithConfiguration')
getServersM :: forall m s . (HCloud.Common.MonadHTTP m,
                             HCloud.Common.SecurityScheme s) =>
               GHC.Maybe.Maybe Data.Text.Internal.Text ->
               GHC.Maybe.Maybe Data.Text.Internal.Text ->
               GHC.Maybe.Maybe Data.Text.Internal.Text ->
               GHC.Maybe.Maybe Data.Text.Internal.Text ->
               Control.Monad.Trans.Reader.ReaderT (HCloud.Common.Configuration s)
                                                  m
                                                  (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                                                      (Network.HTTP.Client.Types.Response GetServersResponse))
getServersM name
            labelSelector
            sort
            status = GHC.Base.fmap (GHC.Base.fmap (\response_2 -> GHC.Base.fmap (Data.Either.either GetServersResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetServersResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                   GetServersResponseBody200)
                                                                                                                                                                         | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_2) response_2)) (HCloud.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack "/servers") ((Data.Text.pack "name",
                                                                                                                                                                                                                                                                                                                                                                                                       HCloud.Common.stringifyModel Data.Functor.<$> name) : ((Data.Text.pack "label_selector",
                                                                                                                                                                                                                                                                                                                                                                                                                                                                HCloud.Common.stringifyModel Data.Functor.<$> labelSelector) : ((Data.Text.pack "sort",
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  HCloud.Common.stringifyModel Data.Functor.<$> sort) : ((Data.Text.pack "status",
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           HCloud.Common.stringifyModel Data.Functor.<$> status) : [])))))
-- | > GET /servers
-- 
-- Monadic version of 'getServersRaw' (use with 'HCloud.Common.runWithConfiguration')
getServersRawM :: forall m s . (HCloud.Common.MonadHTTP m,
                                HCloud.Common.SecurityScheme s) =>
                  GHC.Maybe.Maybe Data.Text.Internal.Text ->
                  GHC.Maybe.Maybe Data.Text.Internal.Text ->
                  GHC.Maybe.Maybe Data.Text.Internal.Text ->
                  GHC.Maybe.Maybe Data.Text.Internal.Text ->
                  Control.Monad.Trans.Reader.ReaderT (HCloud.Common.Configuration s)
                                                     m
                                                     (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                                                         (Network.HTTP.Client.Types.Response Data.ByteString.Internal.ByteString))
getServersRawM name
               labelSelector
               sort
               status = GHC.Base.id (HCloud.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack "/servers") ((Data.Text.pack "name",
                                                                                                                                                               HCloud.Common.stringifyModel Data.Functor.<$> name) : ((Data.Text.pack "label_selector",
                                                                                                                                                                                                                        HCloud.Common.stringifyModel Data.Functor.<$> labelSelector) : ((Data.Text.pack "sort",
                                                                                                                                                                                                                                                                                          HCloud.Common.stringifyModel Data.Functor.<$> sort) : ((Data.Text.pack "status",
                                                                                                                                                                                                                                                                                                                                                   HCloud.Common.stringifyModel Data.Functor.<$> status) : [])))))
-- | Represents a response of the operation 'getServers'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'GetServersResponseError' is used.
data GetServersResponse =                            
   GetServersResponseError GHC.Base.String           -- ^ Means either no matching case available or a parse error
  | GetServersResponse200 GetServersResponseBody200  -- ^ A paged array of servers
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the data type for the schema GetServersResponseBody200
-- 
-- 
data GetServersResponseBody200 = GetServersResponseBody200 {
  -- | meta
  getServersResponseBody200Meta :: (GHC.Maybe.Maybe GetServersResponseBody200Meta)
  -- | servers
  , getServersResponseBody200Servers :: ([] GetServersResponseBody200Servers)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "meta" (getServersResponseBody200Meta obj) : (Data.Aeson..=) "servers" (getServersResponseBody200Servers obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "meta" (getServersResponseBody200Meta obj) GHC.Base.<> (Data.Aeson..=) "servers" (getServersResponseBody200Servers obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200" (\obj -> (GHC.Base.pure GetServersResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "meta")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "servers"))
-- | Defines the data type for the schema GetServersResponseBody200Meta
-- 
-- 
data GetServersResponseBody200Meta = GetServersResponseBody200Meta {
  -- | pagination
  getServersResponseBody200MetaPagination :: GetServersResponseBody200MetaPagination
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200Meta
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "pagination" (getServersResponseBody200MetaPagination obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "pagination" (getServersResponseBody200MetaPagination obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200Meta
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200Meta" (\obj -> GHC.Base.pure GetServersResponseBody200Meta GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pagination"))
-- | Defines the data type for the schema GetServersResponseBody200MetaPagination
-- 
-- 
data GetServersResponseBody200MetaPagination = GetServersResponseBody200MetaPagination {
  -- | last_page: ID of the last page available. Can be null if the current page is the last one.
  getServersResponseBody200MetaPaginationLastPage :: GHC.Types.Double
  -- | next_page: ID of the next page. Can be null if the current page is the last one.
  , getServersResponseBody200MetaPaginationNextPage :: GHC.Types.Double
  -- | page: Current page number
  , getServersResponseBody200MetaPaginationPage :: GHC.Types.Double
  -- | per_page: Maximum number of items shown per page in the response
  , getServersResponseBody200MetaPaginationPerPage :: GHC.Types.Double
  -- | previous_page: ID of the previous page. Can be null if the current page is the first one.
  , getServersResponseBody200MetaPaginationPreviousPage :: GHC.Types.Double
  -- | total_entries: The total number of entries that exist in the database for this query. Nullable if unknown.
  , getServersResponseBody200MetaPaginationTotalEntries :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200MetaPagination
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "last_page" (getServersResponseBody200MetaPaginationLastPage obj) : (Data.Aeson..=) "next_page" (getServersResponseBody200MetaPaginationNextPage obj) : (Data.Aeson..=) "page" (getServersResponseBody200MetaPaginationPage obj) : (Data.Aeson..=) "per_page" (getServersResponseBody200MetaPaginationPerPage obj) : (Data.Aeson..=) "previous_page" (getServersResponseBody200MetaPaginationPreviousPage obj) : (Data.Aeson..=) "total_entries" (getServersResponseBody200MetaPaginationTotalEntries obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "last_page" (getServersResponseBody200MetaPaginationLastPage obj) GHC.Base.<> ((Data.Aeson..=) "next_page" (getServersResponseBody200MetaPaginationNextPage obj) GHC.Base.<> ((Data.Aeson..=) "page" (getServersResponseBody200MetaPaginationPage obj) GHC.Base.<> ((Data.Aeson..=) "per_page" (getServersResponseBody200MetaPaginationPerPage obj) GHC.Base.<> ((Data.Aeson..=) "previous_page" (getServersResponseBody200MetaPaginationPreviousPage obj) GHC.Base.<> (Data.Aeson..=) "total_entries" (getServersResponseBody200MetaPaginationTotalEntries obj))))))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200MetaPagination
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200MetaPagination" (\obj -> (((((GHC.Base.pure GetServersResponseBody200MetaPagination GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "last_page")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "next_page")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "page")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "per_page")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "previous_page")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "total_entries"))
-- | Defines the data type for the schema GetServersResponseBody200Servers
-- 
-- 
data GetServersResponseBody200Servers = GetServersResponseBody200Servers {
  -- | backup_window: Time window (UTC) in which the backup will run, or null if the backups are not enabled
  getServersResponseBody200ServersBackupWindow :: Data.Text.Internal.Text
  -- | created: Point in time when the Resource was created (in ISO-8601 format)
  , getServersResponseBody200ServersCreated :: Data.Text.Internal.Text
  -- | datacenter: Datacenter this Resource is located at
  , getServersResponseBody200ServersDatacenter :: GetServersResponseBody200ServersDatacenter
  -- | id: ID of the Resource
  , getServersResponseBody200ServersId :: GHC.Integer.Type.Integer
  -- | image
  , getServersResponseBody200ServersImage :: GetServersResponseBody200ServersImage
  -- | included_traffic: Free Traffic for the current billing period in bytes
  , getServersResponseBody200ServersIncludedTraffic :: GHC.Types.Double
  -- | ingoing_traffic: Inbound Traffic for the current billing period in bytes
  , getServersResponseBody200ServersIngoingTraffic :: GHC.Types.Double
  -- | iso: ISO Image that is attached to this Server. Null if no ISO is attached.
  , getServersResponseBody200ServersIso :: GetServersResponseBody200ServersIso
  -- | labels: User-defined labels (key-value pairs)
  , getServersResponseBody200ServersLabels :: GetServersResponseBody200ServersLabels
  -- | load_balancers
  , getServersResponseBody200ServersLoadBalancers :: (GHC.Maybe.Maybe ([] GHC.Integer.Type.Integer))
  -- | locked: True if Server has been locked and is not available to user
  , getServersResponseBody200ServersLocked :: GHC.Types.Bool
  -- | name: Name of the Resource. Must be unique per Project.
  , getServersResponseBody200ServersName :: Data.Text.Internal.Text
  -- | outgoing_traffic: Outbound Traffic for the current billing period in bytes
  , getServersResponseBody200ServersOutgoingTraffic :: GHC.Types.Double
  -- | placement_group
  , getServersResponseBody200ServersPlacementGroup :: (GHC.Maybe.Maybe GetServersResponseBody200ServersPlacementGroup)
  -- | primary_disk_size: Size of the primary Disk
  , getServersResponseBody200ServersPrimaryDiskSize :: GHC.Types.Double
  -- | private_net: Private networks information
  , getServersResponseBody200ServersPrivateNet :: ([] GetServersResponseBody200ServersPrivateNet)
  -- | protection: Protection configuration for the Server
  , getServersResponseBody200ServersProtection :: GetServersResponseBody200ServersProtection
  -- | public_net: Public network information. The Server\'s IPv4 address can be found in \`public_net->ipv4->ip\`
  , getServersResponseBody200ServersPublicNet :: GetServersResponseBody200ServersPublicNet
  -- | rescue_enabled: True if rescue mode is enabled. Server will then boot into rescue system on next reboot
  , getServersResponseBody200ServersRescueEnabled :: GHC.Types.Bool
  -- | server_type: Type of Server - determines how much ram, disk and cpu a Server has
  , getServersResponseBody200ServersServerType :: GetServersResponseBody200ServersServerType
  -- | status: Status of the Server
  , getServersResponseBody200ServersStatus :: GetServersResponseBody200ServersStatus
  -- | volumes: IDs of Volumes assigned to this Server
  , getServersResponseBody200ServersVolumes :: (GHC.Maybe.Maybe ([] GHC.Integer.Type.Integer))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200Servers
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "backup_window" (getServersResponseBody200ServersBackupWindow obj) : (Data.Aeson..=) "created" (getServersResponseBody200ServersCreated obj) : (Data.Aeson..=) "datacenter" (getServersResponseBody200ServersDatacenter obj) : (Data.Aeson..=) "id" (getServersResponseBody200ServersId obj) : (Data.Aeson..=) "image" (getServersResponseBody200ServersImage obj) : (Data.Aeson..=) "included_traffic" (getServersResponseBody200ServersIncludedTraffic obj) : (Data.Aeson..=) "ingoing_traffic" (getServersResponseBody200ServersIngoingTraffic obj) : (Data.Aeson..=) "iso" (getServersResponseBody200ServersIso obj) : (Data.Aeson..=) "labels" (getServersResponseBody200ServersLabels obj) : (Data.Aeson..=) "load_balancers" (getServersResponseBody200ServersLoadBalancers obj) : (Data.Aeson..=) "locked" (getServersResponseBody200ServersLocked obj) : (Data.Aeson..=) "name" (getServersResponseBody200ServersName obj) : (Data.Aeson..=) "outgoing_traffic" (getServersResponseBody200ServersOutgoingTraffic obj) : (Data.Aeson..=) "placement_group" (getServersResponseBody200ServersPlacementGroup obj) : (Data.Aeson..=) "primary_disk_size" (getServersResponseBody200ServersPrimaryDiskSize obj) : (Data.Aeson..=) "private_net" (getServersResponseBody200ServersPrivateNet obj) : (Data.Aeson..=) "protection" (getServersResponseBody200ServersProtection obj) : (Data.Aeson..=) "public_net" (getServersResponseBody200ServersPublicNet obj) : (Data.Aeson..=) "rescue_enabled" (getServersResponseBody200ServersRescueEnabled obj) : (Data.Aeson..=) "server_type" (getServersResponseBody200ServersServerType obj) : (Data.Aeson..=) "status" (getServersResponseBody200ServersStatus obj) : (Data.Aeson..=) "volumes" (getServersResponseBody200ServersVolumes obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "backup_window" (getServersResponseBody200ServersBackupWindow obj) GHC.Base.<> ((Data.Aeson..=) "created" (getServersResponseBody200ServersCreated obj) GHC.Base.<> ((Data.Aeson..=) "datacenter" (getServersResponseBody200ServersDatacenter obj) GHC.Base.<> ((Data.Aeson..=) "id" (getServersResponseBody200ServersId obj) GHC.Base.<> ((Data.Aeson..=) "image" (getServersResponseBody200ServersImage obj) GHC.Base.<> ((Data.Aeson..=) "included_traffic" (getServersResponseBody200ServersIncludedTraffic obj) GHC.Base.<> ((Data.Aeson..=) "ingoing_traffic" (getServersResponseBody200ServersIngoingTraffic obj) GHC.Base.<> ((Data.Aeson..=) "iso" (getServersResponseBody200ServersIso obj) GHC.Base.<> ((Data.Aeson..=) "labels" (getServersResponseBody200ServersLabels obj) GHC.Base.<> ((Data.Aeson..=) "load_balancers" (getServersResponseBody200ServersLoadBalancers obj) GHC.Base.<> ((Data.Aeson..=) "locked" (getServersResponseBody200ServersLocked obj) GHC.Base.<> ((Data.Aeson..=) "name" (getServersResponseBody200ServersName obj) GHC.Base.<> ((Data.Aeson..=) "outgoing_traffic" (getServersResponseBody200ServersOutgoingTraffic obj) GHC.Base.<> ((Data.Aeson..=) "placement_group" (getServersResponseBody200ServersPlacementGroup obj) GHC.Base.<> ((Data.Aeson..=) "primary_disk_size" (getServersResponseBody200ServersPrimaryDiskSize obj) GHC.Base.<> ((Data.Aeson..=) "private_net" (getServersResponseBody200ServersPrivateNet obj) GHC.Base.<> ((Data.Aeson..=) "protection" (getServersResponseBody200ServersProtection obj) GHC.Base.<> ((Data.Aeson..=) "public_net" (getServersResponseBody200ServersPublicNet obj) GHC.Base.<> ((Data.Aeson..=) "rescue_enabled" (getServersResponseBody200ServersRescueEnabled obj) GHC.Base.<> ((Data.Aeson..=) "server_type" (getServersResponseBody200ServersServerType obj) GHC.Base.<> ((Data.Aeson..=) "status" (getServersResponseBody200ServersStatus obj) GHC.Base.<> (Data.Aeson..=) "volumes" (getServersResponseBody200ServersVolumes obj))))))))))))))))))))))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200Servers
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200Servers" (\obj -> (((((((((((((((((((((GHC.Base.pure GetServersResponseBody200Servers GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "backup_window")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "datacenter")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "image")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "included_traffic")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ingoing_traffic")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "iso")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "labels")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "load_balancers")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "locked")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "outgoing_traffic")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "placement_group")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "primary_disk_size")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "private_net")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "protection")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "public_net")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "rescue_enabled")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "server_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "volumes"))
-- | Defines the data type for the schema GetServersResponseBody200ServersDatacenter
-- 
-- Datacenter this Resource is located at
data GetServersResponseBody200ServersDatacenter = GetServersResponseBody200ServersDatacenter {
  -- | description: Description of the Datacenter
  getServersResponseBody200ServersDatacenterDescription :: Data.Text.Internal.Text
  -- | id: ID of the Resource
  , getServersResponseBody200ServersDatacenterId :: GHC.Integer.Type.Integer
  -- | location
  , getServersResponseBody200ServersDatacenterLocation :: GetServersResponseBody200ServersDatacenterLocation
  -- | name: Unique identifier of the Datacenter
  , getServersResponseBody200ServersDatacenterName :: Data.Text.Internal.Text
  -- | server_types: The Server types the Datacenter can handle
  , getServersResponseBody200ServersDatacenterServerTypes :: GetServersResponseBody200ServersDatacenterServerTypes
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersDatacenter
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "description" (getServersResponseBody200ServersDatacenterDescription obj) : (Data.Aeson..=) "id" (getServersResponseBody200ServersDatacenterId obj) : (Data.Aeson..=) "location" (getServersResponseBody200ServersDatacenterLocation obj) : (Data.Aeson..=) "name" (getServersResponseBody200ServersDatacenterName obj) : (Data.Aeson..=) "server_types" (getServersResponseBody200ServersDatacenterServerTypes obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "description" (getServersResponseBody200ServersDatacenterDescription obj) GHC.Base.<> ((Data.Aeson..=) "id" (getServersResponseBody200ServersDatacenterId obj) GHC.Base.<> ((Data.Aeson..=) "location" (getServersResponseBody200ServersDatacenterLocation obj) GHC.Base.<> ((Data.Aeson..=) "name" (getServersResponseBody200ServersDatacenterName obj) GHC.Base.<> (Data.Aeson..=) "server_types" (getServersResponseBody200ServersDatacenterServerTypes obj)))))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200ServersDatacenter
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200ServersDatacenter" (\obj -> ((((GHC.Base.pure GetServersResponseBody200ServersDatacenter GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "location")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "server_types"))
-- | Defines the data type for the schema GetServersResponseBody200ServersDatacenterLocation
-- 
-- 
data GetServersResponseBody200ServersDatacenterLocation = GetServersResponseBody200ServersDatacenterLocation {
  -- | city: City the Location is closest to
  getServersResponseBody200ServersDatacenterLocationCity :: Data.Text.Internal.Text
  -- | country: ISO 3166-1 alpha-2 code of the country the Location resides in
  , getServersResponseBody200ServersDatacenterLocationCountry :: Data.Text.Internal.Text
  -- | description: Description of the Location
  , getServersResponseBody200ServersDatacenterLocationDescription :: Data.Text.Internal.Text
  -- | id: ID of the Location
  , getServersResponseBody200ServersDatacenterLocationId :: GHC.Types.Double
  -- | latitude: Latitude of the city closest to the Location
  , getServersResponseBody200ServersDatacenterLocationLatitude :: GHC.Types.Double
  -- | longitude: Longitude of the city closest to the Location
  , getServersResponseBody200ServersDatacenterLocationLongitude :: GHC.Types.Double
  -- | name: Unique identifier of the Location
  , getServersResponseBody200ServersDatacenterLocationName :: Data.Text.Internal.Text
  -- | network_zone: Name of network zone this Location resides in
  , getServersResponseBody200ServersDatacenterLocationNetworkZone :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersDatacenterLocation
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "city" (getServersResponseBody200ServersDatacenterLocationCity obj) : (Data.Aeson..=) "country" (getServersResponseBody200ServersDatacenterLocationCountry obj) : (Data.Aeson..=) "description" (getServersResponseBody200ServersDatacenterLocationDescription obj) : (Data.Aeson..=) "id" (getServersResponseBody200ServersDatacenterLocationId obj) : (Data.Aeson..=) "latitude" (getServersResponseBody200ServersDatacenterLocationLatitude obj) : (Data.Aeson..=) "longitude" (getServersResponseBody200ServersDatacenterLocationLongitude obj) : (Data.Aeson..=) "name" (getServersResponseBody200ServersDatacenterLocationName obj) : (Data.Aeson..=) "network_zone" (getServersResponseBody200ServersDatacenterLocationNetworkZone obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "city" (getServersResponseBody200ServersDatacenterLocationCity obj) GHC.Base.<> ((Data.Aeson..=) "country" (getServersResponseBody200ServersDatacenterLocationCountry obj) GHC.Base.<> ((Data.Aeson..=) "description" (getServersResponseBody200ServersDatacenterLocationDescription obj) GHC.Base.<> ((Data.Aeson..=) "id" (getServersResponseBody200ServersDatacenterLocationId obj) GHC.Base.<> ((Data.Aeson..=) "latitude" (getServersResponseBody200ServersDatacenterLocationLatitude obj) GHC.Base.<> ((Data.Aeson..=) "longitude" (getServersResponseBody200ServersDatacenterLocationLongitude obj) GHC.Base.<> ((Data.Aeson..=) "name" (getServersResponseBody200ServersDatacenterLocationName obj) GHC.Base.<> (Data.Aeson..=) "network_zone" (getServersResponseBody200ServersDatacenterLocationNetworkZone obj))))))))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200ServersDatacenterLocation
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200ServersDatacenterLocation" (\obj -> (((((((GHC.Base.pure GetServersResponseBody200ServersDatacenterLocation GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "city")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "country")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "latitude")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "longitude")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "network_zone"))
-- | Defines the data type for the schema GetServersResponseBody200ServersDatacenterServer_types
-- 
-- The Server types the Datacenter can handle
data GetServersResponseBody200ServersDatacenterServerTypes = GetServersResponseBody200ServersDatacenterServerTypes {
  -- | available: IDs of Server types that are supported and for which the Datacenter has enough resources left
  getServersResponseBody200ServersDatacenterServerTypesAvailable :: ([] GHC.Types.Double)
  -- | available_for_migration: IDs of Server types that are supported and for which the Datacenter has enough resources left
  , getServersResponseBody200ServersDatacenterServerTypesAvailableForMigration :: ([] GHC.Types.Double)
  -- | supported: IDs of Server types that are supported in the Datacenter
  , getServersResponseBody200ServersDatacenterServerTypesSupported :: ([] GHC.Types.Double)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersDatacenterServerTypes
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "available" (getServersResponseBody200ServersDatacenterServerTypesAvailable obj) : (Data.Aeson..=) "available_for_migration" (getServersResponseBody200ServersDatacenterServerTypesAvailableForMigration obj) : (Data.Aeson..=) "supported" (getServersResponseBody200ServersDatacenterServerTypesSupported obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "available" (getServersResponseBody200ServersDatacenterServerTypesAvailable obj) GHC.Base.<> ((Data.Aeson..=) "available_for_migration" (getServersResponseBody200ServersDatacenterServerTypesAvailableForMigration obj) GHC.Base.<> (Data.Aeson..=) "supported" (getServersResponseBody200ServersDatacenterServerTypesSupported obj)))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200ServersDatacenterServerTypes
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200ServersDatacenterServerTypes" (\obj -> ((GHC.Base.pure GetServersResponseBody200ServersDatacenterServerTypes GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "available")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "available_for_migration")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "supported"))
-- | Defines the data type for the schema GetServersResponseBody200ServersImage
-- 
-- 
data GetServersResponseBody200ServersImage = GetServersResponseBody200ServersImage {
  -- | bound_to: ID of Server the Image is bound to. Only set for Images of type \`backup\`.
  getServersResponseBody200ServersImageBoundTo :: GHC.Integer.Type.Integer
  -- | build_id: Build ID of the Image
  , getServersResponseBody200ServersImageBuildId :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | created: Point in time when the Resource was created (in ISO-8601 format)
  , getServersResponseBody200ServersImageCreated :: Data.Text.Internal.Text
  -- | created_from: Information about the Server the Image was created from
  , getServersResponseBody200ServersImageCreatedFrom :: GetServersResponseBody200ServersImageCreatedFrom
  -- | deleted: Point in time where the Image was deleted (in ISO-8601 format)
  , getServersResponseBody200ServersImageDeleted :: Data.Text.Internal.Text
  -- | deprecated: Point in time when the Image is considered to be deprecated (in ISO-8601 format)
  , getServersResponseBody200ServersImageDeprecated :: Data.Text.Internal.Text
  -- | description: Description of the Image
  , getServersResponseBody200ServersImageDescription :: Data.Text.Internal.Text
  -- | disk_size: Size of the disk contained in the Image in GB
  , getServersResponseBody200ServersImageDiskSize :: GHC.Types.Double
  -- | id: ID of the Resource
  , getServersResponseBody200ServersImageId :: GHC.Integer.Type.Integer
  -- | image_size: Size of the Image file in our storage in GB. For snapshot Images this is the value relevant for calculating costs for the Image.
  , getServersResponseBody200ServersImageImageSize :: GHC.Types.Double
  -- | labels: User-defined labels (key-value pairs)
  , getServersResponseBody200ServersImageLabels :: GetServersResponseBody200ServersImageLabels
  -- | name: Unique identifier of the Image. This value is only set for system Images.
  , getServersResponseBody200ServersImageName :: Data.Text.Internal.Text
  -- | os_flavor: Flavor of operating system contained in the Image
  , getServersResponseBody200ServersImageOsFlavor :: GetServersResponseBody200ServersImageOsFlavor
  -- | os_version: Operating system version
  , getServersResponseBody200ServersImageOsVersion :: Data.Text.Internal.Text
  -- | protection: Protection configuration for the Resource
  , getServersResponseBody200ServersImageProtection :: GetServersResponseBody200ServersImageProtection
  -- | rapid_deploy: Indicates that rapid deploy of the Image is available
  , getServersResponseBody200ServersImageRapidDeploy :: (GHC.Maybe.Maybe GHC.Types.Bool)
  -- | status: Whether the Image can be used or if it\'s still being created or unavailable
  , getServersResponseBody200ServersImageStatus :: GetServersResponseBody200ServersImageStatus
  -- | type: Type of the Image
  , getServersResponseBody200ServersImageType :: GetServersResponseBody200ServersImageType
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersImage
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "bound_to" (getServersResponseBody200ServersImageBoundTo obj) : (Data.Aeson..=) "build_id" (getServersResponseBody200ServersImageBuildId obj) : (Data.Aeson..=) "created" (getServersResponseBody200ServersImageCreated obj) : (Data.Aeson..=) "created_from" (getServersResponseBody200ServersImageCreatedFrom obj) : (Data.Aeson..=) "deleted" (getServersResponseBody200ServersImageDeleted obj) : (Data.Aeson..=) "deprecated" (getServersResponseBody200ServersImageDeprecated obj) : (Data.Aeson..=) "description" (getServersResponseBody200ServersImageDescription obj) : (Data.Aeson..=) "disk_size" (getServersResponseBody200ServersImageDiskSize obj) : (Data.Aeson..=) "id" (getServersResponseBody200ServersImageId obj) : (Data.Aeson..=) "image_size" (getServersResponseBody200ServersImageImageSize obj) : (Data.Aeson..=) "labels" (getServersResponseBody200ServersImageLabels obj) : (Data.Aeson..=) "name" (getServersResponseBody200ServersImageName obj) : (Data.Aeson..=) "os_flavor" (getServersResponseBody200ServersImageOsFlavor obj) : (Data.Aeson..=) "os_version" (getServersResponseBody200ServersImageOsVersion obj) : (Data.Aeson..=) "protection" (getServersResponseBody200ServersImageProtection obj) : (Data.Aeson..=) "rapid_deploy" (getServersResponseBody200ServersImageRapidDeploy obj) : (Data.Aeson..=) "status" (getServersResponseBody200ServersImageStatus obj) : (Data.Aeson..=) "type" (getServersResponseBody200ServersImageType obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "bound_to" (getServersResponseBody200ServersImageBoundTo obj) GHC.Base.<> ((Data.Aeson..=) "build_id" (getServersResponseBody200ServersImageBuildId obj) GHC.Base.<> ((Data.Aeson..=) "created" (getServersResponseBody200ServersImageCreated obj) GHC.Base.<> ((Data.Aeson..=) "created_from" (getServersResponseBody200ServersImageCreatedFrom obj) GHC.Base.<> ((Data.Aeson..=) "deleted" (getServersResponseBody200ServersImageDeleted obj) GHC.Base.<> ((Data.Aeson..=) "deprecated" (getServersResponseBody200ServersImageDeprecated obj) GHC.Base.<> ((Data.Aeson..=) "description" (getServersResponseBody200ServersImageDescription obj) GHC.Base.<> ((Data.Aeson..=) "disk_size" (getServersResponseBody200ServersImageDiskSize obj) GHC.Base.<> ((Data.Aeson..=) "id" (getServersResponseBody200ServersImageId obj) GHC.Base.<> ((Data.Aeson..=) "image_size" (getServersResponseBody200ServersImageImageSize obj) GHC.Base.<> ((Data.Aeson..=) "labels" (getServersResponseBody200ServersImageLabels obj) GHC.Base.<> ((Data.Aeson..=) "name" (getServersResponseBody200ServersImageName obj) GHC.Base.<> ((Data.Aeson..=) "os_flavor" (getServersResponseBody200ServersImageOsFlavor obj) GHC.Base.<> ((Data.Aeson..=) "os_version" (getServersResponseBody200ServersImageOsVersion obj) GHC.Base.<> ((Data.Aeson..=) "protection" (getServersResponseBody200ServersImageProtection obj) GHC.Base.<> ((Data.Aeson..=) "rapid_deploy" (getServersResponseBody200ServersImageRapidDeploy obj) GHC.Base.<> ((Data.Aeson..=) "status" (getServersResponseBody200ServersImageStatus obj) GHC.Base.<> (Data.Aeson..=) "type" (getServersResponseBody200ServersImageType obj))))))))))))))))))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200ServersImage
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200ServersImage" (\obj -> (((((((((((((((((GHC.Base.pure GetServersResponseBody200ServersImage GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "bound_to")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "build_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created_from")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deleted")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deprecated")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "disk_size")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "image_size")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "labels")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "os_flavor")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "os_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "protection")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "rapid_deploy")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "type"))
-- | Defines the data type for the schema GetServersResponseBody200ServersImageCreated_from
-- 
-- Information about the Server the Image was created from
data GetServersResponseBody200ServersImageCreatedFrom = GetServersResponseBody200ServersImageCreatedFrom {
  -- | id: ID of the Server the Image was created from
  getServersResponseBody200ServersImageCreatedFromId :: GHC.Integer.Type.Integer
  -- | name: Server name at the time the Image was created
  , getServersResponseBody200ServersImageCreatedFromName :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersImageCreatedFrom
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "id" (getServersResponseBody200ServersImageCreatedFromId obj) : (Data.Aeson..=) "name" (getServersResponseBody200ServersImageCreatedFromName obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "id" (getServersResponseBody200ServersImageCreatedFromId obj) GHC.Base.<> (Data.Aeson..=) "name" (getServersResponseBody200ServersImageCreatedFromName obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200ServersImageCreatedFrom
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200ServersImageCreatedFrom" (\obj -> (GHC.Base.pure GetServersResponseBody200ServersImageCreatedFrom GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name"))
-- | Defines the data type for the schema GetServersResponseBody200ServersImageLabels
-- 
-- User-defined labels (key-value pairs)
data GetServersResponseBody200ServersImageLabels = GetServersResponseBody200ServersImageLabels {
  
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersImageLabels
    where toJSON obj = Data.Aeson.object []
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "string" ("string" :: GHC.Base.String))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200ServersImageLabels
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200ServersImageLabels" (\obj -> GHC.Base.pure GetServersResponseBody200ServersImageLabels)
-- | Defines the enum schema GetServersResponseBody200ServersImageOs_flavor
-- 
-- Flavor of operating system contained in the Image
data GetServersResponseBody200ServersImageOsFlavor
    = GetServersResponseBody200ServersImageOsFlavorEnumOther Data.Aeson.Types.Internal.Value
    | GetServersResponseBody200ServersImageOsFlavorEnumTyped Data.Text.Internal.Text
    | GetServersResponseBody200ServersImageOsFlavorEnumStringCentos
    | GetServersResponseBody200ServersImageOsFlavorEnumStringDebian
    | GetServersResponseBody200ServersImageOsFlavorEnumStringFedora
    | GetServersResponseBody200ServersImageOsFlavorEnumStringUbuntu
    | GetServersResponseBody200ServersImageOsFlavorEnumStringUnknown
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersImageOsFlavor
    where toJSON (GetServersResponseBody200ServersImageOsFlavorEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersResponseBody200ServersImageOsFlavorEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersResponseBody200ServersImageOsFlavorEnumStringCentos) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "centos"
          toJSON (GetServersResponseBody200ServersImageOsFlavorEnumStringDebian) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "debian"
          toJSON (GetServersResponseBody200ServersImageOsFlavorEnumStringFedora) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "fedora"
          toJSON (GetServersResponseBody200ServersImageOsFlavorEnumStringUbuntu) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "ubuntu"
          toJSON (GetServersResponseBody200ServersImageOsFlavorEnumStringUnknown) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "unknown"
instance Data.Aeson.FromJSON GetServersResponseBody200ServersImageOsFlavor
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "centos")
                                          then GetServersResponseBody200ServersImageOsFlavorEnumStringCentos
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "debian")
                                                then GetServersResponseBody200ServersImageOsFlavorEnumStringDebian
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "fedora")
                                                      then GetServersResponseBody200ServersImageOsFlavorEnumStringFedora
                                                      else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "ubuntu")
                                                            then GetServersResponseBody200ServersImageOsFlavorEnumStringUbuntu
                                                            else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "unknown")
                                                                  then GetServersResponseBody200ServersImageOsFlavorEnumStringUnknown
                                                                  else GetServersResponseBody200ServersImageOsFlavorEnumOther val)
-- | Defines the data type for the schema GetServersResponseBody200ServersImageProtection
-- 
-- Protection configuration for the Resource
data GetServersResponseBody200ServersImageProtection = GetServersResponseBody200ServersImageProtection {
  -- | delete: If true, prevents the Resource from being deleted
  getServersResponseBody200ServersImageProtectionDelete :: GHC.Types.Bool
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersImageProtection
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "delete" (getServersResponseBody200ServersImageProtectionDelete obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "delete" (getServersResponseBody200ServersImageProtectionDelete obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200ServersImageProtection
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200ServersImageProtection" (\obj -> GHC.Base.pure GetServersResponseBody200ServersImageProtection GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "delete"))
-- | Defines the enum schema GetServersResponseBody200ServersImageStatus
-- 
-- Whether the Image can be used or if it\'s still being created or unavailable
data GetServersResponseBody200ServersImageStatus
    = GetServersResponseBody200ServersImageStatusEnumOther Data.Aeson.Types.Internal.Value
    | GetServersResponseBody200ServersImageStatusEnumTyped Data.Text.Internal.Text
    | GetServersResponseBody200ServersImageStatusEnumStringAvailable
    | GetServersResponseBody200ServersImageStatusEnumStringCreating
    | GetServersResponseBody200ServersImageStatusEnumStringUnavailable
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersImageStatus
    where toJSON (GetServersResponseBody200ServersImageStatusEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersResponseBody200ServersImageStatusEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersResponseBody200ServersImageStatusEnumStringAvailable) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "available"
          toJSON (GetServersResponseBody200ServersImageStatusEnumStringCreating) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "creating"
          toJSON (GetServersResponseBody200ServersImageStatusEnumStringUnavailable) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "unavailable"
instance Data.Aeson.FromJSON GetServersResponseBody200ServersImageStatus
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "available")
                                          then GetServersResponseBody200ServersImageStatusEnumStringAvailable
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "creating")
                                                then GetServersResponseBody200ServersImageStatusEnumStringCreating
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "unavailable")
                                                      then GetServersResponseBody200ServersImageStatusEnumStringUnavailable
                                                      else GetServersResponseBody200ServersImageStatusEnumOther val)
-- | Defines the enum schema GetServersResponseBody200ServersImageType
-- 
-- Type of the Image
data GetServersResponseBody200ServersImageType
    = GetServersResponseBody200ServersImageTypeEnumOther Data.Aeson.Types.Internal.Value
    | GetServersResponseBody200ServersImageTypeEnumTyped Data.Text.Internal.Text
    | GetServersResponseBody200ServersImageTypeEnumStringApp
    | GetServersResponseBody200ServersImageTypeEnumStringBackup
    | GetServersResponseBody200ServersImageTypeEnumStringSnapshot
    | GetServersResponseBody200ServersImageTypeEnumStringSystem
    | GetServersResponseBody200ServersImageTypeEnumStringTemporary
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersImageType
    where toJSON (GetServersResponseBody200ServersImageTypeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersResponseBody200ServersImageTypeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersResponseBody200ServersImageTypeEnumStringApp) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "app"
          toJSON (GetServersResponseBody200ServersImageTypeEnumStringBackup) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "backup"
          toJSON (GetServersResponseBody200ServersImageTypeEnumStringSnapshot) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "snapshot"
          toJSON (GetServersResponseBody200ServersImageTypeEnumStringSystem) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "system"
          toJSON (GetServersResponseBody200ServersImageTypeEnumStringTemporary) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "temporary"
instance Data.Aeson.FromJSON GetServersResponseBody200ServersImageType
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "app")
                                          then GetServersResponseBody200ServersImageTypeEnumStringApp
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "backup")
                                                then GetServersResponseBody200ServersImageTypeEnumStringBackup
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "snapshot")
                                                      then GetServersResponseBody200ServersImageTypeEnumStringSnapshot
                                                      else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "system")
                                                            then GetServersResponseBody200ServersImageTypeEnumStringSystem
                                                            else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "temporary")
                                                                  then GetServersResponseBody200ServersImageTypeEnumStringTemporary
                                                                  else GetServersResponseBody200ServersImageTypeEnumOther val)
-- | Defines the data type for the schema GetServersResponseBody200ServersIso
-- 
-- ISO Image that is attached to this Server. Null if no ISO is attached.
data GetServersResponseBody200ServersIso = GetServersResponseBody200ServersIso {
  -- | deprecated: ISO 8601 timestamp of deprecation, null if ISO is still available. After the deprecation time it will no longer be possible to attach the ISO to Servers.
  getServersResponseBody200ServersIsoDeprecated :: Data.Text.Internal.Text
  -- | description: Description of the ISO
  , getServersResponseBody200ServersIsoDescription :: Data.Text.Internal.Text
  -- | id: ID of the Resource
  , getServersResponseBody200ServersIsoId :: GHC.Integer.Type.Integer
  -- | name: Unique identifier of the ISO. Only set for public ISOs
  , getServersResponseBody200ServersIsoName :: Data.Text.Internal.Text
  -- | type: Type of the ISO
  , getServersResponseBody200ServersIsoType :: GetServersResponseBody200ServersIsoType
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersIso
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "deprecated" (getServersResponseBody200ServersIsoDeprecated obj) : (Data.Aeson..=) "description" (getServersResponseBody200ServersIsoDescription obj) : (Data.Aeson..=) "id" (getServersResponseBody200ServersIsoId obj) : (Data.Aeson..=) "name" (getServersResponseBody200ServersIsoName obj) : (Data.Aeson..=) "type" (getServersResponseBody200ServersIsoType obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "deprecated" (getServersResponseBody200ServersIsoDeprecated obj) GHC.Base.<> ((Data.Aeson..=) "description" (getServersResponseBody200ServersIsoDescription obj) GHC.Base.<> ((Data.Aeson..=) "id" (getServersResponseBody200ServersIsoId obj) GHC.Base.<> ((Data.Aeson..=) "name" (getServersResponseBody200ServersIsoName obj) GHC.Base.<> (Data.Aeson..=) "type" (getServersResponseBody200ServersIsoType obj)))))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200ServersIso
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200ServersIso" (\obj -> ((((GHC.Base.pure GetServersResponseBody200ServersIso GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deprecated")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "type"))
-- | Defines the enum schema GetServersResponseBody200ServersIsoType
-- 
-- Type of the ISO
data GetServersResponseBody200ServersIsoType
    = GetServersResponseBody200ServersIsoTypeEnumOther Data.Aeson.Types.Internal.Value
    | GetServersResponseBody200ServersIsoTypeEnumTyped Data.Text.Internal.Text
    | GetServersResponseBody200ServersIsoTypeEnumStringPrivate
    | GetServersResponseBody200ServersIsoTypeEnumStringPublic
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersIsoType
    where toJSON (GetServersResponseBody200ServersIsoTypeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersResponseBody200ServersIsoTypeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersResponseBody200ServersIsoTypeEnumStringPrivate) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "private"
          toJSON (GetServersResponseBody200ServersIsoTypeEnumStringPublic) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "public"
instance Data.Aeson.FromJSON GetServersResponseBody200ServersIsoType
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "private")
                                          then GetServersResponseBody200ServersIsoTypeEnumStringPrivate
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "public")
                                                then GetServersResponseBody200ServersIsoTypeEnumStringPublic
                                                else GetServersResponseBody200ServersIsoTypeEnumOther val)
-- | Defines the data type for the schema GetServersResponseBody200ServersLabels
-- 
-- User-defined labels (key-value pairs)
data GetServersResponseBody200ServersLabels = GetServersResponseBody200ServersLabels {
  
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersLabels
    where toJSON obj = Data.Aeson.object []
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "string" ("string" :: GHC.Base.String))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200ServersLabels
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200ServersLabels" (\obj -> GHC.Base.pure GetServersResponseBody200ServersLabels)
-- | Defines the data type for the schema GetServersResponseBody200ServersPlacement_group
-- 
-- 
data GetServersResponseBody200ServersPlacementGroup = GetServersResponseBody200ServersPlacementGroup {
  -- | created: Point in time when the Resource was created (in ISO-8601 format)
  getServersResponseBody200ServersPlacementGroupCreated :: Data.Text.Internal.Text
  -- | id: ID of the Resource
  , getServersResponseBody200ServersPlacementGroupId :: GHC.Integer.Type.Integer
  -- | labels: User-defined labels (key-value pairs)
  , getServersResponseBody200ServersPlacementGroupLabels :: GetServersResponseBody200ServersPlacementGroupLabels
  -- | name: Name of the Resource. Must be unique per Project.
  , getServersResponseBody200ServersPlacementGroupName :: Data.Text.Internal.Text
  -- | servers: Array of IDs of Servers that are part of this Placement Group
  , getServersResponseBody200ServersPlacementGroupServers :: ([] GHC.Integer.Type.Integer)
  -- | type: Type of the Placement Group
  , getServersResponseBody200ServersPlacementGroupType :: GetServersResponseBody200ServersPlacementGroupType
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersPlacementGroup
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "created" (getServersResponseBody200ServersPlacementGroupCreated obj) : (Data.Aeson..=) "id" (getServersResponseBody200ServersPlacementGroupId obj) : (Data.Aeson..=) "labels" (getServersResponseBody200ServersPlacementGroupLabels obj) : (Data.Aeson..=) "name" (getServersResponseBody200ServersPlacementGroupName obj) : (Data.Aeson..=) "servers" (getServersResponseBody200ServersPlacementGroupServers obj) : (Data.Aeson..=) "type" (getServersResponseBody200ServersPlacementGroupType obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "created" (getServersResponseBody200ServersPlacementGroupCreated obj) GHC.Base.<> ((Data.Aeson..=) "id" (getServersResponseBody200ServersPlacementGroupId obj) GHC.Base.<> ((Data.Aeson..=) "labels" (getServersResponseBody200ServersPlacementGroupLabels obj) GHC.Base.<> ((Data.Aeson..=) "name" (getServersResponseBody200ServersPlacementGroupName obj) GHC.Base.<> ((Data.Aeson..=) "servers" (getServersResponseBody200ServersPlacementGroupServers obj) GHC.Base.<> (Data.Aeson..=) "type" (getServersResponseBody200ServersPlacementGroupType obj))))))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200ServersPlacementGroup
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200ServersPlacementGroup" (\obj -> (((((GHC.Base.pure GetServersResponseBody200ServersPlacementGroup GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "labels")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "servers")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "type"))
-- | Defines the data type for the schema GetServersResponseBody200ServersPlacement_groupLabels
-- 
-- User-defined labels (key-value pairs)
data GetServersResponseBody200ServersPlacementGroupLabels = GetServersResponseBody200ServersPlacementGroupLabels {
  
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersPlacementGroupLabels
    where toJSON obj = Data.Aeson.object []
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "string" ("string" :: GHC.Base.String))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200ServersPlacementGroupLabels
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200ServersPlacementGroupLabels" (\obj -> GHC.Base.pure GetServersResponseBody200ServersPlacementGroupLabels)
-- | Defines the enum schema GetServersResponseBody200ServersPlacement_groupType
-- 
-- Type of the Placement Group
data GetServersResponseBody200ServersPlacementGroupType
    = GetServersResponseBody200ServersPlacementGroupTypeEnumOther Data.Aeson.Types.Internal.Value
    | GetServersResponseBody200ServersPlacementGroupTypeEnumTyped Data.Text.Internal.Text
    | GetServersResponseBody200ServersPlacementGroupTypeEnumStringSpread
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersPlacementGroupType
    where toJSON (GetServersResponseBody200ServersPlacementGroupTypeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersResponseBody200ServersPlacementGroupTypeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersResponseBody200ServersPlacementGroupTypeEnumStringSpread) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "spread"
instance Data.Aeson.FromJSON GetServersResponseBody200ServersPlacementGroupType
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "spread")
                                          then GetServersResponseBody200ServersPlacementGroupTypeEnumStringSpread
                                          else GetServersResponseBody200ServersPlacementGroupTypeEnumOther val)
-- | Defines the data type for the schema GetServersResponseBody200ServersPrivate_net
-- 
-- 
data GetServersResponseBody200ServersPrivateNet = GetServersResponseBody200ServersPrivateNet {
  -- | alias_ips
  getServersResponseBody200ServersPrivateNetAliasIps :: (GHC.Maybe.Maybe ([] Data.Text.Internal.Text))
  -- | ip
  , getServersResponseBody200ServersPrivateNetIp :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | mac_address
  , getServersResponseBody200ServersPrivateNetMacAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | network
  , getServersResponseBody200ServersPrivateNetNetwork :: (GHC.Maybe.Maybe GHC.Integer.Type.Integer)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersPrivateNet
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "alias_ips" (getServersResponseBody200ServersPrivateNetAliasIps obj) : (Data.Aeson..=) "ip" (getServersResponseBody200ServersPrivateNetIp obj) : (Data.Aeson..=) "mac_address" (getServersResponseBody200ServersPrivateNetMacAddress obj) : (Data.Aeson..=) "network" (getServersResponseBody200ServersPrivateNetNetwork obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "alias_ips" (getServersResponseBody200ServersPrivateNetAliasIps obj) GHC.Base.<> ((Data.Aeson..=) "ip" (getServersResponseBody200ServersPrivateNetIp obj) GHC.Base.<> ((Data.Aeson..=) "mac_address" (getServersResponseBody200ServersPrivateNetMacAddress obj) GHC.Base.<> (Data.Aeson..=) "network" (getServersResponseBody200ServersPrivateNetNetwork obj))))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200ServersPrivateNet
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200ServersPrivateNet" (\obj -> (((GHC.Base.pure GetServersResponseBody200ServersPrivateNet GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "alias_ips")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "ip")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "mac_address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "network"))
-- | Defines the data type for the schema GetServersResponseBody200ServersProtection
-- 
-- Protection configuration for the Server
data GetServersResponseBody200ServersProtection = GetServersResponseBody200ServersProtection {
  -- | delete: If true, prevents the Server from being deleted
  getServersResponseBody200ServersProtectionDelete :: GHC.Types.Bool
  -- | rebuild: If true, prevents the Server from being rebuilt
  , getServersResponseBody200ServersProtectionRebuild :: GHC.Types.Bool
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersProtection
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "delete" (getServersResponseBody200ServersProtectionDelete obj) : (Data.Aeson..=) "rebuild" (getServersResponseBody200ServersProtectionRebuild obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "delete" (getServersResponseBody200ServersProtectionDelete obj) GHC.Base.<> (Data.Aeson..=) "rebuild" (getServersResponseBody200ServersProtectionRebuild obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200ServersProtection
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200ServersProtection" (\obj -> (GHC.Base.pure GetServersResponseBody200ServersProtection GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "delete")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "rebuild"))
-- | Defines the data type for the schema GetServersResponseBody200ServersPublic_net
-- 
-- Public network information. The Server\'s IPv4 address can be found in \`public_net->ipv4->ip\`
data GetServersResponseBody200ServersPublicNet = GetServersResponseBody200ServersPublicNet {
  -- | firewalls: Firewalls applied to the public network interface of this Server
  getServersResponseBody200ServersPublicNetFirewalls :: (GHC.Maybe.Maybe ([] GetServersResponseBody200ServersPublicNetFirewalls))
  -- | floating_ips: IDs of Floating IPs assigned to this Server
  , getServersResponseBody200ServersPublicNetFloatingIps :: ([] GHC.Integer.Type.Integer)
  -- | ipv4: IP address (v4) and its reverse DNS entry of this Server
  , getServersResponseBody200ServersPublicNetIpv4 :: GetServersResponseBody200ServersPublicNetIpv4
  -- | ipv6: IPv6 network assigned to this Server and its reverse DNS entry
  , getServersResponseBody200ServersPublicNetIpv6 :: GetServersResponseBody200ServersPublicNetIpv6
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersPublicNet
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "firewalls" (getServersResponseBody200ServersPublicNetFirewalls obj) : (Data.Aeson..=) "floating_ips" (getServersResponseBody200ServersPublicNetFloatingIps obj) : (Data.Aeson..=) "ipv4" (getServersResponseBody200ServersPublicNetIpv4 obj) : (Data.Aeson..=) "ipv6" (getServersResponseBody200ServersPublicNetIpv6 obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "firewalls" (getServersResponseBody200ServersPublicNetFirewalls obj) GHC.Base.<> ((Data.Aeson..=) "floating_ips" (getServersResponseBody200ServersPublicNetFloatingIps obj) GHC.Base.<> ((Data.Aeson..=) "ipv4" (getServersResponseBody200ServersPublicNetIpv4 obj) GHC.Base.<> (Data.Aeson..=) "ipv6" (getServersResponseBody200ServersPublicNetIpv6 obj))))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200ServersPublicNet
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200ServersPublicNet" (\obj -> (((GHC.Base.pure GetServersResponseBody200ServersPublicNet GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "firewalls")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "floating_ips")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ipv4")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ipv6"))
-- | Defines the data type for the schema GetServersResponseBody200ServersPublic_netFirewalls
-- 
-- 
data GetServersResponseBody200ServersPublicNetFirewalls = GetServersResponseBody200ServersPublicNetFirewalls {
  -- | id: ID of the Resource
  getServersResponseBody200ServersPublicNetFirewallsId :: (GHC.Maybe.Maybe GHC.Integer.Type.Integer)
  -- | status: Status of the Firewall on the Server
  , getServersResponseBody200ServersPublicNetFirewallsStatus :: (GHC.Maybe.Maybe GetServersResponseBody200ServersPublicNetFirewallsStatus)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersPublicNetFirewalls
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "id" (getServersResponseBody200ServersPublicNetFirewallsId obj) : (Data.Aeson..=) "status" (getServersResponseBody200ServersPublicNetFirewallsStatus obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "id" (getServersResponseBody200ServersPublicNetFirewallsId obj) GHC.Base.<> (Data.Aeson..=) "status" (getServersResponseBody200ServersPublicNetFirewallsStatus obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200ServersPublicNetFirewalls
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200ServersPublicNetFirewalls" (\obj -> (GHC.Base.pure GetServersResponseBody200ServersPublicNetFirewalls GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "status"))
-- | Defines the enum schema GetServersResponseBody200ServersPublic_netFirewallsStatus
-- 
-- Status of the Firewall on the Server
data GetServersResponseBody200ServersPublicNetFirewallsStatus
    = GetServersResponseBody200ServersPublicNetFirewallsStatusEnumOther Data.Aeson.Types.Internal.Value
    | GetServersResponseBody200ServersPublicNetFirewallsStatusEnumTyped Data.Text.Internal.Text
    | GetServersResponseBody200ServersPublicNetFirewallsStatusEnumStringApplied
    | GetServersResponseBody200ServersPublicNetFirewallsStatusEnumStringPending
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersPublicNetFirewallsStatus
    where toJSON (GetServersResponseBody200ServersPublicNetFirewallsStatusEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersResponseBody200ServersPublicNetFirewallsStatusEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersResponseBody200ServersPublicNetFirewallsStatusEnumStringApplied) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "applied"
          toJSON (GetServersResponseBody200ServersPublicNetFirewallsStatusEnumStringPending) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "pending"
instance Data.Aeson.FromJSON GetServersResponseBody200ServersPublicNetFirewallsStatus
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "applied")
                                          then GetServersResponseBody200ServersPublicNetFirewallsStatusEnumStringApplied
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "pending")
                                                then GetServersResponseBody200ServersPublicNetFirewallsStatusEnumStringPending
                                                else GetServersResponseBody200ServersPublicNetFirewallsStatusEnumOther val)
-- | Defines the data type for the schema GetServersResponseBody200ServersPublic_netIpv4
-- 
-- IP address (v4) and its reverse DNS entry of this Server
data GetServersResponseBody200ServersPublicNetIpv4 = GetServersResponseBody200ServersPublicNetIpv4 {
  -- | blocked: If the IP is blocked by our anti abuse dept
  getServersResponseBody200ServersPublicNetIpv4Blocked :: GHC.Types.Bool
  -- | dns_ptr: Reverse DNS PTR entry for the IPv4 addresses of this Server
  , getServersResponseBody200ServersPublicNetIpv4DnsPtr :: Data.Text.Internal.Text
  -- | ip: IP address (v4) of this Server
  , getServersResponseBody200ServersPublicNetIpv4Ip :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersPublicNetIpv4
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "blocked" (getServersResponseBody200ServersPublicNetIpv4Blocked obj) : (Data.Aeson..=) "dns_ptr" (getServersResponseBody200ServersPublicNetIpv4DnsPtr obj) : (Data.Aeson..=) "ip" (getServersResponseBody200ServersPublicNetIpv4Ip obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "blocked" (getServersResponseBody200ServersPublicNetIpv4Blocked obj) GHC.Base.<> ((Data.Aeson..=) "dns_ptr" (getServersResponseBody200ServersPublicNetIpv4DnsPtr obj) GHC.Base.<> (Data.Aeson..=) "ip" (getServersResponseBody200ServersPublicNetIpv4Ip obj)))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200ServersPublicNetIpv4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200ServersPublicNetIpv4" (\obj -> ((GHC.Base.pure GetServersResponseBody200ServersPublicNetIpv4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "blocked")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "dns_ptr")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ip"))
-- | Defines the data type for the schema GetServersResponseBody200ServersPublic_netIpv6
-- 
-- IPv6 network assigned to this Server and its reverse DNS entry
data GetServersResponseBody200ServersPublicNetIpv6 = GetServersResponseBody200ServersPublicNetIpv6 {
  -- | blocked: If the IP is blocked by our anti abuse dept
  getServersResponseBody200ServersPublicNetIpv6Blocked :: GHC.Types.Bool
  -- | dns_ptr: Reverse DNS PTR entries for the IPv6 addresses of this Server, \`null\` by default
  , getServersResponseBody200ServersPublicNetIpv6DnsPtr :: ([] GetServersResponseBody200ServersPublicNetIpv6DnsPtr)
  -- | ip: IP address (v4) of this Server
  , getServersResponseBody200ServersPublicNetIpv6Ip :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersPublicNetIpv6
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "blocked" (getServersResponseBody200ServersPublicNetIpv6Blocked obj) : (Data.Aeson..=) "dns_ptr" (getServersResponseBody200ServersPublicNetIpv6DnsPtr obj) : (Data.Aeson..=) "ip" (getServersResponseBody200ServersPublicNetIpv6Ip obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "blocked" (getServersResponseBody200ServersPublicNetIpv6Blocked obj) GHC.Base.<> ((Data.Aeson..=) "dns_ptr" (getServersResponseBody200ServersPublicNetIpv6DnsPtr obj) GHC.Base.<> (Data.Aeson..=) "ip" (getServersResponseBody200ServersPublicNetIpv6Ip obj)))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200ServersPublicNetIpv6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200ServersPublicNetIpv6" (\obj -> ((GHC.Base.pure GetServersResponseBody200ServersPublicNetIpv6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "blocked")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "dns_ptr")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ip"))
-- | Defines the data type for the schema GetServersResponseBody200ServersPublic_netIpv6Dns_ptr
-- 
-- 
data GetServersResponseBody200ServersPublicNetIpv6DnsPtr = GetServersResponseBody200ServersPublicNetIpv6DnsPtr {
  -- | dns_ptr: DNS pointer for the specific IP address
  getServersResponseBody200ServersPublicNetIpv6DnsPtrDnsPtr :: Data.Text.Internal.Text
  -- | ip: Single IPv6 address of this Server for which the reverse DNS entry has been set up
  , getServersResponseBody200ServersPublicNetIpv6DnsPtrIp :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersPublicNetIpv6DnsPtr
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "dns_ptr" (getServersResponseBody200ServersPublicNetIpv6DnsPtrDnsPtr obj) : (Data.Aeson..=) "ip" (getServersResponseBody200ServersPublicNetIpv6DnsPtrIp obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "dns_ptr" (getServersResponseBody200ServersPublicNetIpv6DnsPtrDnsPtr obj) GHC.Base.<> (Data.Aeson..=) "ip" (getServersResponseBody200ServersPublicNetIpv6DnsPtrIp obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200ServersPublicNetIpv6DnsPtr
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200ServersPublicNetIpv6DnsPtr" (\obj -> (GHC.Base.pure GetServersResponseBody200ServersPublicNetIpv6DnsPtr GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "dns_ptr")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ip"))
-- | Defines the data type for the schema GetServersResponseBody200ServersServer_type
-- 
-- Type of Server - determines how much ram, disk and cpu a Server has
data GetServersResponseBody200ServersServerType = GetServersResponseBody200ServersServerType {
  -- | cores: Number of cpu cores a Server of this type will have
  getServersResponseBody200ServersServerTypeCores :: GHC.Types.Double
  -- | cpu_type: Type of cpu
  , getServersResponseBody200ServersServerTypeCpuType :: GetServersResponseBody200ServersServerTypeCpuType
  -- | deprecated: True if Server type is deprecated
  , getServersResponseBody200ServersServerTypeDeprecated :: GHC.Types.Bool
  -- | description: Description of the Server type
  , getServersResponseBody200ServersServerTypeDescription :: Data.Text.Internal.Text
  -- | disk: Disk size a Server of this type will have in GB
  , getServersResponseBody200ServersServerTypeDisk :: GHC.Types.Double
  -- | id: ID of the Server type
  , getServersResponseBody200ServersServerTypeId :: GHC.Integer.Type.Integer
  -- | memory: Memory a Server of this type will have in GB
  , getServersResponseBody200ServersServerTypeMemory :: GHC.Types.Double
  -- | name: Unique identifier of the Server type
  , getServersResponseBody200ServersServerTypeName :: Data.Text.Internal.Text
  -- | prices: Prices in different Locations
  , getServersResponseBody200ServersServerTypePrices :: ([] GetServersResponseBody200ServersServerTypePrices)
  -- | storage_type: Type of Server boot drive. Local has higher speed. Network has better availability.
  , getServersResponseBody200ServersServerTypeStorageType :: GetServersResponseBody200ServersServerTypeStorageType
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersServerType
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "cores" (getServersResponseBody200ServersServerTypeCores obj) : (Data.Aeson..=) "cpu_type" (getServersResponseBody200ServersServerTypeCpuType obj) : (Data.Aeson..=) "deprecated" (getServersResponseBody200ServersServerTypeDeprecated obj) : (Data.Aeson..=) "description" (getServersResponseBody200ServersServerTypeDescription obj) : (Data.Aeson..=) "disk" (getServersResponseBody200ServersServerTypeDisk obj) : (Data.Aeson..=) "id" (getServersResponseBody200ServersServerTypeId obj) : (Data.Aeson..=) "memory" (getServersResponseBody200ServersServerTypeMemory obj) : (Data.Aeson..=) "name" (getServersResponseBody200ServersServerTypeName obj) : (Data.Aeson..=) "prices" (getServersResponseBody200ServersServerTypePrices obj) : (Data.Aeson..=) "storage_type" (getServersResponseBody200ServersServerTypeStorageType obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "cores" (getServersResponseBody200ServersServerTypeCores obj) GHC.Base.<> ((Data.Aeson..=) "cpu_type" (getServersResponseBody200ServersServerTypeCpuType obj) GHC.Base.<> ((Data.Aeson..=) "deprecated" (getServersResponseBody200ServersServerTypeDeprecated obj) GHC.Base.<> ((Data.Aeson..=) "description" (getServersResponseBody200ServersServerTypeDescription obj) GHC.Base.<> ((Data.Aeson..=) "disk" (getServersResponseBody200ServersServerTypeDisk obj) GHC.Base.<> ((Data.Aeson..=) "id" (getServersResponseBody200ServersServerTypeId obj) GHC.Base.<> ((Data.Aeson..=) "memory" (getServersResponseBody200ServersServerTypeMemory obj) GHC.Base.<> ((Data.Aeson..=) "name" (getServersResponseBody200ServersServerTypeName obj) GHC.Base.<> ((Data.Aeson..=) "prices" (getServersResponseBody200ServersServerTypePrices obj) GHC.Base.<> (Data.Aeson..=) "storage_type" (getServersResponseBody200ServersServerTypeStorageType obj))))))))))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200ServersServerType
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200ServersServerType" (\obj -> (((((((((GHC.Base.pure GetServersResponseBody200ServersServerType GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "cores")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "cpu_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deprecated")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "disk")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "memory")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "prices")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "storage_type"))
-- | Defines the enum schema GetServersResponseBody200ServersServer_typeCpu_type
-- 
-- Type of cpu
data GetServersResponseBody200ServersServerTypeCpuType
    = GetServersResponseBody200ServersServerTypeCpuTypeEnumOther Data.Aeson.Types.Internal.Value
    | GetServersResponseBody200ServersServerTypeCpuTypeEnumTyped Data.Text.Internal.Text
    | GetServersResponseBody200ServersServerTypeCpuTypeEnumStringDedicated
    | GetServersResponseBody200ServersServerTypeCpuTypeEnumStringShared
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersServerTypeCpuType
    where toJSON (GetServersResponseBody200ServersServerTypeCpuTypeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersResponseBody200ServersServerTypeCpuTypeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersResponseBody200ServersServerTypeCpuTypeEnumStringDedicated) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "dedicated"
          toJSON (GetServersResponseBody200ServersServerTypeCpuTypeEnumStringShared) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "shared"
instance Data.Aeson.FromJSON GetServersResponseBody200ServersServerTypeCpuType
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "dedicated")
                                          then GetServersResponseBody200ServersServerTypeCpuTypeEnumStringDedicated
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "shared")
                                                then GetServersResponseBody200ServersServerTypeCpuTypeEnumStringShared
                                                else GetServersResponseBody200ServersServerTypeCpuTypeEnumOther val)
-- | Defines the data type for the schema GetServersResponseBody200ServersServer_typePrices
-- 
-- 
data GetServersResponseBody200ServersServerTypePrices = GetServersResponseBody200ServersServerTypePrices {
  -- | location: Name of the Location the price is for
  getServersResponseBody200ServersServerTypePricesLocation :: Data.Text.Internal.Text
  -- | price_hourly: Hourly costs for a Server type in this Location
  , getServersResponseBody200ServersServerTypePricesPriceHourly :: GetServersResponseBody200ServersServerTypePricesPriceHourly
  -- | price_monthly: Monthly costs for a Server type in this Location
  , getServersResponseBody200ServersServerTypePricesPriceMonthly :: GetServersResponseBody200ServersServerTypePricesPriceMonthly
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersServerTypePrices
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "location" (getServersResponseBody200ServersServerTypePricesLocation obj) : (Data.Aeson..=) "price_hourly" (getServersResponseBody200ServersServerTypePricesPriceHourly obj) : (Data.Aeson..=) "price_monthly" (getServersResponseBody200ServersServerTypePricesPriceMonthly obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "location" (getServersResponseBody200ServersServerTypePricesLocation obj) GHC.Base.<> ((Data.Aeson..=) "price_hourly" (getServersResponseBody200ServersServerTypePricesPriceHourly obj) GHC.Base.<> (Data.Aeson..=) "price_monthly" (getServersResponseBody200ServersServerTypePricesPriceMonthly obj)))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200ServersServerTypePrices
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200ServersServerTypePrices" (\obj -> ((GHC.Base.pure GetServersResponseBody200ServersServerTypePrices GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "location")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "price_hourly")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "price_monthly"))
-- | Defines the data type for the schema GetServersResponseBody200ServersServer_typePricesPrice_hourly
-- 
-- Hourly costs for a Server type in this Location
data GetServersResponseBody200ServersServerTypePricesPriceHourly = GetServersResponseBody200ServersServerTypePricesPriceHourly {
  -- | gross: Price with VAT added
  getServersResponseBody200ServersServerTypePricesPriceHourlyGross :: Data.Text.Internal.Text
  -- | net: Price without VAT
  , getServersResponseBody200ServersServerTypePricesPriceHourlyNet :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersServerTypePricesPriceHourly
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "gross" (getServersResponseBody200ServersServerTypePricesPriceHourlyGross obj) : (Data.Aeson..=) "net" (getServersResponseBody200ServersServerTypePricesPriceHourlyNet obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "gross" (getServersResponseBody200ServersServerTypePricesPriceHourlyGross obj) GHC.Base.<> (Data.Aeson..=) "net" (getServersResponseBody200ServersServerTypePricesPriceHourlyNet obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200ServersServerTypePricesPriceHourly
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200ServersServerTypePricesPriceHourly" (\obj -> (GHC.Base.pure GetServersResponseBody200ServersServerTypePricesPriceHourly GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "gross")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "net"))
-- | Defines the data type for the schema GetServersResponseBody200ServersServer_typePricesPrice_monthly
-- 
-- Monthly costs for a Server type in this Location
data GetServersResponseBody200ServersServerTypePricesPriceMonthly = GetServersResponseBody200ServersServerTypePricesPriceMonthly {
  -- | gross: Price with VAT added
  getServersResponseBody200ServersServerTypePricesPriceMonthlyGross :: Data.Text.Internal.Text
  -- | net: Price without VAT
  , getServersResponseBody200ServersServerTypePricesPriceMonthlyNet :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersServerTypePricesPriceMonthly
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "gross" (getServersResponseBody200ServersServerTypePricesPriceMonthlyGross obj) : (Data.Aeson..=) "net" (getServersResponseBody200ServersServerTypePricesPriceMonthlyNet obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "gross" (getServersResponseBody200ServersServerTypePricesPriceMonthlyGross obj) GHC.Base.<> (Data.Aeson..=) "net" (getServersResponseBody200ServersServerTypePricesPriceMonthlyNet obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersResponseBody200ServersServerTypePricesPriceMonthly
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersResponseBody200ServersServerTypePricesPriceMonthly" (\obj -> (GHC.Base.pure GetServersResponseBody200ServersServerTypePricesPriceMonthly GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "gross")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "net"))
-- | Defines the enum schema GetServersResponseBody200ServersServer_typeStorage_type
-- 
-- Type of Server boot drive. Local has higher speed. Network has better availability.
data GetServersResponseBody200ServersServerTypeStorageType
    = GetServersResponseBody200ServersServerTypeStorageTypeEnumOther Data.Aeson.Types.Internal.Value
    | GetServersResponseBody200ServersServerTypeStorageTypeEnumTyped Data.Text.Internal.Text
    | GetServersResponseBody200ServersServerTypeStorageTypeEnumStringLocal
    | GetServersResponseBody200ServersServerTypeStorageTypeEnumStringNetwork
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersServerTypeStorageType
    where toJSON (GetServersResponseBody200ServersServerTypeStorageTypeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersResponseBody200ServersServerTypeStorageTypeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersResponseBody200ServersServerTypeStorageTypeEnumStringLocal) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "local"
          toJSON (GetServersResponseBody200ServersServerTypeStorageTypeEnumStringNetwork) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "network"
instance Data.Aeson.FromJSON GetServersResponseBody200ServersServerTypeStorageType
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "local")
                                          then GetServersResponseBody200ServersServerTypeStorageTypeEnumStringLocal
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "network")
                                                then GetServersResponseBody200ServersServerTypeStorageTypeEnumStringNetwork
                                                else GetServersResponseBody200ServersServerTypeStorageTypeEnumOther val)
-- | Defines the enum schema GetServersResponseBody200ServersStatus
-- 
-- Status of the Server
data GetServersResponseBody200ServersStatus
    = GetServersResponseBody200ServersStatusEnumOther Data.Aeson.Types.Internal.Value
    | GetServersResponseBody200ServersStatusEnumTyped Data.Text.Internal.Text
    | GetServersResponseBody200ServersStatusEnumStringDeleting
    | GetServersResponseBody200ServersStatusEnumStringInitializing
    | GetServersResponseBody200ServersStatusEnumStringMigrating
    | GetServersResponseBody200ServersStatusEnumStringOff
    | GetServersResponseBody200ServersStatusEnumStringRebuilding
    | GetServersResponseBody200ServersStatusEnumStringRunning
    | GetServersResponseBody200ServersStatusEnumStringStarting
    | GetServersResponseBody200ServersStatusEnumStringStopping
    | GetServersResponseBody200ServersStatusEnumStringUnknown
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersResponseBody200ServersStatus
    where toJSON (GetServersResponseBody200ServersStatusEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersResponseBody200ServersStatusEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersResponseBody200ServersStatusEnumStringDeleting) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "deleting"
          toJSON (GetServersResponseBody200ServersStatusEnumStringInitializing) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "initializing"
          toJSON (GetServersResponseBody200ServersStatusEnumStringMigrating) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "migrating"
          toJSON (GetServersResponseBody200ServersStatusEnumStringOff) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "off"
          toJSON (GetServersResponseBody200ServersStatusEnumStringRebuilding) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "rebuilding"
          toJSON (GetServersResponseBody200ServersStatusEnumStringRunning) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "running"
          toJSON (GetServersResponseBody200ServersStatusEnumStringStarting) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "starting"
          toJSON (GetServersResponseBody200ServersStatusEnumStringStopping) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "stopping"
          toJSON (GetServersResponseBody200ServersStatusEnumStringUnknown) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "unknown"
instance Data.Aeson.FromJSON GetServersResponseBody200ServersStatus
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "deleting")
                                          then GetServersResponseBody200ServersStatusEnumStringDeleting
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "initializing")
                                                then GetServersResponseBody200ServersStatusEnumStringInitializing
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "migrating")
                                                      then GetServersResponseBody200ServersStatusEnumStringMigrating
                                                      else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "off")
                                                            then GetServersResponseBody200ServersStatusEnumStringOff
                                                            else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "rebuilding")
                                                                  then GetServersResponseBody200ServersStatusEnumStringRebuilding
                                                                  else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "running")
                                                                        then GetServersResponseBody200ServersStatusEnumStringRunning
                                                                        else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "starting")
                                                                              then GetServersResponseBody200ServersStatusEnumStringStarting
                                                                              else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "stopping")
                                                                                    then GetServersResponseBody200ServersStatusEnumStringStopping
                                                                                    else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "unknown")
                                                                                          then GetServersResponseBody200ServersStatusEnumStringUnknown
                                                                                          else GetServersResponseBody200ServersStatusEnumOther val)
