-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE DeriveGeneric #-}

-- | Contains the different functions to run the operation getFloatingIps_Id_
module HCloud.Operations.GetFloatingIpsId_ where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Either
import qualified Data.Functor
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Generics
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified HCloud.Common
import HCloud.Types

-- | > GET /floating_ips/{id}
-- 
-- Returns a specific Floating IP object.
getFloatingIps_Id_ :: forall m s . (HCloud.Common.MonadHTTP m, HCloud.Common.SecurityScheme s) => HCloud.Common.Configuration s  -- ^ The configuration to use in the request
  -> GHC.Integer.Type.Integer                                                                                                       -- ^ id: ID of the Floating IP
  -> m (Data.Either.Either Network.HTTP.Client.Types.HttpException (Network.HTTP.Client.Types.Response GetFloatingIpsIdResponse))   -- ^ Monad containing the result of the operation
getFloatingIps_Id_ config
                   id = GHC.Base.fmap (GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either GetFloatingIpsIdResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetFloatingIpsIdResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                  GetFloatingIpsIdResponseBody200)
                                                                                                                                                                                  | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0)) (HCloud.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack ("/floating_ips/" GHC.Base.++ (Data.ByteString.Char8.unpack (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Data.ByteString.Char8.pack GHC.Base.$ HCloud.Common.stringifyModel id)) GHC.Base.++ ""))) [])
-- | > GET /floating_ips/{id}
-- 
-- The same as 'getFloatingIps_Id_' but returns the raw 'Data.ByteString.Char8.ByteString'
getFloatingIps_Id_Raw :: forall m s . (HCloud.Common.MonadHTTP m,
                                       HCloud.Common.SecurityScheme s) =>
                         HCloud.Common.Configuration s ->
                         GHC.Integer.Type.Integer ->
                         m (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                               (Network.HTTP.Client.Types.Response Data.ByteString.Internal.ByteString))
getFloatingIps_Id_Raw config
                      id = GHC.Base.id (HCloud.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack ("/floating_ips/" GHC.Base.++ (Data.ByteString.Char8.unpack (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Data.ByteString.Char8.pack GHC.Base.$ HCloud.Common.stringifyModel id)) GHC.Base.++ ""))) [])
-- | > GET /floating_ips/{id}
-- 
-- Monadic version of 'getFloatingIps_Id_' (use with 'HCloud.Common.runWithConfiguration')
getFloatingIps_Id_M :: forall m s . (HCloud.Common.MonadHTTP m,
                                     HCloud.Common.SecurityScheme s) =>
                       GHC.Integer.Type.Integer ->
                       Control.Monad.Trans.Reader.ReaderT (HCloud.Common.Configuration s)
                                                          m
                                                          (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                                                              (Network.HTTP.Client.Types.Response GetFloatingIpsIdResponse))
getFloatingIps_Id_M id = GHC.Base.fmap (GHC.Base.fmap (\response_2 -> GHC.Base.fmap (Data.Either.either GetFloatingIpsIdResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetFloatingIpsIdResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                   GetFloatingIpsIdResponseBody200)
                                                                                                                                                                                   | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_2) response_2)) (HCloud.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack ("/floating_ips/" GHC.Base.++ (Data.ByteString.Char8.unpack (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Data.ByteString.Char8.pack GHC.Base.$ HCloud.Common.stringifyModel id)) GHC.Base.++ ""))) [])
-- | > GET /floating_ips/{id}
-- 
-- Monadic version of 'getFloatingIps_Id_Raw' (use with 'HCloud.Common.runWithConfiguration')
getFloatingIps_Id_RawM :: forall m s . (HCloud.Common.MonadHTTP m,
                                        HCloud.Common.SecurityScheme s) =>
                          GHC.Integer.Type.Integer ->
                          Control.Monad.Trans.Reader.ReaderT (HCloud.Common.Configuration s)
                                                             m
                                                             (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                                                                 (Network.HTTP.Client.Types.Response Data.ByteString.Internal.ByteString))
getFloatingIps_Id_RawM id = GHC.Base.id (HCloud.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack ("/floating_ips/" GHC.Base.++ (Data.ByteString.Char8.unpack (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Data.ByteString.Char8.pack GHC.Base.$ HCloud.Common.stringifyModel id)) GHC.Base.++ ""))) [])
-- | Represents a response of the operation 'getFloatingIps_Id_'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'GetFloatingIpsIdResponseError' is used.
data GetFloatingIpsIdResponse =                                  
   GetFloatingIpsIdResponseError GHC.Base.String                 -- ^ Means either no matching case available or a parse error
  | GetFloatingIpsIdResponse200 GetFloatingIpsIdResponseBody200  -- ^ The \`floating_ip\` key in the reply contains a Floating IP object with this structure
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the data type for the schema GetFloatingIpsIdResponseBody200
-- 
-- 
data GetFloatingIpsIdResponseBody200 = GetFloatingIpsIdResponseBody200 {
  -- | floating_ip
  getFloatingIpsIdResponseBody200FloatingIp :: GetFloatingIpsIdResponseBody200FloatingIp
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFloatingIpsIdResponseBody200
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "floating_ip" (getFloatingIpsIdResponseBody200FloatingIp obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "floating_ip" (getFloatingIpsIdResponseBody200FloatingIp obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetFloatingIpsIdResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFloatingIpsIdResponseBody200" (\obj -> GHC.Base.pure GetFloatingIpsIdResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "floating_ip"))
-- | Defines the data type for the schema GetFloatingIpsIdResponseBody200Floating_ip
-- 
-- 
data GetFloatingIpsIdResponseBody200FloatingIp = GetFloatingIpsIdResponseBody200FloatingIp {
  -- | blocked: Whether the IP is blocked
  getFloatingIpsIdResponseBody200FloatingIpBlocked :: GHC.Types.Bool
  -- | created: Point in time when the Resource was created (in ISO-8601 format)
  , getFloatingIpsIdResponseBody200FloatingIpCreated :: Data.Text.Internal.Text
  -- | description: Description of the Resource
  , getFloatingIpsIdResponseBody200FloatingIpDescription :: Data.Text.Internal.Text
  -- | dns_ptr: Array of reverse DNS entries
  , getFloatingIpsIdResponseBody200FloatingIpDnsPtr :: ([] GetFloatingIpsIdResponseBody200FloatingIpDnsPtr)
  -- | home_location: Location the Floating IP was created in. Routing is optimized for this Location.
  , getFloatingIpsIdResponseBody200FloatingIpHomeLocation :: GetFloatingIpsIdResponseBody200FloatingIpHomeLocation
  -- | id: ID of the Resource
  , getFloatingIpsIdResponseBody200FloatingIpId :: GHC.Integer.Type.Integer
  -- | ip: IP address
  , getFloatingIpsIdResponseBody200FloatingIpIp :: Data.Text.Internal.Text
  -- | labels: User-defined labels (key-value pairs)
  , getFloatingIpsIdResponseBody200FloatingIpLabels :: GetFloatingIpsIdResponseBody200FloatingIpLabels
  -- | name: Name of the Resource. Must be unique per Project.
  , getFloatingIpsIdResponseBody200FloatingIpName :: Data.Text.Internal.Text
  -- | protection: Protection configuration for the Resource
  , getFloatingIpsIdResponseBody200FloatingIpProtection :: GetFloatingIpsIdResponseBody200FloatingIpProtection
  -- | server: ID of the Server the Floating IP is assigned to, null if it is not assigned at all
  , getFloatingIpsIdResponseBody200FloatingIpServer :: GHC.Integer.Type.Integer
  -- | type: Type of the Floating IP
  , getFloatingIpsIdResponseBody200FloatingIpType :: GetFloatingIpsIdResponseBody200FloatingIpType
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFloatingIpsIdResponseBody200FloatingIp
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "blocked" (getFloatingIpsIdResponseBody200FloatingIpBlocked obj) : (Data.Aeson..=) "created" (getFloatingIpsIdResponseBody200FloatingIpCreated obj) : (Data.Aeson..=) "description" (getFloatingIpsIdResponseBody200FloatingIpDescription obj) : (Data.Aeson..=) "dns_ptr" (getFloatingIpsIdResponseBody200FloatingIpDnsPtr obj) : (Data.Aeson..=) "home_location" (getFloatingIpsIdResponseBody200FloatingIpHomeLocation obj) : (Data.Aeson..=) "id" (getFloatingIpsIdResponseBody200FloatingIpId obj) : (Data.Aeson..=) "ip" (getFloatingIpsIdResponseBody200FloatingIpIp obj) : (Data.Aeson..=) "labels" (getFloatingIpsIdResponseBody200FloatingIpLabels obj) : (Data.Aeson..=) "name" (getFloatingIpsIdResponseBody200FloatingIpName obj) : (Data.Aeson..=) "protection" (getFloatingIpsIdResponseBody200FloatingIpProtection obj) : (Data.Aeson..=) "server" (getFloatingIpsIdResponseBody200FloatingIpServer obj) : (Data.Aeson..=) "type" (getFloatingIpsIdResponseBody200FloatingIpType obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "blocked" (getFloatingIpsIdResponseBody200FloatingIpBlocked obj) GHC.Base.<> ((Data.Aeson..=) "created" (getFloatingIpsIdResponseBody200FloatingIpCreated obj) GHC.Base.<> ((Data.Aeson..=) "description" (getFloatingIpsIdResponseBody200FloatingIpDescription obj) GHC.Base.<> ((Data.Aeson..=) "dns_ptr" (getFloatingIpsIdResponseBody200FloatingIpDnsPtr obj) GHC.Base.<> ((Data.Aeson..=) "home_location" (getFloatingIpsIdResponseBody200FloatingIpHomeLocation obj) GHC.Base.<> ((Data.Aeson..=) "id" (getFloatingIpsIdResponseBody200FloatingIpId obj) GHC.Base.<> ((Data.Aeson..=) "ip" (getFloatingIpsIdResponseBody200FloatingIpIp obj) GHC.Base.<> ((Data.Aeson..=) "labels" (getFloatingIpsIdResponseBody200FloatingIpLabels obj) GHC.Base.<> ((Data.Aeson..=) "name" (getFloatingIpsIdResponseBody200FloatingIpName obj) GHC.Base.<> ((Data.Aeson..=) "protection" (getFloatingIpsIdResponseBody200FloatingIpProtection obj) GHC.Base.<> ((Data.Aeson..=) "server" (getFloatingIpsIdResponseBody200FloatingIpServer obj) GHC.Base.<> (Data.Aeson..=) "type" (getFloatingIpsIdResponseBody200FloatingIpType obj))))))))))))
instance Data.Aeson.Types.FromJSON.FromJSON GetFloatingIpsIdResponseBody200FloatingIp
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFloatingIpsIdResponseBody200FloatingIp" (\obj -> (((((((((((GHC.Base.pure GetFloatingIpsIdResponseBody200FloatingIp GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "blocked")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "dns_ptr")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "home_location")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ip")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "labels")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "protection")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "server")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "type"))
-- | Defines the data type for the schema GetFloatingIpsIdResponseBody200Floating_ipDns_ptr
-- 
-- 
data GetFloatingIpsIdResponseBody200FloatingIpDnsPtr = GetFloatingIpsIdResponseBody200FloatingIpDnsPtr {
  -- | dns_ptr: DNS pointer for the specific IP address
  getFloatingIpsIdResponseBody200FloatingIpDnsPtrDnsPtr :: Data.Text.Internal.Text
  -- | ip: Single IPv4 or IPv6 address
  , getFloatingIpsIdResponseBody200FloatingIpDnsPtrIp :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFloatingIpsIdResponseBody200FloatingIpDnsPtr
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "dns_ptr" (getFloatingIpsIdResponseBody200FloatingIpDnsPtrDnsPtr obj) : (Data.Aeson..=) "ip" (getFloatingIpsIdResponseBody200FloatingIpDnsPtrIp obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "dns_ptr" (getFloatingIpsIdResponseBody200FloatingIpDnsPtrDnsPtr obj) GHC.Base.<> (Data.Aeson..=) "ip" (getFloatingIpsIdResponseBody200FloatingIpDnsPtrIp obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetFloatingIpsIdResponseBody200FloatingIpDnsPtr
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFloatingIpsIdResponseBody200FloatingIpDnsPtr" (\obj -> (GHC.Base.pure GetFloatingIpsIdResponseBody200FloatingIpDnsPtr GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "dns_ptr")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ip"))
-- | Defines the data type for the schema GetFloatingIpsIdResponseBody200Floating_ipHome_location
-- 
-- Location the Floating IP was created in. Routing is optimized for this Location.
data GetFloatingIpsIdResponseBody200FloatingIpHomeLocation = GetFloatingIpsIdResponseBody200FloatingIpHomeLocation {
  -- | city: City the Location is closest to
  getFloatingIpsIdResponseBody200FloatingIpHomeLocationCity :: Data.Text.Internal.Text
  -- | country: ISO 3166-1 alpha-2 code of the country the Location resides in
  , getFloatingIpsIdResponseBody200FloatingIpHomeLocationCountry :: Data.Text.Internal.Text
  -- | description: Description of the Location
  , getFloatingIpsIdResponseBody200FloatingIpHomeLocationDescription :: Data.Text.Internal.Text
  -- | id: ID of the Location
  , getFloatingIpsIdResponseBody200FloatingIpHomeLocationId :: GHC.Types.Double
  -- | latitude: Latitude of the city closest to the Location
  , getFloatingIpsIdResponseBody200FloatingIpHomeLocationLatitude :: GHC.Types.Double
  -- | longitude: Longitude of the city closest to the Location
  , getFloatingIpsIdResponseBody200FloatingIpHomeLocationLongitude :: GHC.Types.Double
  -- | name: Unique identifier of the Location
  , getFloatingIpsIdResponseBody200FloatingIpHomeLocationName :: Data.Text.Internal.Text
  -- | network_zone: Name of network zone this Location resides in
  , getFloatingIpsIdResponseBody200FloatingIpHomeLocationNetworkZone :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFloatingIpsIdResponseBody200FloatingIpHomeLocation
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "city" (getFloatingIpsIdResponseBody200FloatingIpHomeLocationCity obj) : (Data.Aeson..=) "country" (getFloatingIpsIdResponseBody200FloatingIpHomeLocationCountry obj) : (Data.Aeson..=) "description" (getFloatingIpsIdResponseBody200FloatingIpHomeLocationDescription obj) : (Data.Aeson..=) "id" (getFloatingIpsIdResponseBody200FloatingIpHomeLocationId obj) : (Data.Aeson..=) "latitude" (getFloatingIpsIdResponseBody200FloatingIpHomeLocationLatitude obj) : (Data.Aeson..=) "longitude" (getFloatingIpsIdResponseBody200FloatingIpHomeLocationLongitude obj) : (Data.Aeson..=) "name" (getFloatingIpsIdResponseBody200FloatingIpHomeLocationName obj) : (Data.Aeson..=) "network_zone" (getFloatingIpsIdResponseBody200FloatingIpHomeLocationNetworkZone obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "city" (getFloatingIpsIdResponseBody200FloatingIpHomeLocationCity obj) GHC.Base.<> ((Data.Aeson..=) "country" (getFloatingIpsIdResponseBody200FloatingIpHomeLocationCountry obj) GHC.Base.<> ((Data.Aeson..=) "description" (getFloatingIpsIdResponseBody200FloatingIpHomeLocationDescription obj) GHC.Base.<> ((Data.Aeson..=) "id" (getFloatingIpsIdResponseBody200FloatingIpHomeLocationId obj) GHC.Base.<> ((Data.Aeson..=) "latitude" (getFloatingIpsIdResponseBody200FloatingIpHomeLocationLatitude obj) GHC.Base.<> ((Data.Aeson..=) "longitude" (getFloatingIpsIdResponseBody200FloatingIpHomeLocationLongitude obj) GHC.Base.<> ((Data.Aeson..=) "name" (getFloatingIpsIdResponseBody200FloatingIpHomeLocationName obj) GHC.Base.<> (Data.Aeson..=) "network_zone" (getFloatingIpsIdResponseBody200FloatingIpHomeLocationNetworkZone obj))))))))
instance Data.Aeson.Types.FromJSON.FromJSON GetFloatingIpsIdResponseBody200FloatingIpHomeLocation
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFloatingIpsIdResponseBody200FloatingIpHomeLocation" (\obj -> (((((((GHC.Base.pure GetFloatingIpsIdResponseBody200FloatingIpHomeLocation GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "city")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "country")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "latitude")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "longitude")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "network_zone"))
-- | Defines the data type for the schema GetFloatingIpsIdResponseBody200Floating_ipLabels
-- 
-- User-defined labels (key-value pairs)
data GetFloatingIpsIdResponseBody200FloatingIpLabels = GetFloatingIpsIdResponseBody200FloatingIpLabels {
  
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFloatingIpsIdResponseBody200FloatingIpLabels
    where toJSON obj = Data.Aeson.object []
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "string" ("string" :: GHC.Base.String))
instance Data.Aeson.Types.FromJSON.FromJSON GetFloatingIpsIdResponseBody200FloatingIpLabels
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFloatingIpsIdResponseBody200FloatingIpLabels" (\obj -> GHC.Base.pure GetFloatingIpsIdResponseBody200FloatingIpLabels)
-- | Defines the data type for the schema GetFloatingIpsIdResponseBody200Floating_ipProtection
-- 
-- Protection configuration for the Resource
data GetFloatingIpsIdResponseBody200FloatingIpProtection = GetFloatingIpsIdResponseBody200FloatingIpProtection {
  -- | delete: If true, prevents the Resource from being deleted
  getFloatingIpsIdResponseBody200FloatingIpProtectionDelete :: GHC.Types.Bool
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFloatingIpsIdResponseBody200FloatingIpProtection
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "delete" (getFloatingIpsIdResponseBody200FloatingIpProtectionDelete obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "delete" (getFloatingIpsIdResponseBody200FloatingIpProtectionDelete obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetFloatingIpsIdResponseBody200FloatingIpProtection
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFloatingIpsIdResponseBody200FloatingIpProtection" (\obj -> GHC.Base.pure GetFloatingIpsIdResponseBody200FloatingIpProtection GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "delete"))
-- | Defines the enum schema GetFloatingIpsIdResponseBody200Floating_ipType
-- 
-- Type of the Floating IP
data GetFloatingIpsIdResponseBody200FloatingIpType
    = GetFloatingIpsIdResponseBody200FloatingIpTypeEnumOther Data.Aeson.Types.Internal.Value
    | GetFloatingIpsIdResponseBody200FloatingIpTypeEnumTyped Data.Text.Internal.Text
    | GetFloatingIpsIdResponseBody200FloatingIpTypeEnumStringIpv4
    | GetFloatingIpsIdResponseBody200FloatingIpTypeEnumStringIpv6
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFloatingIpsIdResponseBody200FloatingIpType
    where toJSON (GetFloatingIpsIdResponseBody200FloatingIpTypeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetFloatingIpsIdResponseBody200FloatingIpTypeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetFloatingIpsIdResponseBody200FloatingIpTypeEnumStringIpv4) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "ipv4"
          toJSON (GetFloatingIpsIdResponseBody200FloatingIpTypeEnumStringIpv6) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "ipv6"
instance Data.Aeson.FromJSON GetFloatingIpsIdResponseBody200FloatingIpType
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "ipv4")
                                          then GetFloatingIpsIdResponseBody200FloatingIpTypeEnumStringIpv4
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "ipv6")
                                                then GetFloatingIpsIdResponseBody200FloatingIpTypeEnumStringIpv6
                                                else GetFloatingIpsIdResponseBody200FloatingIpTypeEnumOther val)
