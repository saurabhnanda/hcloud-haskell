-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE DeriveGeneric #-}

-- | Contains the different functions to run the operation getFirewalls
module HCloud.Operations.GetFirewalls where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Either
import qualified Data.Functor
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Generics
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified HCloud.Common
import HCloud.Types

-- | > GET /firewalls
-- 
-- Returns all Firewall objects.
getFirewalls :: forall m s . (HCloud.Common.MonadHTTP m, HCloud.Common.SecurityScheme s) => HCloud.Common.Configuration s  -- ^ The configuration to use in the request
  -> GHC.Maybe.Maybe Data.Text.Internal.Text                                                                                  -- ^ sort: Can be used multiple times.
  -> GHC.Maybe.Maybe Data.Text.Internal.Text                                                                                  -- ^ name: Can be used to filter resources by their name. The response will only contain the resources matching the specified name
  -> GHC.Maybe.Maybe Data.Text.Internal.Text                                                                                  -- ^ label_selector: Can be used to filter resources by labels. The response will only contain resources matching the label selector.
  -> m (Data.Either.Either Network.HTTP.Client.Types.HttpException (Network.HTTP.Client.Types.Response GetFirewallsResponse)) -- ^ Monad containing the result of the operation
getFirewalls config
             sort
             name
             labelSelector = GHC.Base.fmap (GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either GetFirewallsResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetFirewallsResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                               GetFirewallsResponseBody200)
                                                                                                                                                                                   | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0)) (HCloud.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack "/firewalls") ((Data.Text.pack "sort",
                                                                                                                                                                                                                                                                                                                                                                                                                         HCloud.Common.stringifyModel Data.Functor.<$> sort) : ((Data.Text.pack "name",
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  HCloud.Common.stringifyModel Data.Functor.<$> name) : ((Data.Text.pack "label_selector",
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           HCloud.Common.stringifyModel Data.Functor.<$> labelSelector) : []))))
-- | > GET /firewalls
-- 
-- The same as 'getFirewalls' but returns the raw 'Data.ByteString.Char8.ByteString'
getFirewallsRaw :: forall m s . (HCloud.Common.MonadHTTP m,
                                 HCloud.Common.SecurityScheme s) =>
                   HCloud.Common.Configuration s ->
                   GHC.Maybe.Maybe Data.Text.Internal.Text ->
                   GHC.Maybe.Maybe Data.Text.Internal.Text ->
                   GHC.Maybe.Maybe Data.Text.Internal.Text ->
                   m (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                         (Network.HTTP.Client.Types.Response Data.ByteString.Internal.ByteString))
getFirewallsRaw config
                sort
                name
                labelSelector = GHC.Base.id (HCloud.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack "/firewalls") ((Data.Text.pack "sort",
                                                                                                                                                                               HCloud.Common.stringifyModel Data.Functor.<$> sort) : ((Data.Text.pack "name",
                                                                                                                                                                                                                                        HCloud.Common.stringifyModel Data.Functor.<$> name) : ((Data.Text.pack "label_selector",
                                                                                                                                                                                                                                                                                                 HCloud.Common.stringifyModel Data.Functor.<$> labelSelector) : []))))
-- | > GET /firewalls
-- 
-- Monadic version of 'getFirewalls' (use with 'HCloud.Common.runWithConfiguration')
getFirewallsM :: forall m s . (HCloud.Common.MonadHTTP m,
                               HCloud.Common.SecurityScheme s) =>
                 GHC.Maybe.Maybe Data.Text.Internal.Text ->
                 GHC.Maybe.Maybe Data.Text.Internal.Text ->
                 GHC.Maybe.Maybe Data.Text.Internal.Text ->
                 Control.Monad.Trans.Reader.ReaderT (HCloud.Common.Configuration s)
                                                    m
                                                    (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                                                        (Network.HTTP.Client.Types.Response GetFirewallsResponse))
getFirewallsM sort
              name
              labelSelector = GHC.Base.fmap (GHC.Base.fmap (\response_2 -> GHC.Base.fmap (Data.Either.either GetFirewallsResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetFirewallsResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                GetFirewallsResponseBody200)
                                                                                                                                                                                    | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_2) response_2)) (HCloud.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack "/firewalls") ((Data.Text.pack "sort",
                                                                                                                                                                                                                                                                                                                                                                                                                    HCloud.Common.stringifyModel Data.Functor.<$> sort) : ((Data.Text.pack "name",
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             HCloud.Common.stringifyModel Data.Functor.<$> name) : ((Data.Text.pack "label_selector",
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      HCloud.Common.stringifyModel Data.Functor.<$> labelSelector) : []))))
-- | > GET /firewalls
-- 
-- Monadic version of 'getFirewallsRaw' (use with 'HCloud.Common.runWithConfiguration')
getFirewallsRawM :: forall m s . (HCloud.Common.MonadHTTP m,
                                  HCloud.Common.SecurityScheme s) =>
                    GHC.Maybe.Maybe Data.Text.Internal.Text ->
                    GHC.Maybe.Maybe Data.Text.Internal.Text ->
                    GHC.Maybe.Maybe Data.Text.Internal.Text ->
                    Control.Monad.Trans.Reader.ReaderT (HCloud.Common.Configuration s)
                                                       m
                                                       (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                                                           (Network.HTTP.Client.Types.Response Data.ByteString.Internal.ByteString))
getFirewallsRawM sort
                 name
                 labelSelector = GHC.Base.id (HCloud.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack "/firewalls") ((Data.Text.pack "sort",
                                                                                                                                                                          HCloud.Common.stringifyModel Data.Functor.<$> sort) : ((Data.Text.pack "name",
                                                                                                                                                                                                                                   HCloud.Common.stringifyModel Data.Functor.<$> name) : ((Data.Text.pack "label_selector",
                                                                                                                                                                                                                                                                                            HCloud.Common.stringifyModel Data.Functor.<$> labelSelector) : []))))
-- | Represents a response of the operation 'getFirewalls'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'GetFirewallsResponseError' is used.
data GetFirewallsResponse =                              
   GetFirewallsResponseError GHC.Base.String             -- ^ Means either no matching case available or a parse error
  | GetFirewallsResponse200 GetFirewallsResponseBody200  -- ^ The \`firewalls\` key contains an array of Firewall objects
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the data type for the schema GetFirewallsResponseBody200
-- 
-- 
data GetFirewallsResponseBody200 = GetFirewallsResponseBody200 {
  -- | firewalls
  getFirewallsResponseBody200Firewalls :: ([] GetFirewallsResponseBody200Firewalls)
  -- | meta
  , getFirewallsResponseBody200Meta :: (GHC.Maybe.Maybe GetFirewallsResponseBody200Meta)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFirewallsResponseBody200
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "firewalls" (getFirewallsResponseBody200Firewalls obj) : (Data.Aeson..=) "meta" (getFirewallsResponseBody200Meta obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "firewalls" (getFirewallsResponseBody200Firewalls obj) GHC.Base.<> (Data.Aeson..=) "meta" (getFirewallsResponseBody200Meta obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetFirewallsResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFirewallsResponseBody200" (\obj -> (GHC.Base.pure GetFirewallsResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "firewalls")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "meta"))
-- | Defines the data type for the schema GetFirewallsResponseBody200Firewalls
-- 
-- 
data GetFirewallsResponseBody200Firewalls = GetFirewallsResponseBody200Firewalls {
  -- | applied_to
  getFirewallsResponseBody200FirewallsAppliedTo :: ([] GetFirewallsResponseBody200FirewallsAppliedTo)
  -- | created: Point in time when the Resource was created (in ISO-8601 format)
  , getFirewallsResponseBody200FirewallsCreated :: Data.Text.Internal.Text
  -- | id: ID of the Resource
  , getFirewallsResponseBody200FirewallsId :: GHC.Integer.Type.Integer
  -- | labels: User-defined labels (key-value pairs)
  , getFirewallsResponseBody200FirewallsLabels :: (GHC.Maybe.Maybe GetFirewallsResponseBody200FirewallsLabels)
  -- | name: Name of the Resource. Must be unique per Project.
  , getFirewallsResponseBody200FirewallsName :: Data.Text.Internal.Text
  -- | rules
  , getFirewallsResponseBody200FirewallsRules :: ([] GetFirewallsResponseBody200FirewallsRules)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFirewallsResponseBody200Firewalls
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "applied_to" (getFirewallsResponseBody200FirewallsAppliedTo obj) : (Data.Aeson..=) "created" (getFirewallsResponseBody200FirewallsCreated obj) : (Data.Aeson..=) "id" (getFirewallsResponseBody200FirewallsId obj) : (Data.Aeson..=) "labels" (getFirewallsResponseBody200FirewallsLabels obj) : (Data.Aeson..=) "name" (getFirewallsResponseBody200FirewallsName obj) : (Data.Aeson..=) "rules" (getFirewallsResponseBody200FirewallsRules obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "applied_to" (getFirewallsResponseBody200FirewallsAppliedTo obj) GHC.Base.<> ((Data.Aeson..=) "created" (getFirewallsResponseBody200FirewallsCreated obj) GHC.Base.<> ((Data.Aeson..=) "id" (getFirewallsResponseBody200FirewallsId obj) GHC.Base.<> ((Data.Aeson..=) "labels" (getFirewallsResponseBody200FirewallsLabels obj) GHC.Base.<> ((Data.Aeson..=) "name" (getFirewallsResponseBody200FirewallsName obj) GHC.Base.<> (Data.Aeson..=) "rules" (getFirewallsResponseBody200FirewallsRules obj))))))
instance Data.Aeson.Types.FromJSON.FromJSON GetFirewallsResponseBody200Firewalls
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFirewallsResponseBody200Firewalls" (\obj -> (((((GHC.Base.pure GetFirewallsResponseBody200Firewalls GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "applied_to")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "labels")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "rules"))
-- | Defines the data type for the schema GetFirewallsResponseBody200FirewallsApplied_to
-- 
-- 
data GetFirewallsResponseBody200FirewallsAppliedTo = GetFirewallsResponseBody200FirewallsAppliedTo {
  -- | applied_to_resources
  getFirewallsResponseBody200FirewallsAppliedToAppliedToResources :: (GHC.Maybe.Maybe ([] GetFirewallsResponseBody200FirewallsAppliedToAppliedToResources))
  -- | label_selector
  , getFirewallsResponseBody200FirewallsAppliedToLabelSelector :: (GHC.Maybe.Maybe GetFirewallsResponseBody200FirewallsAppliedToLabelSelector)
  -- | server
  , getFirewallsResponseBody200FirewallsAppliedToServer :: (GHC.Maybe.Maybe GetFirewallsResponseBody200FirewallsAppliedToServer)
  -- | type: Type of resource referenced
  , getFirewallsResponseBody200FirewallsAppliedToType :: GetFirewallsResponseBody200FirewallsAppliedToType
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFirewallsResponseBody200FirewallsAppliedTo
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "applied_to_resources" (getFirewallsResponseBody200FirewallsAppliedToAppliedToResources obj) : (Data.Aeson..=) "label_selector" (getFirewallsResponseBody200FirewallsAppliedToLabelSelector obj) : (Data.Aeson..=) "server" (getFirewallsResponseBody200FirewallsAppliedToServer obj) : (Data.Aeson..=) "type" (getFirewallsResponseBody200FirewallsAppliedToType obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "applied_to_resources" (getFirewallsResponseBody200FirewallsAppliedToAppliedToResources obj) GHC.Base.<> ((Data.Aeson..=) "label_selector" (getFirewallsResponseBody200FirewallsAppliedToLabelSelector obj) GHC.Base.<> ((Data.Aeson..=) "server" (getFirewallsResponseBody200FirewallsAppliedToServer obj) GHC.Base.<> (Data.Aeson..=) "type" (getFirewallsResponseBody200FirewallsAppliedToType obj))))
instance Data.Aeson.Types.FromJSON.FromJSON GetFirewallsResponseBody200FirewallsAppliedTo
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFirewallsResponseBody200FirewallsAppliedTo" (\obj -> (((GHC.Base.pure GetFirewallsResponseBody200FirewallsAppliedTo GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "applied_to_resources")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "label_selector")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "server")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "type"))
-- | Defines the data type for the schema GetFirewallsResponseBody200FirewallsApplied_toApplied_to_resources
-- 
-- 
data GetFirewallsResponseBody200FirewallsAppliedToAppliedToResources = GetFirewallsResponseBody200FirewallsAppliedToAppliedToResources {
  -- | server
  getFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesServer :: (GHC.Maybe.Maybe GetFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesServer)
  -- | type: Type of resource referenced
  , getFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesType :: (GHC.Maybe.Maybe GetFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesType)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFirewallsResponseBody200FirewallsAppliedToAppliedToResources
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "server" (getFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesServer obj) : (Data.Aeson..=) "type" (getFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesType obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "server" (getFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesServer obj) GHC.Base.<> (Data.Aeson..=) "type" (getFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesType obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetFirewallsResponseBody200FirewallsAppliedToAppliedToResources
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFirewallsResponseBody200FirewallsAppliedToAppliedToResources" (\obj -> (GHC.Base.pure GetFirewallsResponseBody200FirewallsAppliedToAppliedToResources GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "server")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "type"))
-- | Defines the data type for the schema GetFirewallsResponseBody200FirewallsApplied_toApplied_to_resourcesServer
-- 
-- 
data GetFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesServer = GetFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesServer {
  -- | id: ID of the Resource
  getFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesServerId :: GHC.Integer.Type.Integer
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesServer
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "id" (getFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesServerId obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "id" (getFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesServerId obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesServer
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesServer" (\obj -> GHC.Base.pure GetFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesServer GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id"))
-- | Defines the enum schema GetFirewallsResponseBody200FirewallsApplied_toApplied_to_resourcesType
-- 
-- Type of resource referenced
data GetFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesType
    = GetFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesTypeEnumOther Data.Aeson.Types.Internal.Value
    | GetFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesTypeEnumTyped Data.Text.Internal.Text
    | GetFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesTypeEnumStringServer
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesType
    where toJSON (GetFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesTypeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesTypeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesTypeEnumStringServer) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "server"
instance Data.Aeson.FromJSON GetFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesType
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "server")
                                          then GetFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesTypeEnumStringServer
                                          else GetFirewallsResponseBody200FirewallsAppliedToAppliedToResourcesTypeEnumOther val)
-- | Defines the data type for the schema GetFirewallsResponseBody200FirewallsApplied_toLabel_selector
-- 
-- 
data GetFirewallsResponseBody200FirewallsAppliedToLabelSelector = GetFirewallsResponseBody200FirewallsAppliedToLabelSelector {
  -- | selector: Label selector
  getFirewallsResponseBody200FirewallsAppliedToLabelSelectorSelector :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFirewallsResponseBody200FirewallsAppliedToLabelSelector
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "selector" (getFirewallsResponseBody200FirewallsAppliedToLabelSelectorSelector obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "selector" (getFirewallsResponseBody200FirewallsAppliedToLabelSelectorSelector obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetFirewallsResponseBody200FirewallsAppliedToLabelSelector
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFirewallsResponseBody200FirewallsAppliedToLabelSelector" (\obj -> GHC.Base.pure GetFirewallsResponseBody200FirewallsAppliedToLabelSelector GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "selector"))
-- | Defines the data type for the schema GetFirewallsResponseBody200FirewallsApplied_toServer
-- 
-- 
data GetFirewallsResponseBody200FirewallsAppliedToServer = GetFirewallsResponseBody200FirewallsAppliedToServer {
  -- | id: ID of the Resource
  getFirewallsResponseBody200FirewallsAppliedToServerId :: GHC.Integer.Type.Integer
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFirewallsResponseBody200FirewallsAppliedToServer
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "id" (getFirewallsResponseBody200FirewallsAppliedToServerId obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "id" (getFirewallsResponseBody200FirewallsAppliedToServerId obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetFirewallsResponseBody200FirewallsAppliedToServer
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFirewallsResponseBody200FirewallsAppliedToServer" (\obj -> GHC.Base.pure GetFirewallsResponseBody200FirewallsAppliedToServer GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id"))
-- | Defines the enum schema GetFirewallsResponseBody200FirewallsApplied_toType
-- 
-- Type of resource referenced
data GetFirewallsResponseBody200FirewallsAppliedToType
    = GetFirewallsResponseBody200FirewallsAppliedToTypeEnumOther Data.Aeson.Types.Internal.Value
    | GetFirewallsResponseBody200FirewallsAppliedToTypeEnumTyped Data.Text.Internal.Text
    | GetFirewallsResponseBody200FirewallsAppliedToTypeEnumStringLabelSelector
    | GetFirewallsResponseBody200FirewallsAppliedToTypeEnumStringServer
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFirewallsResponseBody200FirewallsAppliedToType
    where toJSON (GetFirewallsResponseBody200FirewallsAppliedToTypeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetFirewallsResponseBody200FirewallsAppliedToTypeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetFirewallsResponseBody200FirewallsAppliedToTypeEnumStringLabelSelector) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "label_selector"
          toJSON (GetFirewallsResponseBody200FirewallsAppliedToTypeEnumStringServer) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "server"
instance Data.Aeson.FromJSON GetFirewallsResponseBody200FirewallsAppliedToType
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "label_selector")
                                          then GetFirewallsResponseBody200FirewallsAppliedToTypeEnumStringLabelSelector
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "server")
                                                then GetFirewallsResponseBody200FirewallsAppliedToTypeEnumStringServer
                                                else GetFirewallsResponseBody200FirewallsAppliedToTypeEnumOther val)
-- | Defines the data type for the schema GetFirewallsResponseBody200FirewallsLabels
-- 
-- User-defined labels (key-value pairs)
data GetFirewallsResponseBody200FirewallsLabels = GetFirewallsResponseBody200FirewallsLabels {
  
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFirewallsResponseBody200FirewallsLabels
    where toJSON obj = Data.Aeson.object []
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "string" ("string" :: GHC.Base.String))
instance Data.Aeson.Types.FromJSON.FromJSON GetFirewallsResponseBody200FirewallsLabels
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFirewallsResponseBody200FirewallsLabels" (\obj -> GHC.Base.pure GetFirewallsResponseBody200FirewallsLabels)
-- | Defines the data type for the schema GetFirewallsResponseBody200FirewallsRules
-- 
-- 
data GetFirewallsResponseBody200FirewallsRules = GetFirewallsResponseBody200FirewallsRules {
  -- | description: Description of the Rule
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  getFirewallsResponseBody200FirewallsRulesDescription :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | destination_ips: List of permitted IPv4\/IPv6 addresses in CIDR notation. Use \`0.0.0.0\/0\` to allow all IPv4 addresses and \`::\/0\` to allow all IPv6 addresses. You can specify 100 CIDRs at most.
  , getFirewallsResponseBody200FirewallsRulesDestinationIps :: (GHC.Maybe.Maybe ([] Data.Text.Internal.Text))
  -- | direction: Select traffic direction on which rule should be applied. Use \`source_ips\` for direction \`in\` and \`destination_ips\` for direction \`out\`.
  , getFirewallsResponseBody200FirewallsRulesDirection :: GetFirewallsResponseBody200FirewallsRulesDirection
  -- | port: Port or port range to which traffic will be allowed, only applicable for protocols TCP and UDP. A port range can be specified by separating two ports with a dash, e.g \`1024-5000\`.
  , getFirewallsResponseBody200FirewallsRulesPort :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | protocol: Type of traffic to allow
  , getFirewallsResponseBody200FirewallsRulesProtocol :: GetFirewallsResponseBody200FirewallsRulesProtocol
  -- | source_ips: List of permitted IPv4\/IPv6 addresses in CIDR notation. Use \`0.0.0.0\/0\` to allow all IPv4 addresses and \`::\/0\` to allow all IPv6 addresses. You can specify 100 CIDRs at most.
  , getFirewallsResponseBody200FirewallsRulesSourceIps :: (GHC.Maybe.Maybe ([] Data.Text.Internal.Text))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFirewallsResponseBody200FirewallsRules
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "description" (getFirewallsResponseBody200FirewallsRulesDescription obj) : (Data.Aeson..=) "destination_ips" (getFirewallsResponseBody200FirewallsRulesDestinationIps obj) : (Data.Aeson..=) "direction" (getFirewallsResponseBody200FirewallsRulesDirection obj) : (Data.Aeson..=) "port" (getFirewallsResponseBody200FirewallsRulesPort obj) : (Data.Aeson..=) "protocol" (getFirewallsResponseBody200FirewallsRulesProtocol obj) : (Data.Aeson..=) "source_ips" (getFirewallsResponseBody200FirewallsRulesSourceIps obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "description" (getFirewallsResponseBody200FirewallsRulesDescription obj) GHC.Base.<> ((Data.Aeson..=) "destination_ips" (getFirewallsResponseBody200FirewallsRulesDestinationIps obj) GHC.Base.<> ((Data.Aeson..=) "direction" (getFirewallsResponseBody200FirewallsRulesDirection obj) GHC.Base.<> ((Data.Aeson..=) "port" (getFirewallsResponseBody200FirewallsRulesPort obj) GHC.Base.<> ((Data.Aeson..=) "protocol" (getFirewallsResponseBody200FirewallsRulesProtocol obj) GHC.Base.<> (Data.Aeson..=) "source_ips" (getFirewallsResponseBody200FirewallsRulesSourceIps obj))))))
instance Data.Aeson.Types.FromJSON.FromJSON GetFirewallsResponseBody200FirewallsRules
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFirewallsResponseBody200FirewallsRules" (\obj -> (((((GHC.Base.pure GetFirewallsResponseBody200FirewallsRules GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "destination_ips")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "direction")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "port")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "protocol")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "source_ips"))
-- | Defines the enum schema GetFirewallsResponseBody200FirewallsRulesDirection
-- 
-- Select traffic direction on which rule should be applied. Use \`source_ips\` for direction \`in\` and \`destination_ips\` for direction \`out\`.
data GetFirewallsResponseBody200FirewallsRulesDirection
    = GetFirewallsResponseBody200FirewallsRulesDirectionEnumOther Data.Aeson.Types.Internal.Value
    | GetFirewallsResponseBody200FirewallsRulesDirectionEnumTyped Data.Text.Internal.Text
    | GetFirewallsResponseBody200FirewallsRulesDirectionEnumStringIn
    | GetFirewallsResponseBody200FirewallsRulesDirectionEnumStringOut
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFirewallsResponseBody200FirewallsRulesDirection
    where toJSON (GetFirewallsResponseBody200FirewallsRulesDirectionEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetFirewallsResponseBody200FirewallsRulesDirectionEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetFirewallsResponseBody200FirewallsRulesDirectionEnumStringIn) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "in"
          toJSON (GetFirewallsResponseBody200FirewallsRulesDirectionEnumStringOut) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "out"
instance Data.Aeson.FromJSON GetFirewallsResponseBody200FirewallsRulesDirection
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "in")
                                          then GetFirewallsResponseBody200FirewallsRulesDirectionEnumStringIn
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "out")
                                                then GetFirewallsResponseBody200FirewallsRulesDirectionEnumStringOut
                                                else GetFirewallsResponseBody200FirewallsRulesDirectionEnumOther val)
-- | Defines the enum schema GetFirewallsResponseBody200FirewallsRulesProtocol
-- 
-- Type of traffic to allow
data GetFirewallsResponseBody200FirewallsRulesProtocol
    = GetFirewallsResponseBody200FirewallsRulesProtocolEnumOther Data.Aeson.Types.Internal.Value
    | GetFirewallsResponseBody200FirewallsRulesProtocolEnumTyped Data.Text.Internal.Text
    | GetFirewallsResponseBody200FirewallsRulesProtocolEnumStringEsp
    | GetFirewallsResponseBody200FirewallsRulesProtocolEnumStringGre
    | GetFirewallsResponseBody200FirewallsRulesProtocolEnumStringIcmp
    | GetFirewallsResponseBody200FirewallsRulesProtocolEnumStringTcp
    | GetFirewallsResponseBody200FirewallsRulesProtocolEnumStringUdp
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFirewallsResponseBody200FirewallsRulesProtocol
    where toJSON (GetFirewallsResponseBody200FirewallsRulesProtocolEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetFirewallsResponseBody200FirewallsRulesProtocolEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetFirewallsResponseBody200FirewallsRulesProtocolEnumStringEsp) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "esp"
          toJSON (GetFirewallsResponseBody200FirewallsRulesProtocolEnumStringGre) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "gre"
          toJSON (GetFirewallsResponseBody200FirewallsRulesProtocolEnumStringIcmp) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "icmp"
          toJSON (GetFirewallsResponseBody200FirewallsRulesProtocolEnumStringTcp) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "tcp"
          toJSON (GetFirewallsResponseBody200FirewallsRulesProtocolEnumStringUdp) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "udp"
instance Data.Aeson.FromJSON GetFirewallsResponseBody200FirewallsRulesProtocol
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "esp")
                                          then GetFirewallsResponseBody200FirewallsRulesProtocolEnumStringEsp
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "gre")
                                                then GetFirewallsResponseBody200FirewallsRulesProtocolEnumStringGre
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "icmp")
                                                      then GetFirewallsResponseBody200FirewallsRulesProtocolEnumStringIcmp
                                                      else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "tcp")
                                                            then GetFirewallsResponseBody200FirewallsRulesProtocolEnumStringTcp
                                                            else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "udp")
                                                                  then GetFirewallsResponseBody200FirewallsRulesProtocolEnumStringUdp
                                                                  else GetFirewallsResponseBody200FirewallsRulesProtocolEnumOther val)
-- | Defines the data type for the schema GetFirewallsResponseBody200Meta
-- 
-- 
data GetFirewallsResponseBody200Meta = GetFirewallsResponseBody200Meta {
  -- | pagination
  getFirewallsResponseBody200MetaPagination :: GetFirewallsResponseBody200MetaPagination
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFirewallsResponseBody200Meta
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "pagination" (getFirewallsResponseBody200MetaPagination obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "pagination" (getFirewallsResponseBody200MetaPagination obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetFirewallsResponseBody200Meta
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFirewallsResponseBody200Meta" (\obj -> GHC.Base.pure GetFirewallsResponseBody200Meta GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pagination"))
-- | Defines the data type for the schema GetFirewallsResponseBody200MetaPagination
-- 
-- 
data GetFirewallsResponseBody200MetaPagination = GetFirewallsResponseBody200MetaPagination {
  -- | last_page: ID of the last page available. Can be null if the current page is the last one.
  getFirewallsResponseBody200MetaPaginationLastPage :: GHC.Types.Double
  -- | next_page: ID of the next page. Can be null if the current page is the last one.
  , getFirewallsResponseBody200MetaPaginationNextPage :: GHC.Types.Double
  -- | page: Current page number
  , getFirewallsResponseBody200MetaPaginationPage :: GHC.Types.Double
  -- | per_page: Maximum number of items shown per page in the response
  , getFirewallsResponseBody200MetaPaginationPerPage :: GHC.Types.Double
  -- | previous_page: ID of the previous page. Can be null if the current page is the first one.
  , getFirewallsResponseBody200MetaPaginationPreviousPage :: GHC.Types.Double
  -- | total_entries: The total number of entries that exist in the database for this query. Nullable if unknown.
  , getFirewallsResponseBody200MetaPaginationTotalEntries :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFirewallsResponseBody200MetaPagination
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "last_page" (getFirewallsResponseBody200MetaPaginationLastPage obj) : (Data.Aeson..=) "next_page" (getFirewallsResponseBody200MetaPaginationNextPage obj) : (Data.Aeson..=) "page" (getFirewallsResponseBody200MetaPaginationPage obj) : (Data.Aeson..=) "per_page" (getFirewallsResponseBody200MetaPaginationPerPage obj) : (Data.Aeson..=) "previous_page" (getFirewallsResponseBody200MetaPaginationPreviousPage obj) : (Data.Aeson..=) "total_entries" (getFirewallsResponseBody200MetaPaginationTotalEntries obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "last_page" (getFirewallsResponseBody200MetaPaginationLastPage obj) GHC.Base.<> ((Data.Aeson..=) "next_page" (getFirewallsResponseBody200MetaPaginationNextPage obj) GHC.Base.<> ((Data.Aeson..=) "page" (getFirewallsResponseBody200MetaPaginationPage obj) GHC.Base.<> ((Data.Aeson..=) "per_page" (getFirewallsResponseBody200MetaPaginationPerPage obj) GHC.Base.<> ((Data.Aeson..=) "previous_page" (getFirewallsResponseBody200MetaPaginationPreviousPage obj) GHC.Base.<> (Data.Aeson..=) "total_entries" (getFirewallsResponseBody200MetaPaginationTotalEntries obj))))))
instance Data.Aeson.Types.FromJSON.FromJSON GetFirewallsResponseBody200MetaPagination
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFirewallsResponseBody200MetaPagination" (\obj -> (((((GHC.Base.pure GetFirewallsResponseBody200MetaPagination GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "last_page")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "next_page")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "page")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "per_page")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "previous_page")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "total_entries"))
