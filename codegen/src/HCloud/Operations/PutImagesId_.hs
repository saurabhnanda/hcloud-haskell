-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE DeriveGeneric #-}

-- | Contains the different functions to run the operation putImages_Id_
module HCloud.Operations.PutImagesId_ where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Either
import qualified Data.Functor
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Generics
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified HCloud.Common
import HCloud.Types

-- | > PUT /images/{id}
-- 
-- Updates the Image. You may change the description, convert a Backup Image to a Snapshot Image or change the Image labels. Only Images of type \`snapshot\` and \`backup\` can be updated.
-- 
-- Note that when updating labels, the current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.
putImages_Id_ :: forall m s . (HCloud.Common.MonadHTTP m, HCloud.Common.SecurityScheme s) => HCloud.Common.Configuration s  -- ^ The configuration to use in the request
  -> GHC.Integer.Type.Integer                                                                                                  -- ^ id: ID of the Image
  -> GHC.Maybe.Maybe PutImagesIdRequestBody                                                                                    -- ^ The request body to send
  -> m (Data.Either.Either Network.HTTP.Client.Types.HttpException (Network.HTTP.Client.Types.Response PutImagesIdResponse))   -- ^ Monad containing the result of the operation
putImages_Id_ config
              id
              body = GHC.Base.fmap (GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either PutImagesIdResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> PutImagesIdResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                     PutImagesIdResponseBody200)
                                                                                                                                                                          | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0)) (HCloud.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") (Data.Text.pack ("/images/" GHC.Base.++ (Data.ByteString.Char8.unpack (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Data.ByteString.Char8.pack GHC.Base.$ HCloud.Common.stringifyModel id)) GHC.Base.++ ""))) [] body HCloud.Common.RequestBodyEncodingJSON)
-- | > PUT /images/{id}
-- 
-- The same as 'putImages_Id_' but returns the raw 'Data.ByteString.Char8.ByteString'
putImages_Id_Raw :: forall m s . (HCloud.Common.MonadHTTP m,
                                  HCloud.Common.SecurityScheme s) =>
                    HCloud.Common.Configuration s ->
                    GHC.Integer.Type.Integer ->
                    GHC.Maybe.Maybe PutImagesIdRequestBody ->
                    m (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                          (Network.HTTP.Client.Types.Response Data.ByteString.Internal.ByteString))
putImages_Id_Raw config
                 id
                 body = GHC.Base.id (HCloud.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") (Data.Text.pack ("/images/" GHC.Base.++ (Data.ByteString.Char8.unpack (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Data.ByteString.Char8.pack GHC.Base.$ HCloud.Common.stringifyModel id)) GHC.Base.++ ""))) [] body HCloud.Common.RequestBodyEncodingJSON)
-- | > PUT /images/{id}
-- 
-- Monadic version of 'putImages_Id_' (use with 'HCloud.Common.runWithConfiguration')
putImages_Id_M :: forall m s . (HCloud.Common.MonadHTTP m,
                                HCloud.Common.SecurityScheme s) =>
                  GHC.Integer.Type.Integer ->
                  GHC.Maybe.Maybe PutImagesIdRequestBody ->
                  Control.Monad.Trans.Reader.ReaderT (HCloud.Common.Configuration s)
                                                     m
                                                     (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                                                         (Network.HTTP.Client.Types.Response PutImagesIdResponse))
putImages_Id_M id
               body = GHC.Base.fmap (GHC.Base.fmap (\response_2 -> GHC.Base.fmap (Data.Either.either PutImagesIdResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> PutImagesIdResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                      PutImagesIdResponseBody200)
                                                                                                                                                                           | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_2) response_2)) (HCloud.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") (Data.Text.pack ("/images/" GHC.Base.++ (Data.ByteString.Char8.unpack (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Data.ByteString.Char8.pack GHC.Base.$ HCloud.Common.stringifyModel id)) GHC.Base.++ ""))) [] body HCloud.Common.RequestBodyEncodingJSON)
-- | > PUT /images/{id}
-- 
-- Monadic version of 'putImages_Id_Raw' (use with 'HCloud.Common.runWithConfiguration')
putImages_Id_RawM :: forall m s . (HCloud.Common.MonadHTTP m,
                                   HCloud.Common.SecurityScheme s) =>
                     GHC.Integer.Type.Integer ->
                     GHC.Maybe.Maybe PutImagesIdRequestBody ->
                     Control.Monad.Trans.Reader.ReaderT (HCloud.Common.Configuration s)
                                                        m
                                                        (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                                                            (Network.HTTP.Client.Types.Response Data.ByteString.Internal.ByteString))
putImages_Id_RawM id
                  body = GHC.Base.id (HCloud.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") (Data.Text.pack ("/images/" GHC.Base.++ (Data.ByteString.Char8.unpack (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Data.ByteString.Char8.pack GHC.Base.$ HCloud.Common.stringifyModel id)) GHC.Base.++ ""))) [] body HCloud.Common.RequestBodyEncodingJSON)
-- | Defines the data type for the schema putImages_Id_RequestBody
-- 
-- 
data PutImagesIdRequestBody = PutImagesIdRequestBody {
  -- | description: New description of Image
  putImagesIdRequestBodyDescription :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | labels: User-defined labels (key-value pairs)
  , putImagesIdRequestBodyLabels :: (GHC.Maybe.Maybe PutImagesIdRequestBodyLabels)
  -- | type: Destination Image type to convert to
  , putImagesIdRequestBodyType :: (GHC.Maybe.Maybe PutImagesIdRequestBodyType)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PutImagesIdRequestBody
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "description" (putImagesIdRequestBodyDescription obj) : (Data.Aeson..=) "labels" (putImagesIdRequestBodyLabels obj) : (Data.Aeson..=) "type" (putImagesIdRequestBodyType obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "description" (putImagesIdRequestBodyDescription obj) GHC.Base.<> ((Data.Aeson..=) "labels" (putImagesIdRequestBodyLabels obj) GHC.Base.<> (Data.Aeson..=) "type" (putImagesIdRequestBodyType obj)))
instance Data.Aeson.Types.FromJSON.FromJSON PutImagesIdRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutImagesIdRequestBody" (\obj -> ((GHC.Base.pure PutImagesIdRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "labels")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "type"))
-- | Defines the data type for the schema putImages_Id_RequestBodyLabels
-- 
-- User-defined labels (key-value pairs)
data PutImagesIdRequestBodyLabels = PutImagesIdRequestBodyLabels {
  
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PutImagesIdRequestBodyLabels
    where toJSON obj = Data.Aeson.object []
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "string" ("string" :: GHC.Base.String))
instance Data.Aeson.Types.FromJSON.FromJSON PutImagesIdRequestBodyLabels
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutImagesIdRequestBodyLabels" (\obj -> GHC.Base.pure PutImagesIdRequestBodyLabels)
-- | Defines the enum schema putImages_Id_RequestBodyType
-- 
-- Destination Image type to convert to
data PutImagesIdRequestBodyType
    = PutImagesIdRequestBodyTypeEnumOther Data.Aeson.Types.Internal.Value
    | PutImagesIdRequestBodyTypeEnumTyped Data.Text.Internal.Text
    | PutImagesIdRequestBodyTypeEnumStringSnapshot
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON PutImagesIdRequestBodyType
    where toJSON (PutImagesIdRequestBodyTypeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PutImagesIdRequestBodyTypeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PutImagesIdRequestBodyTypeEnumStringSnapshot) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "snapshot"
instance Data.Aeson.FromJSON PutImagesIdRequestBodyType
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "snapshot")
                                          then PutImagesIdRequestBodyTypeEnumStringSnapshot
                                          else PutImagesIdRequestBodyTypeEnumOther val)
-- | Represents a response of the operation 'putImages_Id_'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'PutImagesIdResponseError' is used.
data PutImagesIdResponse =                             
   PutImagesIdResponseError GHC.Base.String            -- ^ Means either no matching case available or a parse error
  | PutImagesIdResponse200 PutImagesIdResponseBody200  -- ^ The image key in the reply contains the modified Image object
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the data type for the schema PutImagesIdResponseBody200
-- 
-- 
data PutImagesIdResponseBody200 = PutImagesIdResponseBody200 {
  -- | image
  putImagesIdResponseBody200Image :: (GHC.Maybe.Maybe PutImagesIdResponseBody200Image)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PutImagesIdResponseBody200
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "image" (putImagesIdResponseBody200Image obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "image" (putImagesIdResponseBody200Image obj))
instance Data.Aeson.Types.FromJSON.FromJSON PutImagesIdResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutImagesIdResponseBody200" (\obj -> GHC.Base.pure PutImagesIdResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "image"))
-- | Defines the data type for the schema PutImagesIdResponseBody200Image
-- 
-- 
data PutImagesIdResponseBody200Image = PutImagesIdResponseBody200Image {
  -- | bound_to: ID of Server the Image is bound to. Only set for Images of type \`backup\`.
  putImagesIdResponseBody200ImageBoundTo :: GHC.Integer.Type.Integer
  -- | build_id: Build ID of the Image
  , putImagesIdResponseBody200ImageBuildId :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | created: Point in time when the Resource was created (in ISO-8601 format)
  , putImagesIdResponseBody200ImageCreated :: Data.Text.Internal.Text
  -- | created_from: Information about the Server the Image was created from
  , putImagesIdResponseBody200ImageCreatedFrom :: PutImagesIdResponseBody200ImageCreatedFrom
  -- | deleted: Point in time where the Image was deleted (in ISO-8601 format)
  , putImagesIdResponseBody200ImageDeleted :: Data.Text.Internal.Text
  -- | deprecated: Point in time when the Image is considered to be deprecated (in ISO-8601 format)
  , putImagesIdResponseBody200ImageDeprecated :: Data.Text.Internal.Text
  -- | description: Description of the Image
  , putImagesIdResponseBody200ImageDescription :: Data.Text.Internal.Text
  -- | disk_size: Size of the disk contained in the Image in GB
  , putImagesIdResponseBody200ImageDiskSize :: GHC.Types.Double
  -- | id: ID of the Resource
  , putImagesIdResponseBody200ImageId :: GHC.Integer.Type.Integer
  -- | image_size: Size of the Image file in our storage in GB. For snapshot Images this is the value relevant for calculating costs for the Image.
  , putImagesIdResponseBody200ImageImageSize :: GHC.Types.Double
  -- | labels: User-defined labels (key-value pairs)
  , putImagesIdResponseBody200ImageLabels :: PutImagesIdResponseBody200ImageLabels
  -- | name: Unique identifier of the Image. This value is only set for system Images.
  , putImagesIdResponseBody200ImageName :: Data.Text.Internal.Text
  -- | os_flavor: Flavor of operating system contained in the Image
  , putImagesIdResponseBody200ImageOsFlavor :: PutImagesIdResponseBody200ImageOsFlavor
  -- | os_version: Operating system version
  , putImagesIdResponseBody200ImageOsVersion :: Data.Text.Internal.Text
  -- | protection: Protection configuration for the Resource
  , putImagesIdResponseBody200ImageProtection :: PutImagesIdResponseBody200ImageProtection
  -- | rapid_deploy: Indicates that rapid deploy of the Image is available
  , putImagesIdResponseBody200ImageRapidDeploy :: (GHC.Maybe.Maybe GHC.Types.Bool)
  -- | status: Whether the Image can be used or if it\'s still being created or unavailable
  , putImagesIdResponseBody200ImageStatus :: PutImagesIdResponseBody200ImageStatus
  -- | type: Type of the Image
  , putImagesIdResponseBody200ImageType :: PutImagesIdResponseBody200ImageType
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PutImagesIdResponseBody200Image
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "bound_to" (putImagesIdResponseBody200ImageBoundTo obj) : (Data.Aeson..=) "build_id" (putImagesIdResponseBody200ImageBuildId obj) : (Data.Aeson..=) "created" (putImagesIdResponseBody200ImageCreated obj) : (Data.Aeson..=) "created_from" (putImagesIdResponseBody200ImageCreatedFrom obj) : (Data.Aeson..=) "deleted" (putImagesIdResponseBody200ImageDeleted obj) : (Data.Aeson..=) "deprecated" (putImagesIdResponseBody200ImageDeprecated obj) : (Data.Aeson..=) "description" (putImagesIdResponseBody200ImageDescription obj) : (Data.Aeson..=) "disk_size" (putImagesIdResponseBody200ImageDiskSize obj) : (Data.Aeson..=) "id" (putImagesIdResponseBody200ImageId obj) : (Data.Aeson..=) "image_size" (putImagesIdResponseBody200ImageImageSize obj) : (Data.Aeson..=) "labels" (putImagesIdResponseBody200ImageLabels obj) : (Data.Aeson..=) "name" (putImagesIdResponseBody200ImageName obj) : (Data.Aeson..=) "os_flavor" (putImagesIdResponseBody200ImageOsFlavor obj) : (Data.Aeson..=) "os_version" (putImagesIdResponseBody200ImageOsVersion obj) : (Data.Aeson..=) "protection" (putImagesIdResponseBody200ImageProtection obj) : (Data.Aeson..=) "rapid_deploy" (putImagesIdResponseBody200ImageRapidDeploy obj) : (Data.Aeson..=) "status" (putImagesIdResponseBody200ImageStatus obj) : (Data.Aeson..=) "type" (putImagesIdResponseBody200ImageType obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "bound_to" (putImagesIdResponseBody200ImageBoundTo obj) GHC.Base.<> ((Data.Aeson..=) "build_id" (putImagesIdResponseBody200ImageBuildId obj) GHC.Base.<> ((Data.Aeson..=) "created" (putImagesIdResponseBody200ImageCreated obj) GHC.Base.<> ((Data.Aeson..=) "created_from" (putImagesIdResponseBody200ImageCreatedFrom obj) GHC.Base.<> ((Data.Aeson..=) "deleted" (putImagesIdResponseBody200ImageDeleted obj) GHC.Base.<> ((Data.Aeson..=) "deprecated" (putImagesIdResponseBody200ImageDeprecated obj) GHC.Base.<> ((Data.Aeson..=) "description" (putImagesIdResponseBody200ImageDescription obj) GHC.Base.<> ((Data.Aeson..=) "disk_size" (putImagesIdResponseBody200ImageDiskSize obj) GHC.Base.<> ((Data.Aeson..=) "id" (putImagesIdResponseBody200ImageId obj) GHC.Base.<> ((Data.Aeson..=) "image_size" (putImagesIdResponseBody200ImageImageSize obj) GHC.Base.<> ((Data.Aeson..=) "labels" (putImagesIdResponseBody200ImageLabels obj) GHC.Base.<> ((Data.Aeson..=) "name" (putImagesIdResponseBody200ImageName obj) GHC.Base.<> ((Data.Aeson..=) "os_flavor" (putImagesIdResponseBody200ImageOsFlavor obj) GHC.Base.<> ((Data.Aeson..=) "os_version" (putImagesIdResponseBody200ImageOsVersion obj) GHC.Base.<> ((Data.Aeson..=) "protection" (putImagesIdResponseBody200ImageProtection obj) GHC.Base.<> ((Data.Aeson..=) "rapid_deploy" (putImagesIdResponseBody200ImageRapidDeploy obj) GHC.Base.<> ((Data.Aeson..=) "status" (putImagesIdResponseBody200ImageStatus obj) GHC.Base.<> (Data.Aeson..=) "type" (putImagesIdResponseBody200ImageType obj))))))))))))))))))
instance Data.Aeson.Types.FromJSON.FromJSON PutImagesIdResponseBody200Image
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutImagesIdResponseBody200Image" (\obj -> (((((((((((((((((GHC.Base.pure PutImagesIdResponseBody200Image GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "bound_to")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "build_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created_from")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deleted")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deprecated")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "disk_size")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "image_size")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "labels")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "os_flavor")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "os_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "protection")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "rapid_deploy")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "type"))
-- | Defines the data type for the schema PutImagesIdResponseBody200ImageCreated_from
-- 
-- Information about the Server the Image was created from
data PutImagesIdResponseBody200ImageCreatedFrom = PutImagesIdResponseBody200ImageCreatedFrom {
  -- | id: ID of the Server the Image was created from
  putImagesIdResponseBody200ImageCreatedFromId :: GHC.Integer.Type.Integer
  -- | name: Server name at the time the Image was created
  , putImagesIdResponseBody200ImageCreatedFromName :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PutImagesIdResponseBody200ImageCreatedFrom
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "id" (putImagesIdResponseBody200ImageCreatedFromId obj) : (Data.Aeson..=) "name" (putImagesIdResponseBody200ImageCreatedFromName obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "id" (putImagesIdResponseBody200ImageCreatedFromId obj) GHC.Base.<> (Data.Aeson..=) "name" (putImagesIdResponseBody200ImageCreatedFromName obj))
instance Data.Aeson.Types.FromJSON.FromJSON PutImagesIdResponseBody200ImageCreatedFrom
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutImagesIdResponseBody200ImageCreatedFrom" (\obj -> (GHC.Base.pure PutImagesIdResponseBody200ImageCreatedFrom GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name"))
-- | Defines the data type for the schema PutImagesIdResponseBody200ImageLabels
-- 
-- User-defined labels (key-value pairs)
data PutImagesIdResponseBody200ImageLabels = PutImagesIdResponseBody200ImageLabels {
  
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PutImagesIdResponseBody200ImageLabels
    where toJSON obj = Data.Aeson.object []
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "string" ("string" :: GHC.Base.String))
instance Data.Aeson.Types.FromJSON.FromJSON PutImagesIdResponseBody200ImageLabels
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutImagesIdResponseBody200ImageLabels" (\obj -> GHC.Base.pure PutImagesIdResponseBody200ImageLabels)
-- | Defines the enum schema PutImagesIdResponseBody200ImageOs_flavor
-- 
-- Flavor of operating system contained in the Image
data PutImagesIdResponseBody200ImageOsFlavor
    = PutImagesIdResponseBody200ImageOsFlavorEnumOther Data.Aeson.Types.Internal.Value
    | PutImagesIdResponseBody200ImageOsFlavorEnumTyped Data.Text.Internal.Text
    | PutImagesIdResponseBody200ImageOsFlavorEnumStringCentos
    | PutImagesIdResponseBody200ImageOsFlavorEnumStringDebian
    | PutImagesIdResponseBody200ImageOsFlavorEnumStringFedora
    | PutImagesIdResponseBody200ImageOsFlavorEnumStringUbuntu
    | PutImagesIdResponseBody200ImageOsFlavorEnumStringUnknown
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON PutImagesIdResponseBody200ImageOsFlavor
    where toJSON (PutImagesIdResponseBody200ImageOsFlavorEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PutImagesIdResponseBody200ImageOsFlavorEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PutImagesIdResponseBody200ImageOsFlavorEnumStringCentos) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "centos"
          toJSON (PutImagesIdResponseBody200ImageOsFlavorEnumStringDebian) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "debian"
          toJSON (PutImagesIdResponseBody200ImageOsFlavorEnumStringFedora) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "fedora"
          toJSON (PutImagesIdResponseBody200ImageOsFlavorEnumStringUbuntu) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "ubuntu"
          toJSON (PutImagesIdResponseBody200ImageOsFlavorEnumStringUnknown) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "unknown"
instance Data.Aeson.FromJSON PutImagesIdResponseBody200ImageOsFlavor
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "centos")
                                          then PutImagesIdResponseBody200ImageOsFlavorEnumStringCentos
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "debian")
                                                then PutImagesIdResponseBody200ImageOsFlavorEnumStringDebian
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "fedora")
                                                      then PutImagesIdResponseBody200ImageOsFlavorEnumStringFedora
                                                      else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "ubuntu")
                                                            then PutImagesIdResponseBody200ImageOsFlavorEnumStringUbuntu
                                                            else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "unknown")
                                                                  then PutImagesIdResponseBody200ImageOsFlavorEnumStringUnknown
                                                                  else PutImagesIdResponseBody200ImageOsFlavorEnumOther val)
-- | Defines the data type for the schema PutImagesIdResponseBody200ImageProtection
-- 
-- Protection configuration for the Resource
data PutImagesIdResponseBody200ImageProtection = PutImagesIdResponseBody200ImageProtection {
  -- | delete: If true, prevents the Resource from being deleted
  putImagesIdResponseBody200ImageProtectionDelete :: GHC.Types.Bool
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PutImagesIdResponseBody200ImageProtection
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "delete" (putImagesIdResponseBody200ImageProtectionDelete obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "delete" (putImagesIdResponseBody200ImageProtectionDelete obj))
instance Data.Aeson.Types.FromJSON.FromJSON PutImagesIdResponseBody200ImageProtection
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutImagesIdResponseBody200ImageProtection" (\obj -> GHC.Base.pure PutImagesIdResponseBody200ImageProtection GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "delete"))
-- | Defines the enum schema PutImagesIdResponseBody200ImageStatus
-- 
-- Whether the Image can be used or if it\'s still being created or unavailable
data PutImagesIdResponseBody200ImageStatus
    = PutImagesIdResponseBody200ImageStatusEnumOther Data.Aeson.Types.Internal.Value
    | PutImagesIdResponseBody200ImageStatusEnumTyped Data.Text.Internal.Text
    | PutImagesIdResponseBody200ImageStatusEnumStringAvailable
    | PutImagesIdResponseBody200ImageStatusEnumStringCreating
    | PutImagesIdResponseBody200ImageStatusEnumStringUnavailable
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON PutImagesIdResponseBody200ImageStatus
    where toJSON (PutImagesIdResponseBody200ImageStatusEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PutImagesIdResponseBody200ImageStatusEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PutImagesIdResponseBody200ImageStatusEnumStringAvailable) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "available"
          toJSON (PutImagesIdResponseBody200ImageStatusEnumStringCreating) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "creating"
          toJSON (PutImagesIdResponseBody200ImageStatusEnumStringUnavailable) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "unavailable"
instance Data.Aeson.FromJSON PutImagesIdResponseBody200ImageStatus
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "available")
                                          then PutImagesIdResponseBody200ImageStatusEnumStringAvailable
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "creating")
                                                then PutImagesIdResponseBody200ImageStatusEnumStringCreating
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "unavailable")
                                                      then PutImagesIdResponseBody200ImageStatusEnumStringUnavailable
                                                      else PutImagesIdResponseBody200ImageStatusEnumOther val)
-- | Defines the enum schema PutImagesIdResponseBody200ImageType
-- 
-- Type of the Image
data PutImagesIdResponseBody200ImageType
    = PutImagesIdResponseBody200ImageTypeEnumOther Data.Aeson.Types.Internal.Value
    | PutImagesIdResponseBody200ImageTypeEnumTyped Data.Text.Internal.Text
    | PutImagesIdResponseBody200ImageTypeEnumStringApp
    | PutImagesIdResponseBody200ImageTypeEnumStringBackup
    | PutImagesIdResponseBody200ImageTypeEnumStringSnapshot
    | PutImagesIdResponseBody200ImageTypeEnumStringSystem
    | PutImagesIdResponseBody200ImageTypeEnumStringTemporary
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON PutImagesIdResponseBody200ImageType
    where toJSON (PutImagesIdResponseBody200ImageTypeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PutImagesIdResponseBody200ImageTypeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PutImagesIdResponseBody200ImageTypeEnumStringApp) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "app"
          toJSON (PutImagesIdResponseBody200ImageTypeEnumStringBackup) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "backup"
          toJSON (PutImagesIdResponseBody200ImageTypeEnumStringSnapshot) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "snapshot"
          toJSON (PutImagesIdResponseBody200ImageTypeEnumStringSystem) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "system"
          toJSON (PutImagesIdResponseBody200ImageTypeEnumStringTemporary) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "temporary"
instance Data.Aeson.FromJSON PutImagesIdResponseBody200ImageType
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "app")
                                          then PutImagesIdResponseBody200ImageTypeEnumStringApp
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "backup")
                                                then PutImagesIdResponseBody200ImageTypeEnumStringBackup
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "snapshot")
                                                      then PutImagesIdResponseBody200ImageTypeEnumStringSnapshot
                                                      else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "system")
                                                            then PutImagesIdResponseBody200ImageTypeEnumStringSystem
                                                            else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "temporary")
                                                                  then PutImagesIdResponseBody200ImageTypeEnumStringTemporary
                                                                  else PutImagesIdResponseBody200ImageTypeEnumOther val)
