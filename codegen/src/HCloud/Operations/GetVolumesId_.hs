-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE DeriveGeneric #-}

-- | Contains the different functions to run the operation getVolumes_Id_
module HCloud.Operations.GetVolumesId_ where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Either
import qualified Data.Functor
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Generics
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified HCloud.Common
import HCloud.Types

-- | > GET /volumes/{id}
-- 
-- Gets a specific Volume object.
getVolumes_Id_ :: forall m s . (HCloud.Common.MonadHTTP m, HCloud.Common.SecurityScheme s) => HCloud.Common.Configuration s  -- ^ The configuration to use in the request
  -> GHC.Integer.Type.Integer                                                                                                   -- ^ id: ID of the Volume
  -> m (Data.Either.Either Network.HTTP.Client.Types.HttpException (Network.HTTP.Client.Types.Response GetVolumesIdResponse))   -- ^ Monad containing the result of the operation
getVolumes_Id_ config
               id = GHC.Base.fmap (GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either GetVolumesIdResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetVolumesIdResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                      GetVolumesIdResponseBody200)
                                                                                                                                                                          | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0)) (HCloud.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack ("/volumes/" GHC.Base.++ (Data.ByteString.Char8.unpack (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Data.ByteString.Char8.pack GHC.Base.$ HCloud.Common.stringifyModel id)) GHC.Base.++ ""))) [])
-- | > GET /volumes/{id}
-- 
-- The same as 'getVolumes_Id_' but returns the raw 'Data.ByteString.Char8.ByteString'
getVolumes_Id_Raw :: forall m s . (HCloud.Common.MonadHTTP m,
                                   HCloud.Common.SecurityScheme s) =>
                     HCloud.Common.Configuration s ->
                     GHC.Integer.Type.Integer ->
                     m (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                           (Network.HTTP.Client.Types.Response Data.ByteString.Internal.ByteString))
getVolumes_Id_Raw config
                  id = GHC.Base.id (HCloud.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack ("/volumes/" GHC.Base.++ (Data.ByteString.Char8.unpack (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Data.ByteString.Char8.pack GHC.Base.$ HCloud.Common.stringifyModel id)) GHC.Base.++ ""))) [])
-- | > GET /volumes/{id}
-- 
-- Monadic version of 'getVolumes_Id_' (use with 'HCloud.Common.runWithConfiguration')
getVolumes_Id_M :: forall m s . (HCloud.Common.MonadHTTP m,
                                 HCloud.Common.SecurityScheme s) =>
                   GHC.Integer.Type.Integer ->
                   Control.Monad.Trans.Reader.ReaderT (HCloud.Common.Configuration s)
                                                      m
                                                      (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                                                          (Network.HTTP.Client.Types.Response GetVolumesIdResponse))
getVolumes_Id_M id = GHC.Base.fmap (GHC.Base.fmap (\response_2 -> GHC.Base.fmap (Data.Either.either GetVolumesIdResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetVolumesIdResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                       GetVolumesIdResponseBody200)
                                                                                                                                                                           | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_2) response_2)) (HCloud.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack ("/volumes/" GHC.Base.++ (Data.ByteString.Char8.unpack (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Data.ByteString.Char8.pack GHC.Base.$ HCloud.Common.stringifyModel id)) GHC.Base.++ ""))) [])
-- | > GET /volumes/{id}
-- 
-- Monadic version of 'getVolumes_Id_Raw' (use with 'HCloud.Common.runWithConfiguration')
getVolumes_Id_RawM :: forall m s . (HCloud.Common.MonadHTTP m,
                                    HCloud.Common.SecurityScheme s) =>
                      GHC.Integer.Type.Integer ->
                      Control.Monad.Trans.Reader.ReaderT (HCloud.Common.Configuration s)
                                                         m
                                                         (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                                                             (Network.HTTP.Client.Types.Response Data.ByteString.Internal.ByteString))
getVolumes_Id_RawM id = GHC.Base.id (HCloud.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack ("/volumes/" GHC.Base.++ (Data.ByteString.Char8.unpack (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Data.ByteString.Char8.pack GHC.Base.$ HCloud.Common.stringifyModel id)) GHC.Base.++ ""))) [])
-- | Represents a response of the operation 'getVolumes_Id_'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'GetVolumesIdResponseError' is used.
data GetVolumesIdResponse =                              
   GetVolumesIdResponseError GHC.Base.String             -- ^ Means either no matching case available or a parse error
  | GetVolumesIdResponse200 GetVolumesIdResponseBody200  -- ^ The \`volume\` key contains the volume
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the data type for the schema GetVolumesIdResponseBody200
-- 
-- 
data GetVolumesIdResponseBody200 = GetVolumesIdResponseBody200 {
  -- | volume
  getVolumesIdResponseBody200Volume :: GetVolumesIdResponseBody200Volume
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetVolumesIdResponseBody200
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "volume" (getVolumesIdResponseBody200Volume obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "volume" (getVolumesIdResponseBody200Volume obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetVolumesIdResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetVolumesIdResponseBody200" (\obj -> GHC.Base.pure GetVolumesIdResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "volume"))
-- | Defines the data type for the schema GetVolumesIdResponseBody200Volume
-- 
-- 
data GetVolumesIdResponseBody200Volume = GetVolumesIdResponseBody200Volume {
  -- | created: Point in time when the Resource was created (in ISO-8601 format)
  getVolumesIdResponseBody200VolumeCreated :: Data.Text.Internal.Text
  -- | format: Filesystem of the Volume if formatted on creation, null if not formatted on creation
  , getVolumesIdResponseBody200VolumeFormat :: Data.Text.Internal.Text
  -- | id: ID of the Resource
  , getVolumesIdResponseBody200VolumeId :: GHC.Integer.Type.Integer
  -- | labels: User-defined labels (key-value pairs)
  , getVolumesIdResponseBody200VolumeLabels :: GetVolumesIdResponseBody200VolumeLabels
  -- | linux_device: Device path on the file system for the Volume
  , getVolumesIdResponseBody200VolumeLinuxDevice :: Data.Text.Internal.Text
  -- | location: Location of the Volume. Volume can only be attached to Servers in the same Location.
  , getVolumesIdResponseBody200VolumeLocation :: GetVolumesIdResponseBody200VolumeLocation
  -- | name: Name of the Resource. Must be unique per Project.
  , getVolumesIdResponseBody200VolumeName :: Data.Text.Internal.Text
  -- | protection: Protection configuration for the Resource
  , getVolumesIdResponseBody200VolumeProtection :: GetVolumesIdResponseBody200VolumeProtection
  -- | server: ID of the Server the Volume is attached to, null if it is not attached at all
  , getVolumesIdResponseBody200VolumeServer :: GHC.Integer.Type.Integer
  -- | size: Size in GB of the Volume
  , getVolumesIdResponseBody200VolumeSize :: GHC.Types.Double
  -- | status: Current status of the Volume
  , getVolumesIdResponseBody200VolumeStatus :: GetVolumesIdResponseBody200VolumeStatus
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetVolumesIdResponseBody200Volume
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "created" (getVolumesIdResponseBody200VolumeCreated obj) : (Data.Aeson..=) "format" (getVolumesIdResponseBody200VolumeFormat obj) : (Data.Aeson..=) "id" (getVolumesIdResponseBody200VolumeId obj) : (Data.Aeson..=) "labels" (getVolumesIdResponseBody200VolumeLabels obj) : (Data.Aeson..=) "linux_device" (getVolumesIdResponseBody200VolumeLinuxDevice obj) : (Data.Aeson..=) "location" (getVolumesIdResponseBody200VolumeLocation obj) : (Data.Aeson..=) "name" (getVolumesIdResponseBody200VolumeName obj) : (Data.Aeson..=) "protection" (getVolumesIdResponseBody200VolumeProtection obj) : (Data.Aeson..=) "server" (getVolumesIdResponseBody200VolumeServer obj) : (Data.Aeson..=) "size" (getVolumesIdResponseBody200VolumeSize obj) : (Data.Aeson..=) "status" (getVolumesIdResponseBody200VolumeStatus obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "created" (getVolumesIdResponseBody200VolumeCreated obj) GHC.Base.<> ((Data.Aeson..=) "format" (getVolumesIdResponseBody200VolumeFormat obj) GHC.Base.<> ((Data.Aeson..=) "id" (getVolumesIdResponseBody200VolumeId obj) GHC.Base.<> ((Data.Aeson..=) "labels" (getVolumesIdResponseBody200VolumeLabels obj) GHC.Base.<> ((Data.Aeson..=) "linux_device" (getVolumesIdResponseBody200VolumeLinuxDevice obj) GHC.Base.<> ((Data.Aeson..=) "location" (getVolumesIdResponseBody200VolumeLocation obj) GHC.Base.<> ((Data.Aeson..=) "name" (getVolumesIdResponseBody200VolumeName obj) GHC.Base.<> ((Data.Aeson..=) "protection" (getVolumesIdResponseBody200VolumeProtection obj) GHC.Base.<> ((Data.Aeson..=) "server" (getVolumesIdResponseBody200VolumeServer obj) GHC.Base.<> ((Data.Aeson..=) "size" (getVolumesIdResponseBody200VolumeSize obj) GHC.Base.<> (Data.Aeson..=) "status" (getVolumesIdResponseBody200VolumeStatus obj)))))))))))
instance Data.Aeson.Types.FromJSON.FromJSON GetVolumesIdResponseBody200Volume
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetVolumesIdResponseBody200Volume" (\obj -> ((((((((((GHC.Base.pure GetVolumesIdResponseBody200Volume GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "format")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "labels")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "linux_device")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "location")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "protection")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "server")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "size")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status"))
-- | Defines the data type for the schema GetVolumesIdResponseBody200VolumeLabels
-- 
-- User-defined labels (key-value pairs)
data GetVolumesIdResponseBody200VolumeLabels = GetVolumesIdResponseBody200VolumeLabels {
  
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetVolumesIdResponseBody200VolumeLabels
    where toJSON obj = Data.Aeson.object []
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "string" ("string" :: GHC.Base.String))
instance Data.Aeson.Types.FromJSON.FromJSON GetVolumesIdResponseBody200VolumeLabels
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetVolumesIdResponseBody200VolumeLabels" (\obj -> GHC.Base.pure GetVolumesIdResponseBody200VolumeLabels)
-- | Defines the data type for the schema GetVolumesIdResponseBody200VolumeLocation
-- 
-- Location of the Volume. Volume can only be attached to Servers in the same Location.
data GetVolumesIdResponseBody200VolumeLocation = GetVolumesIdResponseBody200VolumeLocation {
  -- | city: City the Location is closest to
  getVolumesIdResponseBody200VolumeLocationCity :: Data.Text.Internal.Text
  -- | country: ISO 3166-1 alpha-2 code of the country the Location resides in
  , getVolumesIdResponseBody200VolumeLocationCountry :: Data.Text.Internal.Text
  -- | description: Description of the Location
  , getVolumesIdResponseBody200VolumeLocationDescription :: Data.Text.Internal.Text
  -- | id: ID of the Location
  , getVolumesIdResponseBody200VolumeLocationId :: GHC.Types.Double
  -- | latitude: Latitude of the city closest to the Location
  , getVolumesIdResponseBody200VolumeLocationLatitude :: GHC.Types.Double
  -- | longitude: Longitude of the city closest to the Location
  , getVolumesIdResponseBody200VolumeLocationLongitude :: GHC.Types.Double
  -- | name: Unique identifier of the Location
  , getVolumesIdResponseBody200VolumeLocationName :: Data.Text.Internal.Text
  -- | network_zone: Name of network zone this Location resides in
  , getVolumesIdResponseBody200VolumeLocationNetworkZone :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetVolumesIdResponseBody200VolumeLocation
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "city" (getVolumesIdResponseBody200VolumeLocationCity obj) : (Data.Aeson..=) "country" (getVolumesIdResponseBody200VolumeLocationCountry obj) : (Data.Aeson..=) "description" (getVolumesIdResponseBody200VolumeLocationDescription obj) : (Data.Aeson..=) "id" (getVolumesIdResponseBody200VolumeLocationId obj) : (Data.Aeson..=) "latitude" (getVolumesIdResponseBody200VolumeLocationLatitude obj) : (Data.Aeson..=) "longitude" (getVolumesIdResponseBody200VolumeLocationLongitude obj) : (Data.Aeson..=) "name" (getVolumesIdResponseBody200VolumeLocationName obj) : (Data.Aeson..=) "network_zone" (getVolumesIdResponseBody200VolumeLocationNetworkZone obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "city" (getVolumesIdResponseBody200VolumeLocationCity obj) GHC.Base.<> ((Data.Aeson..=) "country" (getVolumesIdResponseBody200VolumeLocationCountry obj) GHC.Base.<> ((Data.Aeson..=) "description" (getVolumesIdResponseBody200VolumeLocationDescription obj) GHC.Base.<> ((Data.Aeson..=) "id" (getVolumesIdResponseBody200VolumeLocationId obj) GHC.Base.<> ((Data.Aeson..=) "latitude" (getVolumesIdResponseBody200VolumeLocationLatitude obj) GHC.Base.<> ((Data.Aeson..=) "longitude" (getVolumesIdResponseBody200VolumeLocationLongitude obj) GHC.Base.<> ((Data.Aeson..=) "name" (getVolumesIdResponseBody200VolumeLocationName obj) GHC.Base.<> (Data.Aeson..=) "network_zone" (getVolumesIdResponseBody200VolumeLocationNetworkZone obj))))))))
instance Data.Aeson.Types.FromJSON.FromJSON GetVolumesIdResponseBody200VolumeLocation
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetVolumesIdResponseBody200VolumeLocation" (\obj -> (((((((GHC.Base.pure GetVolumesIdResponseBody200VolumeLocation GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "city")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "country")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "latitude")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "longitude")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "network_zone"))
-- | Defines the data type for the schema GetVolumesIdResponseBody200VolumeProtection
-- 
-- Protection configuration for the Resource
data GetVolumesIdResponseBody200VolumeProtection = GetVolumesIdResponseBody200VolumeProtection {
  -- | delete: If true, prevents the Resource from being deleted
  getVolumesIdResponseBody200VolumeProtectionDelete :: GHC.Types.Bool
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetVolumesIdResponseBody200VolumeProtection
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "delete" (getVolumesIdResponseBody200VolumeProtectionDelete obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "delete" (getVolumesIdResponseBody200VolumeProtectionDelete obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetVolumesIdResponseBody200VolumeProtection
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetVolumesIdResponseBody200VolumeProtection" (\obj -> GHC.Base.pure GetVolumesIdResponseBody200VolumeProtection GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "delete"))
-- | Defines the enum schema GetVolumesIdResponseBody200VolumeStatus
-- 
-- Current status of the Volume
data GetVolumesIdResponseBody200VolumeStatus
    = GetVolumesIdResponseBody200VolumeStatusEnumOther Data.Aeson.Types.Internal.Value
    | GetVolumesIdResponseBody200VolumeStatusEnumTyped Data.Text.Internal.Text
    | GetVolumesIdResponseBody200VolumeStatusEnumStringAvailable
    | GetVolumesIdResponseBody200VolumeStatusEnumStringCreating
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetVolumesIdResponseBody200VolumeStatus
    where toJSON (GetVolumesIdResponseBody200VolumeStatusEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetVolumesIdResponseBody200VolumeStatusEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetVolumesIdResponseBody200VolumeStatusEnumStringAvailable) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "available"
          toJSON (GetVolumesIdResponseBody200VolumeStatusEnumStringCreating) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "creating"
instance Data.Aeson.FromJSON GetVolumesIdResponseBody200VolumeStatus
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "available")
                                          then GetVolumesIdResponseBody200VolumeStatusEnumStringAvailable
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "creating")
                                                then GetVolumesIdResponseBody200VolumeStatusEnumStringCreating
                                                else GetVolumesIdResponseBody200VolumeStatusEnumOther val)
