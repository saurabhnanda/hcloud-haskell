-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE DeriveGeneric #-}

-- | Contains the different functions to run the operation getServers_Id_
module HCloud.Operations.GetServersId_ where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Either
import qualified Data.Functor
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Generics
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified HCloud.Common
import HCloud.Types

-- | > GET /servers/{id}
-- 
-- Returns a specific Server object. The Server must exist inside the Project
getServers_Id_ :: forall m s . (HCloud.Common.MonadHTTP m, HCloud.Common.SecurityScheme s) => HCloud.Common.Configuration s  -- ^ The configuration to use in the request
  -> GHC.Integer.Type.Integer                                                                                                   -- ^ id: ID of the Server
  -> m (Data.Either.Either Network.HTTP.Client.Types.HttpException (Network.HTTP.Client.Types.Response GetServersIdResponse))   -- ^ Monad containing the result of the operation
getServers_Id_ config
               id = GHC.Base.fmap (GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either GetServersIdResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetServersIdResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                      GetServersIdResponseBody200)
                                                                                                                                                                          | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0)) (HCloud.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack ("/servers/" GHC.Base.++ (Data.ByteString.Char8.unpack (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Data.ByteString.Char8.pack GHC.Base.$ HCloud.Common.stringifyModel id)) GHC.Base.++ ""))) [])
-- | > GET /servers/{id}
-- 
-- The same as 'getServers_Id_' but returns the raw 'Data.ByteString.Char8.ByteString'
getServers_Id_Raw :: forall m s . (HCloud.Common.MonadHTTP m,
                                   HCloud.Common.SecurityScheme s) =>
                     HCloud.Common.Configuration s ->
                     GHC.Integer.Type.Integer ->
                     m (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                           (Network.HTTP.Client.Types.Response Data.ByteString.Internal.ByteString))
getServers_Id_Raw config
                  id = GHC.Base.id (HCloud.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack ("/servers/" GHC.Base.++ (Data.ByteString.Char8.unpack (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Data.ByteString.Char8.pack GHC.Base.$ HCloud.Common.stringifyModel id)) GHC.Base.++ ""))) [])
-- | > GET /servers/{id}
-- 
-- Monadic version of 'getServers_Id_' (use with 'HCloud.Common.runWithConfiguration')
getServers_Id_M :: forall m s . (HCloud.Common.MonadHTTP m,
                                 HCloud.Common.SecurityScheme s) =>
                   GHC.Integer.Type.Integer ->
                   Control.Monad.Trans.Reader.ReaderT (HCloud.Common.Configuration s)
                                                      m
                                                      (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                                                          (Network.HTTP.Client.Types.Response GetServersIdResponse))
getServers_Id_M id = GHC.Base.fmap (GHC.Base.fmap (\response_2 -> GHC.Base.fmap (Data.Either.either GetServersIdResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetServersIdResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                       GetServersIdResponseBody200)
                                                                                                                                                                           | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_2) response_2)) (HCloud.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack ("/servers/" GHC.Base.++ (Data.ByteString.Char8.unpack (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Data.ByteString.Char8.pack GHC.Base.$ HCloud.Common.stringifyModel id)) GHC.Base.++ ""))) [])
-- | > GET /servers/{id}
-- 
-- Monadic version of 'getServers_Id_Raw' (use with 'HCloud.Common.runWithConfiguration')
getServers_Id_RawM :: forall m s . (HCloud.Common.MonadHTTP m,
                                    HCloud.Common.SecurityScheme s) =>
                      GHC.Integer.Type.Integer ->
                      Control.Monad.Trans.Reader.ReaderT (HCloud.Common.Configuration s)
                                                         m
                                                         (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                                                             (Network.HTTP.Client.Types.Response Data.ByteString.Internal.ByteString))
getServers_Id_RawM id = GHC.Base.id (HCloud.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack ("/servers/" GHC.Base.++ (Data.ByteString.Char8.unpack (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Data.ByteString.Char8.pack GHC.Base.$ HCloud.Common.stringifyModel id)) GHC.Base.++ ""))) [])
-- | Represents a response of the operation 'getServers_Id_'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'GetServersIdResponseError' is used.
data GetServersIdResponse =                              
   GetServersIdResponseError GHC.Base.String             -- ^ Means either no matching case available or a parse error
  | GetServersIdResponse200 GetServersIdResponseBody200  -- ^ The \`server\` key in the reply contains a Server object with this structure
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the data type for the schema GetServersIdResponseBody200
-- 
-- 
data GetServersIdResponseBody200 = GetServersIdResponseBody200 {
  -- | server
  getServersIdResponseBody200Server :: (GHC.Maybe.Maybe GetServersIdResponseBody200Server)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "server" (getServersIdResponseBody200Server obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "server" (getServersIdResponseBody200Server obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200" (\obj -> GHC.Base.pure GetServersIdResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "server"))
-- | Defines the data type for the schema GetServersIdResponseBody200Server
-- 
-- 
data GetServersIdResponseBody200Server = GetServersIdResponseBody200Server {
  -- | backup_window: Time window (UTC) in which the backup will run, or null if the backups are not enabled
  getServersIdResponseBody200ServerBackupWindow :: Data.Text.Internal.Text
  -- | created: Point in time when the Resource was created (in ISO-8601 format)
  , getServersIdResponseBody200ServerCreated :: Data.Text.Internal.Text
  -- | datacenter: Datacenter this Resource is located at
  , getServersIdResponseBody200ServerDatacenter :: GetServersIdResponseBody200ServerDatacenter
  -- | id: ID of the Resource
  , getServersIdResponseBody200ServerId :: GHC.Integer.Type.Integer
  -- | image
  , getServersIdResponseBody200ServerImage :: GetServersIdResponseBody200ServerImage
  -- | included_traffic: Free Traffic for the current billing period in bytes
  , getServersIdResponseBody200ServerIncludedTraffic :: GHC.Types.Double
  -- | ingoing_traffic: Inbound Traffic for the current billing period in bytes
  , getServersIdResponseBody200ServerIngoingTraffic :: GHC.Types.Double
  -- | iso: ISO Image that is attached to this Server. Null if no ISO is attached.
  , getServersIdResponseBody200ServerIso :: GetServersIdResponseBody200ServerIso
  -- | labels: User-defined labels (key-value pairs)
  , getServersIdResponseBody200ServerLabels :: GetServersIdResponseBody200ServerLabels
  -- | load_balancers
  , getServersIdResponseBody200ServerLoadBalancers :: (GHC.Maybe.Maybe ([] GHC.Integer.Type.Integer))
  -- | locked: True if Server has been locked and is not available to user
  , getServersIdResponseBody200ServerLocked :: GHC.Types.Bool
  -- | name: Name of the Resource. Must be unique per Project.
  , getServersIdResponseBody200ServerName :: Data.Text.Internal.Text
  -- | outgoing_traffic: Outbound Traffic for the current billing period in bytes
  , getServersIdResponseBody200ServerOutgoingTraffic :: GHC.Types.Double
  -- | placement_group
  , getServersIdResponseBody200ServerPlacementGroup :: (GHC.Maybe.Maybe GetServersIdResponseBody200ServerPlacementGroup)
  -- | primary_disk_size: Size of the primary Disk
  , getServersIdResponseBody200ServerPrimaryDiskSize :: GHC.Types.Double
  -- | private_net: Private networks information
  , getServersIdResponseBody200ServerPrivateNet :: ([] GetServersIdResponseBody200ServerPrivateNet)
  -- | protection: Protection configuration for the Server
  , getServersIdResponseBody200ServerProtection :: GetServersIdResponseBody200ServerProtection
  -- | public_net: Public network information. The Server\'s IPv4 address can be found in \`public_net->ipv4->ip\`
  , getServersIdResponseBody200ServerPublicNet :: GetServersIdResponseBody200ServerPublicNet
  -- | rescue_enabled: True if rescue mode is enabled. Server will then boot into rescue system on next reboot
  , getServersIdResponseBody200ServerRescueEnabled :: GHC.Types.Bool
  -- | server_type: Type of Server - determines how much ram, disk and cpu a Server has
  , getServersIdResponseBody200ServerServerType :: GetServersIdResponseBody200ServerServerType
  -- | status: Status of the Server
  , getServersIdResponseBody200ServerStatus :: GetServersIdResponseBody200ServerStatus
  -- | volumes: IDs of Volumes assigned to this Server
  , getServersIdResponseBody200ServerVolumes :: (GHC.Maybe.Maybe ([] GHC.Integer.Type.Integer))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200Server
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "backup_window" (getServersIdResponseBody200ServerBackupWindow obj) : (Data.Aeson..=) "created" (getServersIdResponseBody200ServerCreated obj) : (Data.Aeson..=) "datacenter" (getServersIdResponseBody200ServerDatacenter obj) : (Data.Aeson..=) "id" (getServersIdResponseBody200ServerId obj) : (Data.Aeson..=) "image" (getServersIdResponseBody200ServerImage obj) : (Data.Aeson..=) "included_traffic" (getServersIdResponseBody200ServerIncludedTraffic obj) : (Data.Aeson..=) "ingoing_traffic" (getServersIdResponseBody200ServerIngoingTraffic obj) : (Data.Aeson..=) "iso" (getServersIdResponseBody200ServerIso obj) : (Data.Aeson..=) "labels" (getServersIdResponseBody200ServerLabels obj) : (Data.Aeson..=) "load_balancers" (getServersIdResponseBody200ServerLoadBalancers obj) : (Data.Aeson..=) "locked" (getServersIdResponseBody200ServerLocked obj) : (Data.Aeson..=) "name" (getServersIdResponseBody200ServerName obj) : (Data.Aeson..=) "outgoing_traffic" (getServersIdResponseBody200ServerOutgoingTraffic obj) : (Data.Aeson..=) "placement_group" (getServersIdResponseBody200ServerPlacementGroup obj) : (Data.Aeson..=) "primary_disk_size" (getServersIdResponseBody200ServerPrimaryDiskSize obj) : (Data.Aeson..=) "private_net" (getServersIdResponseBody200ServerPrivateNet obj) : (Data.Aeson..=) "protection" (getServersIdResponseBody200ServerProtection obj) : (Data.Aeson..=) "public_net" (getServersIdResponseBody200ServerPublicNet obj) : (Data.Aeson..=) "rescue_enabled" (getServersIdResponseBody200ServerRescueEnabled obj) : (Data.Aeson..=) "server_type" (getServersIdResponseBody200ServerServerType obj) : (Data.Aeson..=) "status" (getServersIdResponseBody200ServerStatus obj) : (Data.Aeson..=) "volumes" (getServersIdResponseBody200ServerVolumes obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "backup_window" (getServersIdResponseBody200ServerBackupWindow obj) GHC.Base.<> ((Data.Aeson..=) "created" (getServersIdResponseBody200ServerCreated obj) GHC.Base.<> ((Data.Aeson..=) "datacenter" (getServersIdResponseBody200ServerDatacenter obj) GHC.Base.<> ((Data.Aeson..=) "id" (getServersIdResponseBody200ServerId obj) GHC.Base.<> ((Data.Aeson..=) "image" (getServersIdResponseBody200ServerImage obj) GHC.Base.<> ((Data.Aeson..=) "included_traffic" (getServersIdResponseBody200ServerIncludedTraffic obj) GHC.Base.<> ((Data.Aeson..=) "ingoing_traffic" (getServersIdResponseBody200ServerIngoingTraffic obj) GHC.Base.<> ((Data.Aeson..=) "iso" (getServersIdResponseBody200ServerIso obj) GHC.Base.<> ((Data.Aeson..=) "labels" (getServersIdResponseBody200ServerLabels obj) GHC.Base.<> ((Data.Aeson..=) "load_balancers" (getServersIdResponseBody200ServerLoadBalancers obj) GHC.Base.<> ((Data.Aeson..=) "locked" (getServersIdResponseBody200ServerLocked obj) GHC.Base.<> ((Data.Aeson..=) "name" (getServersIdResponseBody200ServerName obj) GHC.Base.<> ((Data.Aeson..=) "outgoing_traffic" (getServersIdResponseBody200ServerOutgoingTraffic obj) GHC.Base.<> ((Data.Aeson..=) "placement_group" (getServersIdResponseBody200ServerPlacementGroup obj) GHC.Base.<> ((Data.Aeson..=) "primary_disk_size" (getServersIdResponseBody200ServerPrimaryDiskSize obj) GHC.Base.<> ((Data.Aeson..=) "private_net" (getServersIdResponseBody200ServerPrivateNet obj) GHC.Base.<> ((Data.Aeson..=) "protection" (getServersIdResponseBody200ServerProtection obj) GHC.Base.<> ((Data.Aeson..=) "public_net" (getServersIdResponseBody200ServerPublicNet obj) GHC.Base.<> ((Data.Aeson..=) "rescue_enabled" (getServersIdResponseBody200ServerRescueEnabled obj) GHC.Base.<> ((Data.Aeson..=) "server_type" (getServersIdResponseBody200ServerServerType obj) GHC.Base.<> ((Data.Aeson..=) "status" (getServersIdResponseBody200ServerStatus obj) GHC.Base.<> (Data.Aeson..=) "volumes" (getServersIdResponseBody200ServerVolumes obj))))))))))))))))))))))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200Server
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200Server" (\obj -> (((((((((((((((((((((GHC.Base.pure GetServersIdResponseBody200Server GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "backup_window")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "datacenter")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "image")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "included_traffic")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ingoing_traffic")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "iso")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "labels")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "load_balancers")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "locked")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "outgoing_traffic")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "placement_group")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "primary_disk_size")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "private_net")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "protection")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "public_net")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "rescue_enabled")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "server_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "volumes"))
-- | Defines the data type for the schema GetServersIdResponseBody200ServerDatacenter
-- 
-- Datacenter this Resource is located at
data GetServersIdResponseBody200ServerDatacenter = GetServersIdResponseBody200ServerDatacenter {
  -- | description: Description of the Datacenter
  getServersIdResponseBody200ServerDatacenterDescription :: Data.Text.Internal.Text
  -- | id: ID of the Resource
  , getServersIdResponseBody200ServerDatacenterId :: GHC.Integer.Type.Integer
  -- | location
  , getServersIdResponseBody200ServerDatacenterLocation :: GetServersIdResponseBody200ServerDatacenterLocation
  -- | name: Unique identifier of the Datacenter
  , getServersIdResponseBody200ServerDatacenterName :: Data.Text.Internal.Text
  -- | server_types: The Server types the Datacenter can handle
  , getServersIdResponseBody200ServerDatacenterServerTypes :: GetServersIdResponseBody200ServerDatacenterServerTypes
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerDatacenter
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "description" (getServersIdResponseBody200ServerDatacenterDescription obj) : (Data.Aeson..=) "id" (getServersIdResponseBody200ServerDatacenterId obj) : (Data.Aeson..=) "location" (getServersIdResponseBody200ServerDatacenterLocation obj) : (Data.Aeson..=) "name" (getServersIdResponseBody200ServerDatacenterName obj) : (Data.Aeson..=) "server_types" (getServersIdResponseBody200ServerDatacenterServerTypes obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "description" (getServersIdResponseBody200ServerDatacenterDescription obj) GHC.Base.<> ((Data.Aeson..=) "id" (getServersIdResponseBody200ServerDatacenterId obj) GHC.Base.<> ((Data.Aeson..=) "location" (getServersIdResponseBody200ServerDatacenterLocation obj) GHC.Base.<> ((Data.Aeson..=) "name" (getServersIdResponseBody200ServerDatacenterName obj) GHC.Base.<> (Data.Aeson..=) "server_types" (getServersIdResponseBody200ServerDatacenterServerTypes obj)))))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200ServerDatacenter
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200ServerDatacenter" (\obj -> ((((GHC.Base.pure GetServersIdResponseBody200ServerDatacenter GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "location")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "server_types"))
-- | Defines the data type for the schema GetServersIdResponseBody200ServerDatacenterLocation
-- 
-- 
data GetServersIdResponseBody200ServerDatacenterLocation = GetServersIdResponseBody200ServerDatacenterLocation {
  -- | city: City the Location is closest to
  getServersIdResponseBody200ServerDatacenterLocationCity :: Data.Text.Internal.Text
  -- | country: ISO 3166-1 alpha-2 code of the country the Location resides in
  , getServersIdResponseBody200ServerDatacenterLocationCountry :: Data.Text.Internal.Text
  -- | description: Description of the Location
  , getServersIdResponseBody200ServerDatacenterLocationDescription :: Data.Text.Internal.Text
  -- | id: ID of the Location
  , getServersIdResponseBody200ServerDatacenterLocationId :: GHC.Types.Double
  -- | latitude: Latitude of the city closest to the Location
  , getServersIdResponseBody200ServerDatacenterLocationLatitude :: GHC.Types.Double
  -- | longitude: Longitude of the city closest to the Location
  , getServersIdResponseBody200ServerDatacenterLocationLongitude :: GHC.Types.Double
  -- | name: Unique identifier of the Location
  , getServersIdResponseBody200ServerDatacenterLocationName :: Data.Text.Internal.Text
  -- | network_zone: Name of network zone this Location resides in
  , getServersIdResponseBody200ServerDatacenterLocationNetworkZone :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerDatacenterLocation
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "city" (getServersIdResponseBody200ServerDatacenterLocationCity obj) : (Data.Aeson..=) "country" (getServersIdResponseBody200ServerDatacenterLocationCountry obj) : (Data.Aeson..=) "description" (getServersIdResponseBody200ServerDatacenterLocationDescription obj) : (Data.Aeson..=) "id" (getServersIdResponseBody200ServerDatacenterLocationId obj) : (Data.Aeson..=) "latitude" (getServersIdResponseBody200ServerDatacenterLocationLatitude obj) : (Data.Aeson..=) "longitude" (getServersIdResponseBody200ServerDatacenterLocationLongitude obj) : (Data.Aeson..=) "name" (getServersIdResponseBody200ServerDatacenterLocationName obj) : (Data.Aeson..=) "network_zone" (getServersIdResponseBody200ServerDatacenterLocationNetworkZone obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "city" (getServersIdResponseBody200ServerDatacenterLocationCity obj) GHC.Base.<> ((Data.Aeson..=) "country" (getServersIdResponseBody200ServerDatacenterLocationCountry obj) GHC.Base.<> ((Data.Aeson..=) "description" (getServersIdResponseBody200ServerDatacenterLocationDescription obj) GHC.Base.<> ((Data.Aeson..=) "id" (getServersIdResponseBody200ServerDatacenterLocationId obj) GHC.Base.<> ((Data.Aeson..=) "latitude" (getServersIdResponseBody200ServerDatacenterLocationLatitude obj) GHC.Base.<> ((Data.Aeson..=) "longitude" (getServersIdResponseBody200ServerDatacenterLocationLongitude obj) GHC.Base.<> ((Data.Aeson..=) "name" (getServersIdResponseBody200ServerDatacenterLocationName obj) GHC.Base.<> (Data.Aeson..=) "network_zone" (getServersIdResponseBody200ServerDatacenterLocationNetworkZone obj))))))))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200ServerDatacenterLocation
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200ServerDatacenterLocation" (\obj -> (((((((GHC.Base.pure GetServersIdResponseBody200ServerDatacenterLocation GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "city")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "country")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "latitude")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "longitude")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "network_zone"))
-- | Defines the data type for the schema GetServersIdResponseBody200ServerDatacenterServer_types
-- 
-- The Server types the Datacenter can handle
data GetServersIdResponseBody200ServerDatacenterServerTypes = GetServersIdResponseBody200ServerDatacenterServerTypes {
  -- | available: IDs of Server types that are supported and for which the Datacenter has enough resources left
  getServersIdResponseBody200ServerDatacenterServerTypesAvailable :: ([] GHC.Types.Double)
  -- | available_for_migration: IDs of Server types that are supported and for which the Datacenter has enough resources left
  , getServersIdResponseBody200ServerDatacenterServerTypesAvailableForMigration :: ([] GHC.Types.Double)
  -- | supported: IDs of Server types that are supported in the Datacenter
  , getServersIdResponseBody200ServerDatacenterServerTypesSupported :: ([] GHC.Types.Double)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerDatacenterServerTypes
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "available" (getServersIdResponseBody200ServerDatacenterServerTypesAvailable obj) : (Data.Aeson..=) "available_for_migration" (getServersIdResponseBody200ServerDatacenterServerTypesAvailableForMigration obj) : (Data.Aeson..=) "supported" (getServersIdResponseBody200ServerDatacenterServerTypesSupported obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "available" (getServersIdResponseBody200ServerDatacenterServerTypesAvailable obj) GHC.Base.<> ((Data.Aeson..=) "available_for_migration" (getServersIdResponseBody200ServerDatacenterServerTypesAvailableForMigration obj) GHC.Base.<> (Data.Aeson..=) "supported" (getServersIdResponseBody200ServerDatacenterServerTypesSupported obj)))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200ServerDatacenterServerTypes
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200ServerDatacenterServerTypes" (\obj -> ((GHC.Base.pure GetServersIdResponseBody200ServerDatacenterServerTypes GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "available")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "available_for_migration")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "supported"))
-- | Defines the data type for the schema GetServersIdResponseBody200ServerImage
-- 
-- 
data GetServersIdResponseBody200ServerImage = GetServersIdResponseBody200ServerImage {
  -- | bound_to: ID of Server the Image is bound to. Only set for Images of type \`backup\`.
  getServersIdResponseBody200ServerImageBoundTo :: GHC.Integer.Type.Integer
  -- | build_id: Build ID of the Image
  , getServersIdResponseBody200ServerImageBuildId :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | created: Point in time when the Resource was created (in ISO-8601 format)
  , getServersIdResponseBody200ServerImageCreated :: Data.Text.Internal.Text
  -- | created_from: Information about the Server the Image was created from
  , getServersIdResponseBody200ServerImageCreatedFrom :: GetServersIdResponseBody200ServerImageCreatedFrom
  -- | deleted: Point in time where the Image was deleted (in ISO-8601 format)
  , getServersIdResponseBody200ServerImageDeleted :: Data.Text.Internal.Text
  -- | deprecated: Point in time when the Image is considered to be deprecated (in ISO-8601 format)
  , getServersIdResponseBody200ServerImageDeprecated :: Data.Text.Internal.Text
  -- | description: Description of the Image
  , getServersIdResponseBody200ServerImageDescription :: Data.Text.Internal.Text
  -- | disk_size: Size of the disk contained in the Image in GB
  , getServersIdResponseBody200ServerImageDiskSize :: GHC.Types.Double
  -- | id: ID of the Resource
  , getServersIdResponseBody200ServerImageId :: GHC.Integer.Type.Integer
  -- | image_size: Size of the Image file in our storage in GB. For snapshot Images this is the value relevant for calculating costs for the Image.
  , getServersIdResponseBody200ServerImageImageSize :: GHC.Types.Double
  -- | labels: User-defined labels (key-value pairs)
  , getServersIdResponseBody200ServerImageLabels :: GetServersIdResponseBody200ServerImageLabels
  -- | name: Unique identifier of the Image. This value is only set for system Images.
  , getServersIdResponseBody200ServerImageName :: Data.Text.Internal.Text
  -- | os_flavor: Flavor of operating system contained in the Image
  , getServersIdResponseBody200ServerImageOsFlavor :: GetServersIdResponseBody200ServerImageOsFlavor
  -- | os_version: Operating system version
  , getServersIdResponseBody200ServerImageOsVersion :: Data.Text.Internal.Text
  -- | protection: Protection configuration for the Resource
  , getServersIdResponseBody200ServerImageProtection :: GetServersIdResponseBody200ServerImageProtection
  -- | rapid_deploy: Indicates that rapid deploy of the Image is available
  , getServersIdResponseBody200ServerImageRapidDeploy :: (GHC.Maybe.Maybe GHC.Types.Bool)
  -- | status: Whether the Image can be used or if it\'s still being created or unavailable
  , getServersIdResponseBody200ServerImageStatus :: GetServersIdResponseBody200ServerImageStatus
  -- | type: Type of the Image
  , getServersIdResponseBody200ServerImageType :: GetServersIdResponseBody200ServerImageType
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerImage
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "bound_to" (getServersIdResponseBody200ServerImageBoundTo obj) : (Data.Aeson..=) "build_id" (getServersIdResponseBody200ServerImageBuildId obj) : (Data.Aeson..=) "created" (getServersIdResponseBody200ServerImageCreated obj) : (Data.Aeson..=) "created_from" (getServersIdResponseBody200ServerImageCreatedFrom obj) : (Data.Aeson..=) "deleted" (getServersIdResponseBody200ServerImageDeleted obj) : (Data.Aeson..=) "deprecated" (getServersIdResponseBody200ServerImageDeprecated obj) : (Data.Aeson..=) "description" (getServersIdResponseBody200ServerImageDescription obj) : (Data.Aeson..=) "disk_size" (getServersIdResponseBody200ServerImageDiskSize obj) : (Data.Aeson..=) "id" (getServersIdResponseBody200ServerImageId obj) : (Data.Aeson..=) "image_size" (getServersIdResponseBody200ServerImageImageSize obj) : (Data.Aeson..=) "labels" (getServersIdResponseBody200ServerImageLabels obj) : (Data.Aeson..=) "name" (getServersIdResponseBody200ServerImageName obj) : (Data.Aeson..=) "os_flavor" (getServersIdResponseBody200ServerImageOsFlavor obj) : (Data.Aeson..=) "os_version" (getServersIdResponseBody200ServerImageOsVersion obj) : (Data.Aeson..=) "protection" (getServersIdResponseBody200ServerImageProtection obj) : (Data.Aeson..=) "rapid_deploy" (getServersIdResponseBody200ServerImageRapidDeploy obj) : (Data.Aeson..=) "status" (getServersIdResponseBody200ServerImageStatus obj) : (Data.Aeson..=) "type" (getServersIdResponseBody200ServerImageType obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "bound_to" (getServersIdResponseBody200ServerImageBoundTo obj) GHC.Base.<> ((Data.Aeson..=) "build_id" (getServersIdResponseBody200ServerImageBuildId obj) GHC.Base.<> ((Data.Aeson..=) "created" (getServersIdResponseBody200ServerImageCreated obj) GHC.Base.<> ((Data.Aeson..=) "created_from" (getServersIdResponseBody200ServerImageCreatedFrom obj) GHC.Base.<> ((Data.Aeson..=) "deleted" (getServersIdResponseBody200ServerImageDeleted obj) GHC.Base.<> ((Data.Aeson..=) "deprecated" (getServersIdResponseBody200ServerImageDeprecated obj) GHC.Base.<> ((Data.Aeson..=) "description" (getServersIdResponseBody200ServerImageDescription obj) GHC.Base.<> ((Data.Aeson..=) "disk_size" (getServersIdResponseBody200ServerImageDiskSize obj) GHC.Base.<> ((Data.Aeson..=) "id" (getServersIdResponseBody200ServerImageId obj) GHC.Base.<> ((Data.Aeson..=) "image_size" (getServersIdResponseBody200ServerImageImageSize obj) GHC.Base.<> ((Data.Aeson..=) "labels" (getServersIdResponseBody200ServerImageLabels obj) GHC.Base.<> ((Data.Aeson..=) "name" (getServersIdResponseBody200ServerImageName obj) GHC.Base.<> ((Data.Aeson..=) "os_flavor" (getServersIdResponseBody200ServerImageOsFlavor obj) GHC.Base.<> ((Data.Aeson..=) "os_version" (getServersIdResponseBody200ServerImageOsVersion obj) GHC.Base.<> ((Data.Aeson..=) "protection" (getServersIdResponseBody200ServerImageProtection obj) GHC.Base.<> ((Data.Aeson..=) "rapid_deploy" (getServersIdResponseBody200ServerImageRapidDeploy obj) GHC.Base.<> ((Data.Aeson..=) "status" (getServersIdResponseBody200ServerImageStatus obj) GHC.Base.<> (Data.Aeson..=) "type" (getServersIdResponseBody200ServerImageType obj))))))))))))))))))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200ServerImage
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200ServerImage" (\obj -> (((((((((((((((((GHC.Base.pure GetServersIdResponseBody200ServerImage GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "bound_to")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "build_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created_from")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deleted")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deprecated")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "disk_size")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "image_size")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "labels")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "os_flavor")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "os_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "protection")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "rapid_deploy")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "type"))
-- | Defines the data type for the schema GetServersIdResponseBody200ServerImageCreated_from
-- 
-- Information about the Server the Image was created from
data GetServersIdResponseBody200ServerImageCreatedFrom = GetServersIdResponseBody200ServerImageCreatedFrom {
  -- | id: ID of the Server the Image was created from
  getServersIdResponseBody200ServerImageCreatedFromId :: GHC.Integer.Type.Integer
  -- | name: Server name at the time the Image was created
  , getServersIdResponseBody200ServerImageCreatedFromName :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerImageCreatedFrom
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "id" (getServersIdResponseBody200ServerImageCreatedFromId obj) : (Data.Aeson..=) "name" (getServersIdResponseBody200ServerImageCreatedFromName obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "id" (getServersIdResponseBody200ServerImageCreatedFromId obj) GHC.Base.<> (Data.Aeson..=) "name" (getServersIdResponseBody200ServerImageCreatedFromName obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200ServerImageCreatedFrom
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200ServerImageCreatedFrom" (\obj -> (GHC.Base.pure GetServersIdResponseBody200ServerImageCreatedFrom GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name"))
-- | Defines the data type for the schema GetServersIdResponseBody200ServerImageLabels
-- 
-- User-defined labels (key-value pairs)
data GetServersIdResponseBody200ServerImageLabels = GetServersIdResponseBody200ServerImageLabels {
  
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerImageLabels
    where toJSON obj = Data.Aeson.object []
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "string" ("string" :: GHC.Base.String))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200ServerImageLabels
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200ServerImageLabels" (\obj -> GHC.Base.pure GetServersIdResponseBody200ServerImageLabels)
-- | Defines the enum schema GetServersIdResponseBody200ServerImageOs_flavor
-- 
-- Flavor of operating system contained in the Image
data GetServersIdResponseBody200ServerImageOsFlavor
    = GetServersIdResponseBody200ServerImageOsFlavorEnumOther Data.Aeson.Types.Internal.Value
    | GetServersIdResponseBody200ServerImageOsFlavorEnumTyped Data.Text.Internal.Text
    | GetServersIdResponseBody200ServerImageOsFlavorEnumStringCentos
    | GetServersIdResponseBody200ServerImageOsFlavorEnumStringDebian
    | GetServersIdResponseBody200ServerImageOsFlavorEnumStringFedora
    | GetServersIdResponseBody200ServerImageOsFlavorEnumStringUbuntu
    | GetServersIdResponseBody200ServerImageOsFlavorEnumStringUnknown
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerImageOsFlavor
    where toJSON (GetServersIdResponseBody200ServerImageOsFlavorEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersIdResponseBody200ServerImageOsFlavorEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersIdResponseBody200ServerImageOsFlavorEnumStringCentos) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "centos"
          toJSON (GetServersIdResponseBody200ServerImageOsFlavorEnumStringDebian) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "debian"
          toJSON (GetServersIdResponseBody200ServerImageOsFlavorEnumStringFedora) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "fedora"
          toJSON (GetServersIdResponseBody200ServerImageOsFlavorEnumStringUbuntu) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "ubuntu"
          toJSON (GetServersIdResponseBody200ServerImageOsFlavorEnumStringUnknown) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "unknown"
instance Data.Aeson.FromJSON GetServersIdResponseBody200ServerImageOsFlavor
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "centos")
                                          then GetServersIdResponseBody200ServerImageOsFlavorEnumStringCentos
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "debian")
                                                then GetServersIdResponseBody200ServerImageOsFlavorEnumStringDebian
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "fedora")
                                                      then GetServersIdResponseBody200ServerImageOsFlavorEnumStringFedora
                                                      else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "ubuntu")
                                                            then GetServersIdResponseBody200ServerImageOsFlavorEnumStringUbuntu
                                                            else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "unknown")
                                                                  then GetServersIdResponseBody200ServerImageOsFlavorEnumStringUnknown
                                                                  else GetServersIdResponseBody200ServerImageOsFlavorEnumOther val)
-- | Defines the data type for the schema GetServersIdResponseBody200ServerImageProtection
-- 
-- Protection configuration for the Resource
data GetServersIdResponseBody200ServerImageProtection = GetServersIdResponseBody200ServerImageProtection {
  -- | delete: If true, prevents the Resource from being deleted
  getServersIdResponseBody200ServerImageProtectionDelete :: GHC.Types.Bool
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerImageProtection
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "delete" (getServersIdResponseBody200ServerImageProtectionDelete obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "delete" (getServersIdResponseBody200ServerImageProtectionDelete obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200ServerImageProtection
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200ServerImageProtection" (\obj -> GHC.Base.pure GetServersIdResponseBody200ServerImageProtection GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "delete"))
-- | Defines the enum schema GetServersIdResponseBody200ServerImageStatus
-- 
-- Whether the Image can be used or if it\'s still being created or unavailable
data GetServersIdResponseBody200ServerImageStatus
    = GetServersIdResponseBody200ServerImageStatusEnumOther Data.Aeson.Types.Internal.Value
    | GetServersIdResponseBody200ServerImageStatusEnumTyped Data.Text.Internal.Text
    | GetServersIdResponseBody200ServerImageStatusEnumStringAvailable
    | GetServersIdResponseBody200ServerImageStatusEnumStringCreating
    | GetServersIdResponseBody200ServerImageStatusEnumStringUnavailable
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerImageStatus
    where toJSON (GetServersIdResponseBody200ServerImageStatusEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersIdResponseBody200ServerImageStatusEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersIdResponseBody200ServerImageStatusEnumStringAvailable) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "available"
          toJSON (GetServersIdResponseBody200ServerImageStatusEnumStringCreating) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "creating"
          toJSON (GetServersIdResponseBody200ServerImageStatusEnumStringUnavailable) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "unavailable"
instance Data.Aeson.FromJSON GetServersIdResponseBody200ServerImageStatus
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "available")
                                          then GetServersIdResponseBody200ServerImageStatusEnumStringAvailable
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "creating")
                                                then GetServersIdResponseBody200ServerImageStatusEnumStringCreating
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "unavailable")
                                                      then GetServersIdResponseBody200ServerImageStatusEnumStringUnavailable
                                                      else GetServersIdResponseBody200ServerImageStatusEnumOther val)
-- | Defines the enum schema GetServersIdResponseBody200ServerImageType
-- 
-- Type of the Image
data GetServersIdResponseBody200ServerImageType
    = GetServersIdResponseBody200ServerImageTypeEnumOther Data.Aeson.Types.Internal.Value
    | GetServersIdResponseBody200ServerImageTypeEnumTyped Data.Text.Internal.Text
    | GetServersIdResponseBody200ServerImageTypeEnumStringApp
    | GetServersIdResponseBody200ServerImageTypeEnumStringBackup
    | GetServersIdResponseBody200ServerImageTypeEnumStringSnapshot
    | GetServersIdResponseBody200ServerImageTypeEnumStringSystem
    | GetServersIdResponseBody200ServerImageTypeEnumStringTemporary
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerImageType
    where toJSON (GetServersIdResponseBody200ServerImageTypeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersIdResponseBody200ServerImageTypeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersIdResponseBody200ServerImageTypeEnumStringApp) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "app"
          toJSON (GetServersIdResponseBody200ServerImageTypeEnumStringBackup) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "backup"
          toJSON (GetServersIdResponseBody200ServerImageTypeEnumStringSnapshot) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "snapshot"
          toJSON (GetServersIdResponseBody200ServerImageTypeEnumStringSystem) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "system"
          toJSON (GetServersIdResponseBody200ServerImageTypeEnumStringTemporary) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "temporary"
instance Data.Aeson.FromJSON GetServersIdResponseBody200ServerImageType
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "app")
                                          then GetServersIdResponseBody200ServerImageTypeEnumStringApp
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "backup")
                                                then GetServersIdResponseBody200ServerImageTypeEnumStringBackup
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "snapshot")
                                                      then GetServersIdResponseBody200ServerImageTypeEnumStringSnapshot
                                                      else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "system")
                                                            then GetServersIdResponseBody200ServerImageTypeEnumStringSystem
                                                            else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "temporary")
                                                                  then GetServersIdResponseBody200ServerImageTypeEnumStringTemporary
                                                                  else GetServersIdResponseBody200ServerImageTypeEnumOther val)
-- | Defines the data type for the schema GetServersIdResponseBody200ServerIso
-- 
-- ISO Image that is attached to this Server. Null if no ISO is attached.
data GetServersIdResponseBody200ServerIso = GetServersIdResponseBody200ServerIso {
  -- | deprecated: ISO 8601 timestamp of deprecation, null if ISO is still available. After the deprecation time it will no longer be possible to attach the ISO to Servers.
  getServersIdResponseBody200ServerIsoDeprecated :: Data.Text.Internal.Text
  -- | description: Description of the ISO
  , getServersIdResponseBody200ServerIsoDescription :: Data.Text.Internal.Text
  -- | id: ID of the Resource
  , getServersIdResponseBody200ServerIsoId :: GHC.Integer.Type.Integer
  -- | name: Unique identifier of the ISO. Only set for public ISOs
  , getServersIdResponseBody200ServerIsoName :: Data.Text.Internal.Text
  -- | type: Type of the ISO
  , getServersIdResponseBody200ServerIsoType :: GetServersIdResponseBody200ServerIsoType
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerIso
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "deprecated" (getServersIdResponseBody200ServerIsoDeprecated obj) : (Data.Aeson..=) "description" (getServersIdResponseBody200ServerIsoDescription obj) : (Data.Aeson..=) "id" (getServersIdResponseBody200ServerIsoId obj) : (Data.Aeson..=) "name" (getServersIdResponseBody200ServerIsoName obj) : (Data.Aeson..=) "type" (getServersIdResponseBody200ServerIsoType obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "deprecated" (getServersIdResponseBody200ServerIsoDeprecated obj) GHC.Base.<> ((Data.Aeson..=) "description" (getServersIdResponseBody200ServerIsoDescription obj) GHC.Base.<> ((Data.Aeson..=) "id" (getServersIdResponseBody200ServerIsoId obj) GHC.Base.<> ((Data.Aeson..=) "name" (getServersIdResponseBody200ServerIsoName obj) GHC.Base.<> (Data.Aeson..=) "type" (getServersIdResponseBody200ServerIsoType obj)))))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200ServerIso
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200ServerIso" (\obj -> ((((GHC.Base.pure GetServersIdResponseBody200ServerIso GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deprecated")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "type"))
-- | Defines the enum schema GetServersIdResponseBody200ServerIsoType
-- 
-- Type of the ISO
data GetServersIdResponseBody200ServerIsoType
    = GetServersIdResponseBody200ServerIsoTypeEnumOther Data.Aeson.Types.Internal.Value
    | GetServersIdResponseBody200ServerIsoTypeEnumTyped Data.Text.Internal.Text
    | GetServersIdResponseBody200ServerIsoTypeEnumStringPrivate
    | GetServersIdResponseBody200ServerIsoTypeEnumStringPublic
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerIsoType
    where toJSON (GetServersIdResponseBody200ServerIsoTypeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersIdResponseBody200ServerIsoTypeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersIdResponseBody200ServerIsoTypeEnumStringPrivate) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "private"
          toJSON (GetServersIdResponseBody200ServerIsoTypeEnumStringPublic) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "public"
instance Data.Aeson.FromJSON GetServersIdResponseBody200ServerIsoType
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "private")
                                          then GetServersIdResponseBody200ServerIsoTypeEnumStringPrivate
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "public")
                                                then GetServersIdResponseBody200ServerIsoTypeEnumStringPublic
                                                else GetServersIdResponseBody200ServerIsoTypeEnumOther val)
-- | Defines the data type for the schema GetServersIdResponseBody200ServerLabels
-- 
-- User-defined labels (key-value pairs)
data GetServersIdResponseBody200ServerLabels = GetServersIdResponseBody200ServerLabels {
  
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerLabels
    where toJSON obj = Data.Aeson.object []
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "string" ("string" :: GHC.Base.String))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200ServerLabels
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200ServerLabels" (\obj -> GHC.Base.pure GetServersIdResponseBody200ServerLabels)
-- | Defines the data type for the schema GetServersIdResponseBody200ServerPlacement_group
-- 
-- 
data GetServersIdResponseBody200ServerPlacementGroup = GetServersIdResponseBody200ServerPlacementGroup {
  -- | created: Point in time when the Resource was created (in ISO-8601 format)
  getServersIdResponseBody200ServerPlacementGroupCreated :: Data.Text.Internal.Text
  -- | id: ID of the Resource
  , getServersIdResponseBody200ServerPlacementGroupId :: GHC.Integer.Type.Integer
  -- | labels: User-defined labels (key-value pairs)
  , getServersIdResponseBody200ServerPlacementGroupLabels :: GetServersIdResponseBody200ServerPlacementGroupLabels
  -- | name: Name of the Resource. Must be unique per Project.
  , getServersIdResponseBody200ServerPlacementGroupName :: Data.Text.Internal.Text
  -- | servers: Array of IDs of Servers that are part of this Placement Group
  , getServersIdResponseBody200ServerPlacementGroupServers :: ([] GHC.Integer.Type.Integer)
  -- | type: Type of the Placement Group
  , getServersIdResponseBody200ServerPlacementGroupType :: GetServersIdResponseBody200ServerPlacementGroupType
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerPlacementGroup
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "created" (getServersIdResponseBody200ServerPlacementGroupCreated obj) : (Data.Aeson..=) "id" (getServersIdResponseBody200ServerPlacementGroupId obj) : (Data.Aeson..=) "labels" (getServersIdResponseBody200ServerPlacementGroupLabels obj) : (Data.Aeson..=) "name" (getServersIdResponseBody200ServerPlacementGroupName obj) : (Data.Aeson..=) "servers" (getServersIdResponseBody200ServerPlacementGroupServers obj) : (Data.Aeson..=) "type" (getServersIdResponseBody200ServerPlacementGroupType obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "created" (getServersIdResponseBody200ServerPlacementGroupCreated obj) GHC.Base.<> ((Data.Aeson..=) "id" (getServersIdResponseBody200ServerPlacementGroupId obj) GHC.Base.<> ((Data.Aeson..=) "labels" (getServersIdResponseBody200ServerPlacementGroupLabels obj) GHC.Base.<> ((Data.Aeson..=) "name" (getServersIdResponseBody200ServerPlacementGroupName obj) GHC.Base.<> ((Data.Aeson..=) "servers" (getServersIdResponseBody200ServerPlacementGroupServers obj) GHC.Base.<> (Data.Aeson..=) "type" (getServersIdResponseBody200ServerPlacementGroupType obj))))))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200ServerPlacementGroup
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200ServerPlacementGroup" (\obj -> (((((GHC.Base.pure GetServersIdResponseBody200ServerPlacementGroup GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "labels")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "servers")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "type"))
-- | Defines the data type for the schema GetServersIdResponseBody200ServerPlacement_groupLabels
-- 
-- User-defined labels (key-value pairs)
data GetServersIdResponseBody200ServerPlacementGroupLabels = GetServersIdResponseBody200ServerPlacementGroupLabels {
  
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerPlacementGroupLabels
    where toJSON obj = Data.Aeson.object []
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "string" ("string" :: GHC.Base.String))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200ServerPlacementGroupLabels
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200ServerPlacementGroupLabels" (\obj -> GHC.Base.pure GetServersIdResponseBody200ServerPlacementGroupLabels)
-- | Defines the enum schema GetServersIdResponseBody200ServerPlacement_groupType
-- 
-- Type of the Placement Group
data GetServersIdResponseBody200ServerPlacementGroupType
    = GetServersIdResponseBody200ServerPlacementGroupTypeEnumOther Data.Aeson.Types.Internal.Value
    | GetServersIdResponseBody200ServerPlacementGroupTypeEnumTyped Data.Text.Internal.Text
    | GetServersIdResponseBody200ServerPlacementGroupTypeEnumStringSpread
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerPlacementGroupType
    where toJSON (GetServersIdResponseBody200ServerPlacementGroupTypeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersIdResponseBody200ServerPlacementGroupTypeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersIdResponseBody200ServerPlacementGroupTypeEnumStringSpread) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "spread"
instance Data.Aeson.FromJSON GetServersIdResponseBody200ServerPlacementGroupType
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "spread")
                                          then GetServersIdResponseBody200ServerPlacementGroupTypeEnumStringSpread
                                          else GetServersIdResponseBody200ServerPlacementGroupTypeEnumOther val)
-- | Defines the data type for the schema GetServersIdResponseBody200ServerPrivate_net
-- 
-- 
data GetServersIdResponseBody200ServerPrivateNet = GetServersIdResponseBody200ServerPrivateNet {
  -- | alias_ips
  getServersIdResponseBody200ServerPrivateNetAliasIps :: (GHC.Maybe.Maybe ([] Data.Text.Internal.Text))
  -- | ip
  , getServersIdResponseBody200ServerPrivateNetIp :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | mac_address
  , getServersIdResponseBody200ServerPrivateNetMacAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | network
  , getServersIdResponseBody200ServerPrivateNetNetwork :: (GHC.Maybe.Maybe GHC.Integer.Type.Integer)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerPrivateNet
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "alias_ips" (getServersIdResponseBody200ServerPrivateNetAliasIps obj) : (Data.Aeson..=) "ip" (getServersIdResponseBody200ServerPrivateNetIp obj) : (Data.Aeson..=) "mac_address" (getServersIdResponseBody200ServerPrivateNetMacAddress obj) : (Data.Aeson..=) "network" (getServersIdResponseBody200ServerPrivateNetNetwork obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "alias_ips" (getServersIdResponseBody200ServerPrivateNetAliasIps obj) GHC.Base.<> ((Data.Aeson..=) "ip" (getServersIdResponseBody200ServerPrivateNetIp obj) GHC.Base.<> ((Data.Aeson..=) "mac_address" (getServersIdResponseBody200ServerPrivateNetMacAddress obj) GHC.Base.<> (Data.Aeson..=) "network" (getServersIdResponseBody200ServerPrivateNetNetwork obj))))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200ServerPrivateNet
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200ServerPrivateNet" (\obj -> (((GHC.Base.pure GetServersIdResponseBody200ServerPrivateNet GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "alias_ips")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "ip")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "mac_address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "network"))
-- | Defines the data type for the schema GetServersIdResponseBody200ServerProtection
-- 
-- Protection configuration for the Server
data GetServersIdResponseBody200ServerProtection = GetServersIdResponseBody200ServerProtection {
  -- | delete: If true, prevents the Server from being deleted
  getServersIdResponseBody200ServerProtectionDelete :: GHC.Types.Bool
  -- | rebuild: If true, prevents the Server from being rebuilt
  , getServersIdResponseBody200ServerProtectionRebuild :: GHC.Types.Bool
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerProtection
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "delete" (getServersIdResponseBody200ServerProtectionDelete obj) : (Data.Aeson..=) "rebuild" (getServersIdResponseBody200ServerProtectionRebuild obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "delete" (getServersIdResponseBody200ServerProtectionDelete obj) GHC.Base.<> (Data.Aeson..=) "rebuild" (getServersIdResponseBody200ServerProtectionRebuild obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200ServerProtection
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200ServerProtection" (\obj -> (GHC.Base.pure GetServersIdResponseBody200ServerProtection GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "delete")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "rebuild"))
-- | Defines the data type for the schema GetServersIdResponseBody200ServerPublic_net
-- 
-- Public network information. The Server\'s IPv4 address can be found in \`public_net->ipv4->ip\`
data GetServersIdResponseBody200ServerPublicNet = GetServersIdResponseBody200ServerPublicNet {
  -- | firewalls: Firewalls applied to the public network interface of this Server
  getServersIdResponseBody200ServerPublicNetFirewalls :: (GHC.Maybe.Maybe ([] GetServersIdResponseBody200ServerPublicNetFirewalls))
  -- | floating_ips: IDs of Floating IPs assigned to this Server
  , getServersIdResponseBody200ServerPublicNetFloatingIps :: ([] GHC.Integer.Type.Integer)
  -- | ipv4: IP address (v4) and its reverse DNS entry of this Server
  , getServersIdResponseBody200ServerPublicNetIpv4 :: GetServersIdResponseBody200ServerPublicNetIpv4
  -- | ipv6: IPv6 network assigned to this Server and its reverse DNS entry
  , getServersIdResponseBody200ServerPublicNetIpv6 :: GetServersIdResponseBody200ServerPublicNetIpv6
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerPublicNet
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "firewalls" (getServersIdResponseBody200ServerPublicNetFirewalls obj) : (Data.Aeson..=) "floating_ips" (getServersIdResponseBody200ServerPublicNetFloatingIps obj) : (Data.Aeson..=) "ipv4" (getServersIdResponseBody200ServerPublicNetIpv4 obj) : (Data.Aeson..=) "ipv6" (getServersIdResponseBody200ServerPublicNetIpv6 obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "firewalls" (getServersIdResponseBody200ServerPublicNetFirewalls obj) GHC.Base.<> ((Data.Aeson..=) "floating_ips" (getServersIdResponseBody200ServerPublicNetFloatingIps obj) GHC.Base.<> ((Data.Aeson..=) "ipv4" (getServersIdResponseBody200ServerPublicNetIpv4 obj) GHC.Base.<> (Data.Aeson..=) "ipv6" (getServersIdResponseBody200ServerPublicNetIpv6 obj))))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200ServerPublicNet
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200ServerPublicNet" (\obj -> (((GHC.Base.pure GetServersIdResponseBody200ServerPublicNet GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "firewalls")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "floating_ips")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ipv4")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ipv6"))
-- | Defines the data type for the schema GetServersIdResponseBody200ServerPublic_netFirewalls
-- 
-- 
data GetServersIdResponseBody200ServerPublicNetFirewalls = GetServersIdResponseBody200ServerPublicNetFirewalls {
  -- | id: ID of the Resource
  getServersIdResponseBody200ServerPublicNetFirewallsId :: (GHC.Maybe.Maybe GHC.Integer.Type.Integer)
  -- | status: Status of the Firewall on the Server
  , getServersIdResponseBody200ServerPublicNetFirewallsStatus :: (GHC.Maybe.Maybe GetServersIdResponseBody200ServerPublicNetFirewallsStatus)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerPublicNetFirewalls
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "id" (getServersIdResponseBody200ServerPublicNetFirewallsId obj) : (Data.Aeson..=) "status" (getServersIdResponseBody200ServerPublicNetFirewallsStatus obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "id" (getServersIdResponseBody200ServerPublicNetFirewallsId obj) GHC.Base.<> (Data.Aeson..=) "status" (getServersIdResponseBody200ServerPublicNetFirewallsStatus obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200ServerPublicNetFirewalls
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200ServerPublicNetFirewalls" (\obj -> (GHC.Base.pure GetServersIdResponseBody200ServerPublicNetFirewalls GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "status"))
-- | Defines the enum schema GetServersIdResponseBody200ServerPublic_netFirewallsStatus
-- 
-- Status of the Firewall on the Server
data GetServersIdResponseBody200ServerPublicNetFirewallsStatus
    = GetServersIdResponseBody200ServerPublicNetFirewallsStatusEnumOther Data.Aeson.Types.Internal.Value
    | GetServersIdResponseBody200ServerPublicNetFirewallsStatusEnumTyped Data.Text.Internal.Text
    | GetServersIdResponseBody200ServerPublicNetFirewallsStatusEnumStringApplied
    | GetServersIdResponseBody200ServerPublicNetFirewallsStatusEnumStringPending
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerPublicNetFirewallsStatus
    where toJSON (GetServersIdResponseBody200ServerPublicNetFirewallsStatusEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersIdResponseBody200ServerPublicNetFirewallsStatusEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersIdResponseBody200ServerPublicNetFirewallsStatusEnumStringApplied) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "applied"
          toJSON (GetServersIdResponseBody200ServerPublicNetFirewallsStatusEnumStringPending) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "pending"
instance Data.Aeson.FromJSON GetServersIdResponseBody200ServerPublicNetFirewallsStatus
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "applied")
                                          then GetServersIdResponseBody200ServerPublicNetFirewallsStatusEnumStringApplied
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "pending")
                                                then GetServersIdResponseBody200ServerPublicNetFirewallsStatusEnumStringPending
                                                else GetServersIdResponseBody200ServerPublicNetFirewallsStatusEnumOther val)
-- | Defines the data type for the schema GetServersIdResponseBody200ServerPublic_netIpv4
-- 
-- IP address (v4) and its reverse DNS entry of this Server
data GetServersIdResponseBody200ServerPublicNetIpv4 = GetServersIdResponseBody200ServerPublicNetIpv4 {
  -- | blocked: If the IP is blocked by our anti abuse dept
  getServersIdResponseBody200ServerPublicNetIpv4Blocked :: GHC.Types.Bool
  -- | dns_ptr: Reverse DNS PTR entry for the IPv4 addresses of this Server
  , getServersIdResponseBody200ServerPublicNetIpv4DnsPtr :: Data.Text.Internal.Text
  -- | ip: IP address (v4) of this Server
  , getServersIdResponseBody200ServerPublicNetIpv4Ip :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerPublicNetIpv4
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "blocked" (getServersIdResponseBody200ServerPublicNetIpv4Blocked obj) : (Data.Aeson..=) "dns_ptr" (getServersIdResponseBody200ServerPublicNetIpv4DnsPtr obj) : (Data.Aeson..=) "ip" (getServersIdResponseBody200ServerPublicNetIpv4Ip obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "blocked" (getServersIdResponseBody200ServerPublicNetIpv4Blocked obj) GHC.Base.<> ((Data.Aeson..=) "dns_ptr" (getServersIdResponseBody200ServerPublicNetIpv4DnsPtr obj) GHC.Base.<> (Data.Aeson..=) "ip" (getServersIdResponseBody200ServerPublicNetIpv4Ip obj)))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200ServerPublicNetIpv4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200ServerPublicNetIpv4" (\obj -> ((GHC.Base.pure GetServersIdResponseBody200ServerPublicNetIpv4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "blocked")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "dns_ptr")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ip"))
-- | Defines the data type for the schema GetServersIdResponseBody200ServerPublic_netIpv6
-- 
-- IPv6 network assigned to this Server and its reverse DNS entry
data GetServersIdResponseBody200ServerPublicNetIpv6 = GetServersIdResponseBody200ServerPublicNetIpv6 {
  -- | blocked: If the IP is blocked by our anti abuse dept
  getServersIdResponseBody200ServerPublicNetIpv6Blocked :: GHC.Types.Bool
  -- | dns_ptr: Reverse DNS PTR entries for the IPv6 addresses of this Server, \`null\` by default
  , getServersIdResponseBody200ServerPublicNetIpv6DnsPtr :: ([] GetServersIdResponseBody200ServerPublicNetIpv6DnsPtr)
  -- | ip: IP address (v4) of this Server
  , getServersIdResponseBody200ServerPublicNetIpv6Ip :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerPublicNetIpv6
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "blocked" (getServersIdResponseBody200ServerPublicNetIpv6Blocked obj) : (Data.Aeson..=) "dns_ptr" (getServersIdResponseBody200ServerPublicNetIpv6DnsPtr obj) : (Data.Aeson..=) "ip" (getServersIdResponseBody200ServerPublicNetIpv6Ip obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "blocked" (getServersIdResponseBody200ServerPublicNetIpv6Blocked obj) GHC.Base.<> ((Data.Aeson..=) "dns_ptr" (getServersIdResponseBody200ServerPublicNetIpv6DnsPtr obj) GHC.Base.<> (Data.Aeson..=) "ip" (getServersIdResponseBody200ServerPublicNetIpv6Ip obj)))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200ServerPublicNetIpv6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200ServerPublicNetIpv6" (\obj -> ((GHC.Base.pure GetServersIdResponseBody200ServerPublicNetIpv6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "blocked")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "dns_ptr")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ip"))
-- | Defines the data type for the schema GetServersIdResponseBody200ServerPublic_netIpv6Dns_ptr
-- 
-- 
data GetServersIdResponseBody200ServerPublicNetIpv6DnsPtr = GetServersIdResponseBody200ServerPublicNetIpv6DnsPtr {
  -- | dns_ptr: DNS pointer for the specific IP address
  getServersIdResponseBody200ServerPublicNetIpv6DnsPtrDnsPtr :: Data.Text.Internal.Text
  -- | ip: Single IPv6 address of this Server for which the reverse DNS entry has been set up
  , getServersIdResponseBody200ServerPublicNetIpv6DnsPtrIp :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerPublicNetIpv6DnsPtr
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "dns_ptr" (getServersIdResponseBody200ServerPublicNetIpv6DnsPtrDnsPtr obj) : (Data.Aeson..=) "ip" (getServersIdResponseBody200ServerPublicNetIpv6DnsPtrIp obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "dns_ptr" (getServersIdResponseBody200ServerPublicNetIpv6DnsPtrDnsPtr obj) GHC.Base.<> (Data.Aeson..=) "ip" (getServersIdResponseBody200ServerPublicNetIpv6DnsPtrIp obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200ServerPublicNetIpv6DnsPtr
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200ServerPublicNetIpv6DnsPtr" (\obj -> (GHC.Base.pure GetServersIdResponseBody200ServerPublicNetIpv6DnsPtr GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "dns_ptr")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ip"))
-- | Defines the data type for the schema GetServersIdResponseBody200ServerServer_type
-- 
-- Type of Server - determines how much ram, disk and cpu a Server has
data GetServersIdResponseBody200ServerServerType = GetServersIdResponseBody200ServerServerType {
  -- | cores: Number of cpu cores a Server of this type will have
  getServersIdResponseBody200ServerServerTypeCores :: GHC.Types.Double
  -- | cpu_type: Type of cpu
  , getServersIdResponseBody200ServerServerTypeCpuType :: GetServersIdResponseBody200ServerServerTypeCpuType
  -- | deprecated: True if Server type is deprecated
  , getServersIdResponseBody200ServerServerTypeDeprecated :: GHC.Types.Bool
  -- | description: Description of the Server type
  , getServersIdResponseBody200ServerServerTypeDescription :: Data.Text.Internal.Text
  -- | disk: Disk size a Server of this type will have in GB
  , getServersIdResponseBody200ServerServerTypeDisk :: GHC.Types.Double
  -- | id: ID of the Server type
  , getServersIdResponseBody200ServerServerTypeId :: GHC.Integer.Type.Integer
  -- | memory: Memory a Server of this type will have in GB
  , getServersIdResponseBody200ServerServerTypeMemory :: GHC.Types.Double
  -- | name: Unique identifier of the Server type
  , getServersIdResponseBody200ServerServerTypeName :: Data.Text.Internal.Text
  -- | prices: Prices in different Locations
  , getServersIdResponseBody200ServerServerTypePrices :: ([] GetServersIdResponseBody200ServerServerTypePrices)
  -- | storage_type: Type of Server boot drive. Local has higher speed. Network has better availability.
  , getServersIdResponseBody200ServerServerTypeStorageType :: GetServersIdResponseBody200ServerServerTypeStorageType
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerServerType
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "cores" (getServersIdResponseBody200ServerServerTypeCores obj) : (Data.Aeson..=) "cpu_type" (getServersIdResponseBody200ServerServerTypeCpuType obj) : (Data.Aeson..=) "deprecated" (getServersIdResponseBody200ServerServerTypeDeprecated obj) : (Data.Aeson..=) "description" (getServersIdResponseBody200ServerServerTypeDescription obj) : (Data.Aeson..=) "disk" (getServersIdResponseBody200ServerServerTypeDisk obj) : (Data.Aeson..=) "id" (getServersIdResponseBody200ServerServerTypeId obj) : (Data.Aeson..=) "memory" (getServersIdResponseBody200ServerServerTypeMemory obj) : (Data.Aeson..=) "name" (getServersIdResponseBody200ServerServerTypeName obj) : (Data.Aeson..=) "prices" (getServersIdResponseBody200ServerServerTypePrices obj) : (Data.Aeson..=) "storage_type" (getServersIdResponseBody200ServerServerTypeStorageType obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "cores" (getServersIdResponseBody200ServerServerTypeCores obj) GHC.Base.<> ((Data.Aeson..=) "cpu_type" (getServersIdResponseBody200ServerServerTypeCpuType obj) GHC.Base.<> ((Data.Aeson..=) "deprecated" (getServersIdResponseBody200ServerServerTypeDeprecated obj) GHC.Base.<> ((Data.Aeson..=) "description" (getServersIdResponseBody200ServerServerTypeDescription obj) GHC.Base.<> ((Data.Aeson..=) "disk" (getServersIdResponseBody200ServerServerTypeDisk obj) GHC.Base.<> ((Data.Aeson..=) "id" (getServersIdResponseBody200ServerServerTypeId obj) GHC.Base.<> ((Data.Aeson..=) "memory" (getServersIdResponseBody200ServerServerTypeMemory obj) GHC.Base.<> ((Data.Aeson..=) "name" (getServersIdResponseBody200ServerServerTypeName obj) GHC.Base.<> ((Data.Aeson..=) "prices" (getServersIdResponseBody200ServerServerTypePrices obj) GHC.Base.<> (Data.Aeson..=) "storage_type" (getServersIdResponseBody200ServerServerTypeStorageType obj))))))))))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200ServerServerType
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200ServerServerType" (\obj -> (((((((((GHC.Base.pure GetServersIdResponseBody200ServerServerType GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "cores")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "cpu_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deprecated")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "disk")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "memory")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "prices")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "storage_type"))
-- | Defines the enum schema GetServersIdResponseBody200ServerServer_typeCpu_type
-- 
-- Type of cpu
data GetServersIdResponseBody200ServerServerTypeCpuType
    = GetServersIdResponseBody200ServerServerTypeCpuTypeEnumOther Data.Aeson.Types.Internal.Value
    | GetServersIdResponseBody200ServerServerTypeCpuTypeEnumTyped Data.Text.Internal.Text
    | GetServersIdResponseBody200ServerServerTypeCpuTypeEnumStringDedicated
    | GetServersIdResponseBody200ServerServerTypeCpuTypeEnumStringShared
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerServerTypeCpuType
    where toJSON (GetServersIdResponseBody200ServerServerTypeCpuTypeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersIdResponseBody200ServerServerTypeCpuTypeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersIdResponseBody200ServerServerTypeCpuTypeEnumStringDedicated) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "dedicated"
          toJSON (GetServersIdResponseBody200ServerServerTypeCpuTypeEnumStringShared) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "shared"
instance Data.Aeson.FromJSON GetServersIdResponseBody200ServerServerTypeCpuType
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "dedicated")
                                          then GetServersIdResponseBody200ServerServerTypeCpuTypeEnumStringDedicated
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "shared")
                                                then GetServersIdResponseBody200ServerServerTypeCpuTypeEnumStringShared
                                                else GetServersIdResponseBody200ServerServerTypeCpuTypeEnumOther val)
-- | Defines the data type for the schema GetServersIdResponseBody200ServerServer_typePrices
-- 
-- 
data GetServersIdResponseBody200ServerServerTypePrices = GetServersIdResponseBody200ServerServerTypePrices {
  -- | location: Name of the Location the price is for
  getServersIdResponseBody200ServerServerTypePricesLocation :: Data.Text.Internal.Text
  -- | price_hourly: Hourly costs for a Server type in this Location
  , getServersIdResponseBody200ServerServerTypePricesPriceHourly :: GetServersIdResponseBody200ServerServerTypePricesPriceHourly
  -- | price_monthly: Monthly costs for a Server type in this Location
  , getServersIdResponseBody200ServerServerTypePricesPriceMonthly :: GetServersIdResponseBody200ServerServerTypePricesPriceMonthly
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerServerTypePrices
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "location" (getServersIdResponseBody200ServerServerTypePricesLocation obj) : (Data.Aeson..=) "price_hourly" (getServersIdResponseBody200ServerServerTypePricesPriceHourly obj) : (Data.Aeson..=) "price_monthly" (getServersIdResponseBody200ServerServerTypePricesPriceMonthly obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "location" (getServersIdResponseBody200ServerServerTypePricesLocation obj) GHC.Base.<> ((Data.Aeson..=) "price_hourly" (getServersIdResponseBody200ServerServerTypePricesPriceHourly obj) GHC.Base.<> (Data.Aeson..=) "price_monthly" (getServersIdResponseBody200ServerServerTypePricesPriceMonthly obj)))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200ServerServerTypePrices
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200ServerServerTypePrices" (\obj -> ((GHC.Base.pure GetServersIdResponseBody200ServerServerTypePrices GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "location")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "price_hourly")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "price_monthly"))
-- | Defines the data type for the schema GetServersIdResponseBody200ServerServer_typePricesPrice_hourly
-- 
-- Hourly costs for a Server type in this Location
data GetServersIdResponseBody200ServerServerTypePricesPriceHourly = GetServersIdResponseBody200ServerServerTypePricesPriceHourly {
  -- | gross: Price with VAT added
  getServersIdResponseBody200ServerServerTypePricesPriceHourlyGross :: Data.Text.Internal.Text
  -- | net: Price without VAT
  , getServersIdResponseBody200ServerServerTypePricesPriceHourlyNet :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerServerTypePricesPriceHourly
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "gross" (getServersIdResponseBody200ServerServerTypePricesPriceHourlyGross obj) : (Data.Aeson..=) "net" (getServersIdResponseBody200ServerServerTypePricesPriceHourlyNet obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "gross" (getServersIdResponseBody200ServerServerTypePricesPriceHourlyGross obj) GHC.Base.<> (Data.Aeson..=) "net" (getServersIdResponseBody200ServerServerTypePricesPriceHourlyNet obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200ServerServerTypePricesPriceHourly
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200ServerServerTypePricesPriceHourly" (\obj -> (GHC.Base.pure GetServersIdResponseBody200ServerServerTypePricesPriceHourly GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "gross")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "net"))
-- | Defines the data type for the schema GetServersIdResponseBody200ServerServer_typePricesPrice_monthly
-- 
-- Monthly costs for a Server type in this Location
data GetServersIdResponseBody200ServerServerTypePricesPriceMonthly = GetServersIdResponseBody200ServerServerTypePricesPriceMonthly {
  -- | gross: Price with VAT added
  getServersIdResponseBody200ServerServerTypePricesPriceMonthlyGross :: Data.Text.Internal.Text
  -- | net: Price without VAT
  , getServersIdResponseBody200ServerServerTypePricesPriceMonthlyNet :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerServerTypePricesPriceMonthly
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "gross" (getServersIdResponseBody200ServerServerTypePricesPriceMonthlyGross obj) : (Data.Aeson..=) "net" (getServersIdResponseBody200ServerServerTypePricesPriceMonthlyNet obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "gross" (getServersIdResponseBody200ServerServerTypePricesPriceMonthlyGross obj) GHC.Base.<> (Data.Aeson..=) "net" (getServersIdResponseBody200ServerServerTypePricesPriceMonthlyNet obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetServersIdResponseBody200ServerServerTypePricesPriceMonthly
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetServersIdResponseBody200ServerServerTypePricesPriceMonthly" (\obj -> (GHC.Base.pure GetServersIdResponseBody200ServerServerTypePricesPriceMonthly GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "gross")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "net"))
-- | Defines the enum schema GetServersIdResponseBody200ServerServer_typeStorage_type
-- 
-- Type of Server boot drive. Local has higher speed. Network has better availability.
data GetServersIdResponseBody200ServerServerTypeStorageType
    = GetServersIdResponseBody200ServerServerTypeStorageTypeEnumOther Data.Aeson.Types.Internal.Value
    | GetServersIdResponseBody200ServerServerTypeStorageTypeEnumTyped Data.Text.Internal.Text
    | GetServersIdResponseBody200ServerServerTypeStorageTypeEnumStringLocal
    | GetServersIdResponseBody200ServerServerTypeStorageTypeEnumStringNetwork
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerServerTypeStorageType
    where toJSON (GetServersIdResponseBody200ServerServerTypeStorageTypeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersIdResponseBody200ServerServerTypeStorageTypeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersIdResponseBody200ServerServerTypeStorageTypeEnumStringLocal) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "local"
          toJSON (GetServersIdResponseBody200ServerServerTypeStorageTypeEnumStringNetwork) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "network"
instance Data.Aeson.FromJSON GetServersIdResponseBody200ServerServerTypeStorageType
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "local")
                                          then GetServersIdResponseBody200ServerServerTypeStorageTypeEnumStringLocal
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "network")
                                                then GetServersIdResponseBody200ServerServerTypeStorageTypeEnumStringNetwork
                                                else GetServersIdResponseBody200ServerServerTypeStorageTypeEnumOther val)
-- | Defines the enum schema GetServersIdResponseBody200ServerStatus
-- 
-- Status of the Server
data GetServersIdResponseBody200ServerStatus
    = GetServersIdResponseBody200ServerStatusEnumOther Data.Aeson.Types.Internal.Value
    | GetServersIdResponseBody200ServerStatusEnumTyped Data.Text.Internal.Text
    | GetServersIdResponseBody200ServerStatusEnumStringDeleting
    | GetServersIdResponseBody200ServerStatusEnumStringInitializing
    | GetServersIdResponseBody200ServerStatusEnumStringMigrating
    | GetServersIdResponseBody200ServerStatusEnumStringOff
    | GetServersIdResponseBody200ServerStatusEnumStringRebuilding
    | GetServersIdResponseBody200ServerStatusEnumStringRunning
    | GetServersIdResponseBody200ServerStatusEnumStringStarting
    | GetServersIdResponseBody200ServerStatusEnumStringStopping
    | GetServersIdResponseBody200ServerStatusEnumStringUnknown
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetServersIdResponseBody200ServerStatus
    where toJSON (GetServersIdResponseBody200ServerStatusEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersIdResponseBody200ServerStatusEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetServersIdResponseBody200ServerStatusEnumStringDeleting) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "deleting"
          toJSON (GetServersIdResponseBody200ServerStatusEnumStringInitializing) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "initializing"
          toJSON (GetServersIdResponseBody200ServerStatusEnumStringMigrating) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "migrating"
          toJSON (GetServersIdResponseBody200ServerStatusEnumStringOff) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "off"
          toJSON (GetServersIdResponseBody200ServerStatusEnumStringRebuilding) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "rebuilding"
          toJSON (GetServersIdResponseBody200ServerStatusEnumStringRunning) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "running"
          toJSON (GetServersIdResponseBody200ServerStatusEnumStringStarting) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "starting"
          toJSON (GetServersIdResponseBody200ServerStatusEnumStringStopping) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "stopping"
          toJSON (GetServersIdResponseBody200ServerStatusEnumStringUnknown) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "unknown"
instance Data.Aeson.FromJSON GetServersIdResponseBody200ServerStatus
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "deleting")
                                          then GetServersIdResponseBody200ServerStatusEnumStringDeleting
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "initializing")
                                                then GetServersIdResponseBody200ServerStatusEnumStringInitializing
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "migrating")
                                                      then GetServersIdResponseBody200ServerStatusEnumStringMigrating
                                                      else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "off")
                                                            then GetServersIdResponseBody200ServerStatusEnumStringOff
                                                            else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "rebuilding")
                                                                  then GetServersIdResponseBody200ServerStatusEnumStringRebuilding
                                                                  else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "running")
                                                                        then GetServersIdResponseBody200ServerStatusEnumStringRunning
                                                                        else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "starting")
                                                                              then GetServersIdResponseBody200ServerStatusEnumStringStarting
                                                                              else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "stopping")
                                                                                    then GetServersIdResponseBody200ServerStatusEnumStringStopping
                                                                                    else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "unknown")
                                                                                          then GetServersIdResponseBody200ServerStatusEnumStringUnknown
                                                                                          else GetServersIdResponseBody200ServerStatusEnumOther val)
