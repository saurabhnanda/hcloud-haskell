-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE DeriveGeneric #-}

-- | Contains the different functions to run the operation postServers
module HCloud.Operations.PostServers where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Either
import qualified Data.Functor
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Generics
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified HCloud.Common
import HCloud.Types

-- | > POST /servers
-- 
-- Creates a new Server. Returns preliminary information about the Server as well as an Action that covers progress of creation.
postServers :: forall m s . (HCloud.Common.MonadHTTP m, HCloud.Common.SecurityScheme s) => HCloud.Common.Configuration s  -- ^ The configuration to use in the request
  -> GHC.Maybe.Maybe PostServersRequestBody                                                                                  -- ^ The request body to send
  -> m (Data.Either.Either Network.HTTP.Client.Types.HttpException (Network.HTTP.Client.Types.Response PostServersResponse)) -- ^ Monad containing the result of the operation
postServers config
            body = GHC.Base.fmap (GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either PostServersResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 201) (Network.HTTP.Client.Types.responseStatus response) -> PostServersResponse201 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                   PostServersResponseBody201)
                                                                                                                                                                        | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0)) (HCloud.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") (Data.Text.pack "/servers") [] body HCloud.Common.RequestBodyEncodingJSON)
-- | > POST /servers
-- 
-- The same as 'postServers' but returns the raw 'Data.ByteString.Char8.ByteString'
postServersRaw :: forall m s . (HCloud.Common.MonadHTTP m,
                                HCloud.Common.SecurityScheme s) =>
                  HCloud.Common.Configuration s ->
                  GHC.Maybe.Maybe PostServersRequestBody ->
                  m (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                        (Network.HTTP.Client.Types.Response Data.ByteString.Internal.ByteString))
postServersRaw config
               body = GHC.Base.id (HCloud.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") (Data.Text.pack "/servers") [] body HCloud.Common.RequestBodyEncodingJSON)
-- | > POST /servers
-- 
-- Monadic version of 'postServers' (use with 'HCloud.Common.runWithConfiguration')
postServersM :: forall m s . (HCloud.Common.MonadHTTP m,
                              HCloud.Common.SecurityScheme s) =>
                GHC.Maybe.Maybe PostServersRequestBody ->
                Control.Monad.Trans.Reader.ReaderT (HCloud.Common.Configuration s)
                                                   m
                                                   (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                                                       (Network.HTTP.Client.Types.Response PostServersResponse))
postServersM body = GHC.Base.fmap (GHC.Base.fmap (\response_2 -> GHC.Base.fmap (Data.Either.either PostServersResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 201) (Network.HTTP.Client.Types.responseStatus response) -> PostServersResponse201 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                    PostServersResponseBody201)
                                                                                                                                                                         | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_2) response_2)) (HCloud.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") (Data.Text.pack "/servers") [] body HCloud.Common.RequestBodyEncodingJSON)
-- | > POST /servers
-- 
-- Monadic version of 'postServersRaw' (use with 'HCloud.Common.runWithConfiguration')
postServersRawM :: forall m s . (HCloud.Common.MonadHTTP m,
                                 HCloud.Common.SecurityScheme s) =>
                   GHC.Maybe.Maybe PostServersRequestBody ->
                   Control.Monad.Trans.Reader.ReaderT (HCloud.Common.Configuration s)
                                                      m
                                                      (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                                                          (Network.HTTP.Client.Types.Response Data.ByteString.Internal.ByteString))
postServersRawM body = GHC.Base.id (HCloud.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") (Data.Text.pack "/servers") [] body HCloud.Common.RequestBodyEncodingJSON)
-- | Defines the data type for the schema postServersRequestBody
-- 
-- 
data PostServersRequestBody = PostServersRequestBody {
  -- | automount: Auto-mount Volumes after attach
  postServersRequestBodyAutomount :: (GHC.Maybe.Maybe GHC.Types.Bool)
  -- | datacenter: ID or name of Datacenter to create Server in (must not be used together with location)
  , postServersRequestBodyDatacenter :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | firewalls: Firewalls which should be applied on the Server\'s public network interface at creation time
  , postServersRequestBodyFirewalls :: (GHC.Maybe.Maybe ([] PostServersRequestBodyFirewalls))
  -- | image: ID or name of the Image the Server is created from
  , postServersRequestBodyImage :: Data.Text.Internal.Text
  -- | labels: User-defined labels (key-value pairs)
  , postServersRequestBodyLabels :: (GHC.Maybe.Maybe PostServersRequestBodyLabels)
  -- | location: ID or name of Location to create Server in (must not be used together with datacenter)
  , postServersRequestBodyLocation :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | name: Name of the Server to create (must be unique per Project and a valid hostname as per RFC 1123)
  , postServersRequestBodyName :: Data.Text.Internal.Text
  -- | networks: Network IDs which should be attached to the Server private network interface at the creation time
  , postServersRequestBodyNetworks :: (GHC.Maybe.Maybe ([] GHC.Integer.Type.Integer))
  -- | server_type: ID or name of the Server type this Server should be created with
  , postServersRequestBodyServerType :: Data.Text.Internal.Text
  -- | ssh_keys: SSH key IDs (\`integer\`) or names (\`string\`) which should be injected into the Server at creation time
  , postServersRequestBodySshKeys :: (GHC.Maybe.Maybe ([] Data.Text.Internal.Text))
  -- | start_after_create: Start Server right after creation. Defaults to true.
  , postServersRequestBodyStartAfterCreate :: (GHC.Maybe.Maybe GHC.Types.Bool)
  -- | user_data: Cloud-Init user data to use during Server creation. This field is limited to 32KiB.
  , postServersRequestBodyUserData :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | volumes: Volume IDs which should be attached to the Server at the creation time. Volumes must be in the same Location.
  , postServersRequestBodyVolumes :: (GHC.Maybe.Maybe ([] GHC.Integer.Type.Integer))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersRequestBody
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "automount" (postServersRequestBodyAutomount obj) : (Data.Aeson..=) "datacenter" (postServersRequestBodyDatacenter obj) : (Data.Aeson..=) "firewalls" (postServersRequestBodyFirewalls obj) : (Data.Aeson..=) "image" (postServersRequestBodyImage obj) : (Data.Aeson..=) "labels" (postServersRequestBodyLabels obj) : (Data.Aeson..=) "location" (postServersRequestBodyLocation obj) : (Data.Aeson..=) "name" (postServersRequestBodyName obj) : (Data.Aeson..=) "networks" (postServersRequestBodyNetworks obj) : (Data.Aeson..=) "server_type" (postServersRequestBodyServerType obj) : (Data.Aeson..=) "ssh_keys" (postServersRequestBodySshKeys obj) : (Data.Aeson..=) "start_after_create" (postServersRequestBodyStartAfterCreate obj) : (Data.Aeson..=) "user_data" (postServersRequestBodyUserData obj) : (Data.Aeson..=) "volumes" (postServersRequestBodyVolumes obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "automount" (postServersRequestBodyAutomount obj) GHC.Base.<> ((Data.Aeson..=) "datacenter" (postServersRequestBodyDatacenter obj) GHC.Base.<> ((Data.Aeson..=) "firewalls" (postServersRequestBodyFirewalls obj) GHC.Base.<> ((Data.Aeson..=) "image" (postServersRequestBodyImage obj) GHC.Base.<> ((Data.Aeson..=) "labels" (postServersRequestBodyLabels obj) GHC.Base.<> ((Data.Aeson..=) "location" (postServersRequestBodyLocation obj) GHC.Base.<> ((Data.Aeson..=) "name" (postServersRequestBodyName obj) GHC.Base.<> ((Data.Aeson..=) "networks" (postServersRequestBodyNetworks obj) GHC.Base.<> ((Data.Aeson..=) "server_type" (postServersRequestBodyServerType obj) GHC.Base.<> ((Data.Aeson..=) "ssh_keys" (postServersRequestBodySshKeys obj) GHC.Base.<> ((Data.Aeson..=) "start_after_create" (postServersRequestBodyStartAfterCreate obj) GHC.Base.<> ((Data.Aeson..=) "user_data" (postServersRequestBodyUserData obj) GHC.Base.<> (Data.Aeson..=) "volumes" (postServersRequestBodyVolumes obj)))))))))))))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersRequestBody" (\obj -> ((((((((((((GHC.Base.pure PostServersRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "automount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "datacenter")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "firewalls")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "image")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "labels")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "location")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "networks")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "server_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "ssh_keys")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "start_after_create")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "user_data")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "volumes"))
-- | Defines the data type for the schema postServersRequestBodyFirewalls
-- 
-- 
data PostServersRequestBodyFirewalls = PostServersRequestBodyFirewalls {
  -- | firewall: ID of the Firewall
  postServersRequestBodyFirewallsFirewall :: (GHC.Maybe.Maybe GHC.Integer.Type.Integer)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersRequestBodyFirewalls
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "firewall" (postServersRequestBodyFirewallsFirewall obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "firewall" (postServersRequestBodyFirewallsFirewall obj))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersRequestBodyFirewalls
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersRequestBodyFirewalls" (\obj -> GHC.Base.pure PostServersRequestBodyFirewalls GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "firewall"))
-- | Defines the data type for the schema postServersRequestBodyLabels
-- 
-- User-defined labels (key-value pairs)
data PostServersRequestBodyLabels = PostServersRequestBodyLabels {
  
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersRequestBodyLabels
    where toJSON obj = Data.Aeson.object []
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "string" ("string" :: GHC.Base.String))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersRequestBodyLabels
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersRequestBodyLabels" (\obj -> GHC.Base.pure PostServersRequestBodyLabels)
-- | Represents a response of the operation 'postServers'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'PostServersResponseError' is used.
data PostServersResponse =                             
   PostServersResponseError GHC.Base.String            -- ^ Means either no matching case available or a parse error
  | PostServersResponse201 PostServersResponseBody201  -- ^ The \`server\` key in the reply contains a Server object with this structure
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the data type for the schema PostServersResponseBody201
-- 
-- 
data PostServersResponseBody201 = PostServersResponseBody201 {
  -- | action
  postServersResponseBody201Action :: PostServersResponseBody201Action
  -- | next_actions
  , postServersResponseBody201NextActions :: ([] PostServersResponseBody201NextActions)
  -- | root_password: Root password when no SSH keys have been specified
  , postServersResponseBody201RootPassword :: Data.Text.Internal.Text
  -- | server
  , postServersResponseBody201Server :: PostServersResponseBody201Server
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "action" (postServersResponseBody201Action obj) : (Data.Aeson..=) "next_actions" (postServersResponseBody201NextActions obj) : (Data.Aeson..=) "root_password" (postServersResponseBody201RootPassword obj) : (Data.Aeson..=) "server" (postServersResponseBody201Server obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "action" (postServersResponseBody201Action obj) GHC.Base.<> ((Data.Aeson..=) "next_actions" (postServersResponseBody201NextActions obj) GHC.Base.<> ((Data.Aeson..=) "root_password" (postServersResponseBody201RootPassword obj) GHC.Base.<> (Data.Aeson..=) "server" (postServersResponseBody201Server obj))))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201" (\obj -> (((GHC.Base.pure PostServersResponseBody201 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "action")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "next_actions")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "root_password")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "server"))
-- | Defines the data type for the schema PostServersResponseBody201Action
-- 
-- 
data PostServersResponseBody201Action = PostServersResponseBody201Action {
  -- | command: Command executed in the Action
  postServersResponseBody201ActionCommand :: Data.Text.Internal.Text
  -- | error: Error message for the Action if error occurred, otherwise null
  , postServersResponseBody201ActionError :: PostServersResponseBody201ActionError
  -- | finished: Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
  , postServersResponseBody201ActionFinished :: Data.Text.Internal.Text
  -- | id: ID of the Resource
  , postServersResponseBody201ActionId :: GHC.Integer.Type.Integer
  -- | progress: Progress of Action in percent
  , postServersResponseBody201ActionProgress :: GHC.Types.Double
  -- | resources: Resources the Action relates to
  , postServersResponseBody201ActionResources :: ([] PostServersResponseBody201ActionResources)
  -- | started: Point in time when the Action was started (in ISO-8601 format)
  , postServersResponseBody201ActionStarted :: Data.Text.Internal.Text
  -- | status: Status of the Action
  , postServersResponseBody201ActionStatus :: PostServersResponseBody201ActionStatus
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201Action
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "command" (postServersResponseBody201ActionCommand obj) : (Data.Aeson..=) "error" (postServersResponseBody201ActionError obj) : (Data.Aeson..=) "finished" (postServersResponseBody201ActionFinished obj) : (Data.Aeson..=) "id" (postServersResponseBody201ActionId obj) : (Data.Aeson..=) "progress" (postServersResponseBody201ActionProgress obj) : (Data.Aeson..=) "resources" (postServersResponseBody201ActionResources obj) : (Data.Aeson..=) "started" (postServersResponseBody201ActionStarted obj) : (Data.Aeson..=) "status" (postServersResponseBody201ActionStatus obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "command" (postServersResponseBody201ActionCommand obj) GHC.Base.<> ((Data.Aeson..=) "error" (postServersResponseBody201ActionError obj) GHC.Base.<> ((Data.Aeson..=) "finished" (postServersResponseBody201ActionFinished obj) GHC.Base.<> ((Data.Aeson..=) "id" (postServersResponseBody201ActionId obj) GHC.Base.<> ((Data.Aeson..=) "progress" (postServersResponseBody201ActionProgress obj) GHC.Base.<> ((Data.Aeson..=) "resources" (postServersResponseBody201ActionResources obj) GHC.Base.<> ((Data.Aeson..=) "started" (postServersResponseBody201ActionStarted obj) GHC.Base.<> (Data.Aeson..=) "status" (postServersResponseBody201ActionStatus obj))))))))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201Action
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201Action" (\obj -> (((((((GHC.Base.pure PostServersResponseBody201Action GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "command")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "error")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "finished")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "progress")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "resources")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "started")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status"))
-- | Defines the data type for the schema PostServersResponseBody201ActionError
-- 
-- Error message for the Action if error occurred, otherwise null
data PostServersResponseBody201ActionError = PostServersResponseBody201ActionError {
  -- | code: Fixed machine readable code
  postServersResponseBody201ActionErrorCode :: Data.Text.Internal.Text
  -- | message: Humanized error message
  , postServersResponseBody201ActionErrorMessage :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ActionError
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "code" (postServersResponseBody201ActionErrorCode obj) : (Data.Aeson..=) "message" (postServersResponseBody201ActionErrorMessage obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "code" (postServersResponseBody201ActionErrorCode obj) GHC.Base.<> (Data.Aeson..=) "message" (postServersResponseBody201ActionErrorMessage obj))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ActionError
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ActionError" (\obj -> (GHC.Base.pure PostServersResponseBody201ActionError GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "code")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Defines the data type for the schema PostServersResponseBody201ActionResources
-- 
-- 
data PostServersResponseBody201ActionResources = PostServersResponseBody201ActionResources {
  -- | id: ID of the Resource
  postServersResponseBody201ActionResourcesId :: GHC.Integer.Type.Integer
  -- | type: Type of resource referenced
  , postServersResponseBody201ActionResourcesType :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ActionResources
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "id" (postServersResponseBody201ActionResourcesId obj) : (Data.Aeson..=) "type" (postServersResponseBody201ActionResourcesType obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "id" (postServersResponseBody201ActionResourcesId obj) GHC.Base.<> (Data.Aeson..=) "type" (postServersResponseBody201ActionResourcesType obj))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ActionResources
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ActionResources" (\obj -> (GHC.Base.pure PostServersResponseBody201ActionResources GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "type"))
-- | Defines the enum schema PostServersResponseBody201ActionStatus
-- 
-- Status of the Action
data PostServersResponseBody201ActionStatus
    = PostServersResponseBody201ActionStatusEnumOther Data.Aeson.Types.Internal.Value
    | PostServersResponseBody201ActionStatusEnumTyped Data.Text.Internal.Text
    | PostServersResponseBody201ActionStatusEnumStringError
    | PostServersResponseBody201ActionStatusEnumStringRunning
    | PostServersResponseBody201ActionStatusEnumStringSuccess
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ActionStatus
    where toJSON (PostServersResponseBody201ActionStatusEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PostServersResponseBody201ActionStatusEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PostServersResponseBody201ActionStatusEnumStringError) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "error"
          toJSON (PostServersResponseBody201ActionStatusEnumStringRunning) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "running"
          toJSON (PostServersResponseBody201ActionStatusEnumStringSuccess) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "success"
instance Data.Aeson.FromJSON PostServersResponseBody201ActionStatus
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "error")
                                          then PostServersResponseBody201ActionStatusEnumStringError
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "running")
                                                then PostServersResponseBody201ActionStatusEnumStringRunning
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "success")
                                                      then PostServersResponseBody201ActionStatusEnumStringSuccess
                                                      else PostServersResponseBody201ActionStatusEnumOther val)
-- | Defines the data type for the schema PostServersResponseBody201Next_actions
-- 
-- 
data PostServersResponseBody201NextActions = PostServersResponseBody201NextActions {
  -- | command: Command executed in the Action
  postServersResponseBody201NextActionsCommand :: Data.Text.Internal.Text
  -- | error: Error message for the Action if error occurred, otherwise null
  , postServersResponseBody201NextActionsError :: PostServersResponseBody201NextActionsError
  -- | finished: Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
  , postServersResponseBody201NextActionsFinished :: Data.Text.Internal.Text
  -- | id: ID of the Resource
  , postServersResponseBody201NextActionsId :: GHC.Integer.Type.Integer
  -- | progress: Progress of Action in percent
  , postServersResponseBody201NextActionsProgress :: GHC.Types.Double
  -- | resources: Resources the Action relates to
  , postServersResponseBody201NextActionsResources :: ([] PostServersResponseBody201NextActionsResources)
  -- | started: Point in time when the Action was started (in ISO-8601 format)
  , postServersResponseBody201NextActionsStarted :: Data.Text.Internal.Text
  -- | status: Status of the Action
  , postServersResponseBody201NextActionsStatus :: PostServersResponseBody201NextActionsStatus
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201NextActions
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "command" (postServersResponseBody201NextActionsCommand obj) : (Data.Aeson..=) "error" (postServersResponseBody201NextActionsError obj) : (Data.Aeson..=) "finished" (postServersResponseBody201NextActionsFinished obj) : (Data.Aeson..=) "id" (postServersResponseBody201NextActionsId obj) : (Data.Aeson..=) "progress" (postServersResponseBody201NextActionsProgress obj) : (Data.Aeson..=) "resources" (postServersResponseBody201NextActionsResources obj) : (Data.Aeson..=) "started" (postServersResponseBody201NextActionsStarted obj) : (Data.Aeson..=) "status" (postServersResponseBody201NextActionsStatus obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "command" (postServersResponseBody201NextActionsCommand obj) GHC.Base.<> ((Data.Aeson..=) "error" (postServersResponseBody201NextActionsError obj) GHC.Base.<> ((Data.Aeson..=) "finished" (postServersResponseBody201NextActionsFinished obj) GHC.Base.<> ((Data.Aeson..=) "id" (postServersResponseBody201NextActionsId obj) GHC.Base.<> ((Data.Aeson..=) "progress" (postServersResponseBody201NextActionsProgress obj) GHC.Base.<> ((Data.Aeson..=) "resources" (postServersResponseBody201NextActionsResources obj) GHC.Base.<> ((Data.Aeson..=) "started" (postServersResponseBody201NextActionsStarted obj) GHC.Base.<> (Data.Aeson..=) "status" (postServersResponseBody201NextActionsStatus obj))))))))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201NextActions
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201NextActions" (\obj -> (((((((GHC.Base.pure PostServersResponseBody201NextActions GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "command")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "error")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "finished")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "progress")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "resources")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "started")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status"))
-- | Defines the data type for the schema PostServersResponseBody201Next_actionsError
-- 
-- Error message for the Action if error occurred, otherwise null
data PostServersResponseBody201NextActionsError = PostServersResponseBody201NextActionsError {
  -- | code: Fixed machine readable code
  postServersResponseBody201NextActionsErrorCode :: Data.Text.Internal.Text
  -- | message: Humanized error message
  , postServersResponseBody201NextActionsErrorMessage :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201NextActionsError
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "code" (postServersResponseBody201NextActionsErrorCode obj) : (Data.Aeson..=) "message" (postServersResponseBody201NextActionsErrorMessage obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "code" (postServersResponseBody201NextActionsErrorCode obj) GHC.Base.<> (Data.Aeson..=) "message" (postServersResponseBody201NextActionsErrorMessage obj))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201NextActionsError
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201NextActionsError" (\obj -> (GHC.Base.pure PostServersResponseBody201NextActionsError GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "code")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Defines the data type for the schema PostServersResponseBody201Next_actionsResources
-- 
-- 
data PostServersResponseBody201NextActionsResources = PostServersResponseBody201NextActionsResources {
  -- | id: ID of the Resource
  postServersResponseBody201NextActionsResourcesId :: GHC.Integer.Type.Integer
  -- | type: Type of resource referenced
  , postServersResponseBody201NextActionsResourcesType :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201NextActionsResources
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "id" (postServersResponseBody201NextActionsResourcesId obj) : (Data.Aeson..=) "type" (postServersResponseBody201NextActionsResourcesType obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "id" (postServersResponseBody201NextActionsResourcesId obj) GHC.Base.<> (Data.Aeson..=) "type" (postServersResponseBody201NextActionsResourcesType obj))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201NextActionsResources
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201NextActionsResources" (\obj -> (GHC.Base.pure PostServersResponseBody201NextActionsResources GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "type"))
-- | Defines the enum schema PostServersResponseBody201Next_actionsStatus
-- 
-- Status of the Action
data PostServersResponseBody201NextActionsStatus
    = PostServersResponseBody201NextActionsStatusEnumOther Data.Aeson.Types.Internal.Value
    | PostServersResponseBody201NextActionsStatusEnumTyped Data.Text.Internal.Text
    | PostServersResponseBody201NextActionsStatusEnumStringError
    | PostServersResponseBody201NextActionsStatusEnumStringRunning
    | PostServersResponseBody201NextActionsStatusEnumStringSuccess
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201NextActionsStatus
    where toJSON (PostServersResponseBody201NextActionsStatusEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PostServersResponseBody201NextActionsStatusEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PostServersResponseBody201NextActionsStatusEnumStringError) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "error"
          toJSON (PostServersResponseBody201NextActionsStatusEnumStringRunning) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "running"
          toJSON (PostServersResponseBody201NextActionsStatusEnumStringSuccess) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "success"
instance Data.Aeson.FromJSON PostServersResponseBody201NextActionsStatus
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "error")
                                          then PostServersResponseBody201NextActionsStatusEnumStringError
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "running")
                                                then PostServersResponseBody201NextActionsStatusEnumStringRunning
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "success")
                                                      then PostServersResponseBody201NextActionsStatusEnumStringSuccess
                                                      else PostServersResponseBody201NextActionsStatusEnumOther val)
-- | Defines the data type for the schema PostServersResponseBody201Server
-- 
-- 
data PostServersResponseBody201Server = PostServersResponseBody201Server {
  -- | backup_window: Time window (UTC) in which the backup will run, or null if the backups are not enabled
  postServersResponseBody201ServerBackupWindow :: Data.Text.Internal.Text
  -- | created: Point in time when the Resource was created (in ISO-8601 format)
  , postServersResponseBody201ServerCreated :: Data.Text.Internal.Text
  -- | datacenter: Datacenter this Resource is located at
  , postServersResponseBody201ServerDatacenter :: PostServersResponseBody201ServerDatacenter
  -- | id: ID of the Resource
  , postServersResponseBody201ServerId :: GHC.Integer.Type.Integer
  -- | image
  , postServersResponseBody201ServerImage :: PostServersResponseBody201ServerImage
  -- | included_traffic: Free Traffic for the current billing period in bytes
  , postServersResponseBody201ServerIncludedTraffic :: GHC.Types.Double
  -- | ingoing_traffic: Inbound Traffic for the current billing period in bytes
  , postServersResponseBody201ServerIngoingTraffic :: GHC.Types.Double
  -- | iso: ISO Image that is attached to this Server. Null if no ISO is attached.
  , postServersResponseBody201ServerIso :: PostServersResponseBody201ServerIso
  -- | labels: User-defined labels (key-value pairs)
  , postServersResponseBody201ServerLabels :: PostServersResponseBody201ServerLabels
  -- | load_balancers
  , postServersResponseBody201ServerLoadBalancers :: (GHC.Maybe.Maybe ([] GHC.Integer.Type.Integer))
  -- | locked: True if Server has been locked and is not available to user
  , postServersResponseBody201ServerLocked :: GHC.Types.Bool
  -- | name: Name of the Resource. Must be unique per Project.
  , postServersResponseBody201ServerName :: Data.Text.Internal.Text
  -- | outgoing_traffic: Outbound Traffic for the current billing period in bytes
  , postServersResponseBody201ServerOutgoingTraffic :: GHC.Types.Double
  -- | placement_group
  , postServersResponseBody201ServerPlacementGroup :: (GHC.Maybe.Maybe PostServersResponseBody201ServerPlacementGroup)
  -- | primary_disk_size: Size of the primary Disk
  , postServersResponseBody201ServerPrimaryDiskSize :: GHC.Types.Double
  -- | private_net: Private networks information
  , postServersResponseBody201ServerPrivateNet :: ([] PostServersResponseBody201ServerPrivateNet)
  -- | protection: Protection configuration for the Server
  , postServersResponseBody201ServerProtection :: PostServersResponseBody201ServerProtection
  -- | public_net: Public network information. The Server\'s IPv4 address can be found in \`public_net->ipv4->ip\`
  , postServersResponseBody201ServerPublicNet :: PostServersResponseBody201ServerPublicNet
  -- | rescue_enabled: True if rescue mode is enabled. Server will then boot into rescue system on next reboot
  , postServersResponseBody201ServerRescueEnabled :: GHC.Types.Bool
  -- | server_type: Type of Server - determines how much ram, disk and cpu a Server has
  , postServersResponseBody201ServerServerType :: PostServersResponseBody201ServerServerType
  -- | status: Status of the Server
  , postServersResponseBody201ServerStatus :: PostServersResponseBody201ServerStatus
  -- | volumes: IDs of Volumes assigned to this Server
  , postServersResponseBody201ServerVolumes :: (GHC.Maybe.Maybe ([] GHC.Integer.Type.Integer))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201Server
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "backup_window" (postServersResponseBody201ServerBackupWindow obj) : (Data.Aeson..=) "created" (postServersResponseBody201ServerCreated obj) : (Data.Aeson..=) "datacenter" (postServersResponseBody201ServerDatacenter obj) : (Data.Aeson..=) "id" (postServersResponseBody201ServerId obj) : (Data.Aeson..=) "image" (postServersResponseBody201ServerImage obj) : (Data.Aeson..=) "included_traffic" (postServersResponseBody201ServerIncludedTraffic obj) : (Data.Aeson..=) "ingoing_traffic" (postServersResponseBody201ServerIngoingTraffic obj) : (Data.Aeson..=) "iso" (postServersResponseBody201ServerIso obj) : (Data.Aeson..=) "labels" (postServersResponseBody201ServerLabels obj) : (Data.Aeson..=) "load_balancers" (postServersResponseBody201ServerLoadBalancers obj) : (Data.Aeson..=) "locked" (postServersResponseBody201ServerLocked obj) : (Data.Aeson..=) "name" (postServersResponseBody201ServerName obj) : (Data.Aeson..=) "outgoing_traffic" (postServersResponseBody201ServerOutgoingTraffic obj) : (Data.Aeson..=) "placement_group" (postServersResponseBody201ServerPlacementGroup obj) : (Data.Aeson..=) "primary_disk_size" (postServersResponseBody201ServerPrimaryDiskSize obj) : (Data.Aeson..=) "private_net" (postServersResponseBody201ServerPrivateNet obj) : (Data.Aeson..=) "protection" (postServersResponseBody201ServerProtection obj) : (Data.Aeson..=) "public_net" (postServersResponseBody201ServerPublicNet obj) : (Data.Aeson..=) "rescue_enabled" (postServersResponseBody201ServerRescueEnabled obj) : (Data.Aeson..=) "server_type" (postServersResponseBody201ServerServerType obj) : (Data.Aeson..=) "status" (postServersResponseBody201ServerStatus obj) : (Data.Aeson..=) "volumes" (postServersResponseBody201ServerVolumes obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "backup_window" (postServersResponseBody201ServerBackupWindow obj) GHC.Base.<> ((Data.Aeson..=) "created" (postServersResponseBody201ServerCreated obj) GHC.Base.<> ((Data.Aeson..=) "datacenter" (postServersResponseBody201ServerDatacenter obj) GHC.Base.<> ((Data.Aeson..=) "id" (postServersResponseBody201ServerId obj) GHC.Base.<> ((Data.Aeson..=) "image" (postServersResponseBody201ServerImage obj) GHC.Base.<> ((Data.Aeson..=) "included_traffic" (postServersResponseBody201ServerIncludedTraffic obj) GHC.Base.<> ((Data.Aeson..=) "ingoing_traffic" (postServersResponseBody201ServerIngoingTraffic obj) GHC.Base.<> ((Data.Aeson..=) "iso" (postServersResponseBody201ServerIso obj) GHC.Base.<> ((Data.Aeson..=) "labels" (postServersResponseBody201ServerLabels obj) GHC.Base.<> ((Data.Aeson..=) "load_balancers" (postServersResponseBody201ServerLoadBalancers obj) GHC.Base.<> ((Data.Aeson..=) "locked" (postServersResponseBody201ServerLocked obj) GHC.Base.<> ((Data.Aeson..=) "name" (postServersResponseBody201ServerName obj) GHC.Base.<> ((Data.Aeson..=) "outgoing_traffic" (postServersResponseBody201ServerOutgoingTraffic obj) GHC.Base.<> ((Data.Aeson..=) "placement_group" (postServersResponseBody201ServerPlacementGroup obj) GHC.Base.<> ((Data.Aeson..=) "primary_disk_size" (postServersResponseBody201ServerPrimaryDiskSize obj) GHC.Base.<> ((Data.Aeson..=) "private_net" (postServersResponseBody201ServerPrivateNet obj) GHC.Base.<> ((Data.Aeson..=) "protection" (postServersResponseBody201ServerProtection obj) GHC.Base.<> ((Data.Aeson..=) "public_net" (postServersResponseBody201ServerPublicNet obj) GHC.Base.<> ((Data.Aeson..=) "rescue_enabled" (postServersResponseBody201ServerRescueEnabled obj) GHC.Base.<> ((Data.Aeson..=) "server_type" (postServersResponseBody201ServerServerType obj) GHC.Base.<> ((Data.Aeson..=) "status" (postServersResponseBody201ServerStatus obj) GHC.Base.<> (Data.Aeson..=) "volumes" (postServersResponseBody201ServerVolumes obj))))))))))))))))))))))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201Server
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201Server" (\obj -> (((((((((((((((((((((GHC.Base.pure PostServersResponseBody201Server GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "backup_window")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "datacenter")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "image")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "included_traffic")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ingoing_traffic")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "iso")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "labels")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "load_balancers")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "locked")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "outgoing_traffic")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "placement_group")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "primary_disk_size")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "private_net")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "protection")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "public_net")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "rescue_enabled")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "server_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "volumes"))
-- | Defines the data type for the schema PostServersResponseBody201ServerDatacenter
-- 
-- Datacenter this Resource is located at
data PostServersResponseBody201ServerDatacenter = PostServersResponseBody201ServerDatacenter {
  -- | description: Description of the Datacenter
  postServersResponseBody201ServerDatacenterDescription :: Data.Text.Internal.Text
  -- | id: ID of the Resource
  , postServersResponseBody201ServerDatacenterId :: GHC.Integer.Type.Integer
  -- | location
  , postServersResponseBody201ServerDatacenterLocation :: PostServersResponseBody201ServerDatacenterLocation
  -- | name: Unique identifier of the Datacenter
  , postServersResponseBody201ServerDatacenterName :: Data.Text.Internal.Text
  -- | server_types: The Server types the Datacenter can handle
  , postServersResponseBody201ServerDatacenterServerTypes :: PostServersResponseBody201ServerDatacenterServerTypes
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerDatacenter
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "description" (postServersResponseBody201ServerDatacenterDescription obj) : (Data.Aeson..=) "id" (postServersResponseBody201ServerDatacenterId obj) : (Data.Aeson..=) "location" (postServersResponseBody201ServerDatacenterLocation obj) : (Data.Aeson..=) "name" (postServersResponseBody201ServerDatacenterName obj) : (Data.Aeson..=) "server_types" (postServersResponseBody201ServerDatacenterServerTypes obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "description" (postServersResponseBody201ServerDatacenterDescription obj) GHC.Base.<> ((Data.Aeson..=) "id" (postServersResponseBody201ServerDatacenterId obj) GHC.Base.<> ((Data.Aeson..=) "location" (postServersResponseBody201ServerDatacenterLocation obj) GHC.Base.<> ((Data.Aeson..=) "name" (postServersResponseBody201ServerDatacenterName obj) GHC.Base.<> (Data.Aeson..=) "server_types" (postServersResponseBody201ServerDatacenterServerTypes obj)))))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ServerDatacenter
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ServerDatacenter" (\obj -> ((((GHC.Base.pure PostServersResponseBody201ServerDatacenter GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "location")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "server_types"))
-- | Defines the data type for the schema PostServersResponseBody201ServerDatacenterLocation
-- 
-- 
data PostServersResponseBody201ServerDatacenterLocation = PostServersResponseBody201ServerDatacenterLocation {
  -- | city: City the Location is closest to
  postServersResponseBody201ServerDatacenterLocationCity :: Data.Text.Internal.Text
  -- | country: ISO 3166-1 alpha-2 code of the country the Location resides in
  , postServersResponseBody201ServerDatacenterLocationCountry :: Data.Text.Internal.Text
  -- | description: Description of the Location
  , postServersResponseBody201ServerDatacenterLocationDescription :: Data.Text.Internal.Text
  -- | id: ID of the Location
  , postServersResponseBody201ServerDatacenterLocationId :: GHC.Types.Double
  -- | latitude: Latitude of the city closest to the Location
  , postServersResponseBody201ServerDatacenterLocationLatitude :: GHC.Types.Double
  -- | longitude: Longitude of the city closest to the Location
  , postServersResponseBody201ServerDatacenterLocationLongitude :: GHC.Types.Double
  -- | name: Unique identifier of the Location
  , postServersResponseBody201ServerDatacenterLocationName :: Data.Text.Internal.Text
  -- | network_zone: Name of network zone this Location resides in
  , postServersResponseBody201ServerDatacenterLocationNetworkZone :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerDatacenterLocation
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "city" (postServersResponseBody201ServerDatacenterLocationCity obj) : (Data.Aeson..=) "country" (postServersResponseBody201ServerDatacenterLocationCountry obj) : (Data.Aeson..=) "description" (postServersResponseBody201ServerDatacenterLocationDescription obj) : (Data.Aeson..=) "id" (postServersResponseBody201ServerDatacenterLocationId obj) : (Data.Aeson..=) "latitude" (postServersResponseBody201ServerDatacenterLocationLatitude obj) : (Data.Aeson..=) "longitude" (postServersResponseBody201ServerDatacenterLocationLongitude obj) : (Data.Aeson..=) "name" (postServersResponseBody201ServerDatacenterLocationName obj) : (Data.Aeson..=) "network_zone" (postServersResponseBody201ServerDatacenterLocationNetworkZone obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "city" (postServersResponseBody201ServerDatacenterLocationCity obj) GHC.Base.<> ((Data.Aeson..=) "country" (postServersResponseBody201ServerDatacenterLocationCountry obj) GHC.Base.<> ((Data.Aeson..=) "description" (postServersResponseBody201ServerDatacenterLocationDescription obj) GHC.Base.<> ((Data.Aeson..=) "id" (postServersResponseBody201ServerDatacenterLocationId obj) GHC.Base.<> ((Data.Aeson..=) "latitude" (postServersResponseBody201ServerDatacenterLocationLatitude obj) GHC.Base.<> ((Data.Aeson..=) "longitude" (postServersResponseBody201ServerDatacenterLocationLongitude obj) GHC.Base.<> ((Data.Aeson..=) "name" (postServersResponseBody201ServerDatacenterLocationName obj) GHC.Base.<> (Data.Aeson..=) "network_zone" (postServersResponseBody201ServerDatacenterLocationNetworkZone obj))))))))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ServerDatacenterLocation
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ServerDatacenterLocation" (\obj -> (((((((GHC.Base.pure PostServersResponseBody201ServerDatacenterLocation GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "city")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "country")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "latitude")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "longitude")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "network_zone"))
-- | Defines the data type for the schema PostServersResponseBody201ServerDatacenterServer_types
-- 
-- The Server types the Datacenter can handle
data PostServersResponseBody201ServerDatacenterServerTypes = PostServersResponseBody201ServerDatacenterServerTypes {
  -- | available: IDs of Server types that are supported and for which the Datacenter has enough resources left
  postServersResponseBody201ServerDatacenterServerTypesAvailable :: ([] GHC.Types.Double)
  -- | available_for_migration: IDs of Server types that are supported and for which the Datacenter has enough resources left
  , postServersResponseBody201ServerDatacenterServerTypesAvailableForMigration :: ([] GHC.Types.Double)
  -- | supported: IDs of Server types that are supported in the Datacenter
  , postServersResponseBody201ServerDatacenterServerTypesSupported :: ([] GHC.Types.Double)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerDatacenterServerTypes
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "available" (postServersResponseBody201ServerDatacenterServerTypesAvailable obj) : (Data.Aeson..=) "available_for_migration" (postServersResponseBody201ServerDatacenterServerTypesAvailableForMigration obj) : (Data.Aeson..=) "supported" (postServersResponseBody201ServerDatacenterServerTypesSupported obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "available" (postServersResponseBody201ServerDatacenterServerTypesAvailable obj) GHC.Base.<> ((Data.Aeson..=) "available_for_migration" (postServersResponseBody201ServerDatacenterServerTypesAvailableForMigration obj) GHC.Base.<> (Data.Aeson..=) "supported" (postServersResponseBody201ServerDatacenterServerTypesSupported obj)))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ServerDatacenterServerTypes
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ServerDatacenterServerTypes" (\obj -> ((GHC.Base.pure PostServersResponseBody201ServerDatacenterServerTypes GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "available")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "available_for_migration")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "supported"))
-- | Defines the data type for the schema PostServersResponseBody201ServerImage
-- 
-- 
data PostServersResponseBody201ServerImage = PostServersResponseBody201ServerImage {
  -- | bound_to: ID of Server the Image is bound to. Only set for Images of type \`backup\`.
  postServersResponseBody201ServerImageBoundTo :: GHC.Integer.Type.Integer
  -- | build_id: Build ID of the Image
  , postServersResponseBody201ServerImageBuildId :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | created: Point in time when the Resource was created (in ISO-8601 format)
  , postServersResponseBody201ServerImageCreated :: Data.Text.Internal.Text
  -- | created_from: Information about the Server the Image was created from
  , postServersResponseBody201ServerImageCreatedFrom :: PostServersResponseBody201ServerImageCreatedFrom
  -- | deleted: Point in time where the Image was deleted (in ISO-8601 format)
  , postServersResponseBody201ServerImageDeleted :: Data.Text.Internal.Text
  -- | deprecated: Point in time when the Image is considered to be deprecated (in ISO-8601 format)
  , postServersResponseBody201ServerImageDeprecated :: Data.Text.Internal.Text
  -- | description: Description of the Image
  , postServersResponseBody201ServerImageDescription :: Data.Text.Internal.Text
  -- | disk_size: Size of the disk contained in the Image in GB
  , postServersResponseBody201ServerImageDiskSize :: GHC.Types.Double
  -- | id: ID of the Resource
  , postServersResponseBody201ServerImageId :: GHC.Integer.Type.Integer
  -- | image_size: Size of the Image file in our storage in GB. For snapshot Images this is the value relevant for calculating costs for the Image.
  , postServersResponseBody201ServerImageImageSize :: GHC.Types.Double
  -- | labels: User-defined labels (key-value pairs)
  , postServersResponseBody201ServerImageLabels :: PostServersResponseBody201ServerImageLabels
  -- | name: Unique identifier of the Image. This value is only set for system Images.
  , postServersResponseBody201ServerImageName :: Data.Text.Internal.Text
  -- | os_flavor: Flavor of operating system contained in the Image
  , postServersResponseBody201ServerImageOsFlavor :: PostServersResponseBody201ServerImageOsFlavor
  -- | os_version: Operating system version
  , postServersResponseBody201ServerImageOsVersion :: Data.Text.Internal.Text
  -- | protection: Protection configuration for the Resource
  , postServersResponseBody201ServerImageProtection :: PostServersResponseBody201ServerImageProtection
  -- | rapid_deploy: Indicates that rapid deploy of the Image is available
  , postServersResponseBody201ServerImageRapidDeploy :: (GHC.Maybe.Maybe GHC.Types.Bool)
  -- | status: Whether the Image can be used or if it\'s still being created or unavailable
  , postServersResponseBody201ServerImageStatus :: PostServersResponseBody201ServerImageStatus
  -- | type: Type of the Image
  , postServersResponseBody201ServerImageType :: PostServersResponseBody201ServerImageType
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerImage
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "bound_to" (postServersResponseBody201ServerImageBoundTo obj) : (Data.Aeson..=) "build_id" (postServersResponseBody201ServerImageBuildId obj) : (Data.Aeson..=) "created" (postServersResponseBody201ServerImageCreated obj) : (Data.Aeson..=) "created_from" (postServersResponseBody201ServerImageCreatedFrom obj) : (Data.Aeson..=) "deleted" (postServersResponseBody201ServerImageDeleted obj) : (Data.Aeson..=) "deprecated" (postServersResponseBody201ServerImageDeprecated obj) : (Data.Aeson..=) "description" (postServersResponseBody201ServerImageDescription obj) : (Data.Aeson..=) "disk_size" (postServersResponseBody201ServerImageDiskSize obj) : (Data.Aeson..=) "id" (postServersResponseBody201ServerImageId obj) : (Data.Aeson..=) "image_size" (postServersResponseBody201ServerImageImageSize obj) : (Data.Aeson..=) "labels" (postServersResponseBody201ServerImageLabels obj) : (Data.Aeson..=) "name" (postServersResponseBody201ServerImageName obj) : (Data.Aeson..=) "os_flavor" (postServersResponseBody201ServerImageOsFlavor obj) : (Data.Aeson..=) "os_version" (postServersResponseBody201ServerImageOsVersion obj) : (Data.Aeson..=) "protection" (postServersResponseBody201ServerImageProtection obj) : (Data.Aeson..=) "rapid_deploy" (postServersResponseBody201ServerImageRapidDeploy obj) : (Data.Aeson..=) "status" (postServersResponseBody201ServerImageStatus obj) : (Data.Aeson..=) "type" (postServersResponseBody201ServerImageType obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "bound_to" (postServersResponseBody201ServerImageBoundTo obj) GHC.Base.<> ((Data.Aeson..=) "build_id" (postServersResponseBody201ServerImageBuildId obj) GHC.Base.<> ((Data.Aeson..=) "created" (postServersResponseBody201ServerImageCreated obj) GHC.Base.<> ((Data.Aeson..=) "created_from" (postServersResponseBody201ServerImageCreatedFrom obj) GHC.Base.<> ((Data.Aeson..=) "deleted" (postServersResponseBody201ServerImageDeleted obj) GHC.Base.<> ((Data.Aeson..=) "deprecated" (postServersResponseBody201ServerImageDeprecated obj) GHC.Base.<> ((Data.Aeson..=) "description" (postServersResponseBody201ServerImageDescription obj) GHC.Base.<> ((Data.Aeson..=) "disk_size" (postServersResponseBody201ServerImageDiskSize obj) GHC.Base.<> ((Data.Aeson..=) "id" (postServersResponseBody201ServerImageId obj) GHC.Base.<> ((Data.Aeson..=) "image_size" (postServersResponseBody201ServerImageImageSize obj) GHC.Base.<> ((Data.Aeson..=) "labels" (postServersResponseBody201ServerImageLabels obj) GHC.Base.<> ((Data.Aeson..=) "name" (postServersResponseBody201ServerImageName obj) GHC.Base.<> ((Data.Aeson..=) "os_flavor" (postServersResponseBody201ServerImageOsFlavor obj) GHC.Base.<> ((Data.Aeson..=) "os_version" (postServersResponseBody201ServerImageOsVersion obj) GHC.Base.<> ((Data.Aeson..=) "protection" (postServersResponseBody201ServerImageProtection obj) GHC.Base.<> ((Data.Aeson..=) "rapid_deploy" (postServersResponseBody201ServerImageRapidDeploy obj) GHC.Base.<> ((Data.Aeson..=) "status" (postServersResponseBody201ServerImageStatus obj) GHC.Base.<> (Data.Aeson..=) "type" (postServersResponseBody201ServerImageType obj))))))))))))))))))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ServerImage
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ServerImage" (\obj -> (((((((((((((((((GHC.Base.pure PostServersResponseBody201ServerImage GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "bound_to")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "build_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created_from")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deleted")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deprecated")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "disk_size")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "image_size")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "labels")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "os_flavor")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "os_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "protection")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "rapid_deploy")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "type"))
-- | Defines the data type for the schema PostServersResponseBody201ServerImageCreated_from
-- 
-- Information about the Server the Image was created from
data PostServersResponseBody201ServerImageCreatedFrom = PostServersResponseBody201ServerImageCreatedFrom {
  -- | id: ID of the Server the Image was created from
  postServersResponseBody201ServerImageCreatedFromId :: GHC.Integer.Type.Integer
  -- | name: Server name at the time the Image was created
  , postServersResponseBody201ServerImageCreatedFromName :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerImageCreatedFrom
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "id" (postServersResponseBody201ServerImageCreatedFromId obj) : (Data.Aeson..=) "name" (postServersResponseBody201ServerImageCreatedFromName obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "id" (postServersResponseBody201ServerImageCreatedFromId obj) GHC.Base.<> (Data.Aeson..=) "name" (postServersResponseBody201ServerImageCreatedFromName obj))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ServerImageCreatedFrom
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ServerImageCreatedFrom" (\obj -> (GHC.Base.pure PostServersResponseBody201ServerImageCreatedFrom GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name"))
-- | Defines the data type for the schema PostServersResponseBody201ServerImageLabels
-- 
-- User-defined labels (key-value pairs)
data PostServersResponseBody201ServerImageLabels = PostServersResponseBody201ServerImageLabels {
  
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerImageLabels
    where toJSON obj = Data.Aeson.object []
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "string" ("string" :: GHC.Base.String))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ServerImageLabels
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ServerImageLabels" (\obj -> GHC.Base.pure PostServersResponseBody201ServerImageLabels)
-- | Defines the enum schema PostServersResponseBody201ServerImageOs_flavor
-- 
-- Flavor of operating system contained in the Image
data PostServersResponseBody201ServerImageOsFlavor
    = PostServersResponseBody201ServerImageOsFlavorEnumOther Data.Aeson.Types.Internal.Value
    | PostServersResponseBody201ServerImageOsFlavorEnumTyped Data.Text.Internal.Text
    | PostServersResponseBody201ServerImageOsFlavorEnumStringCentos
    | PostServersResponseBody201ServerImageOsFlavorEnumStringDebian
    | PostServersResponseBody201ServerImageOsFlavorEnumStringFedora
    | PostServersResponseBody201ServerImageOsFlavorEnumStringUbuntu
    | PostServersResponseBody201ServerImageOsFlavorEnumStringUnknown
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerImageOsFlavor
    where toJSON (PostServersResponseBody201ServerImageOsFlavorEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PostServersResponseBody201ServerImageOsFlavorEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PostServersResponseBody201ServerImageOsFlavorEnumStringCentos) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "centos"
          toJSON (PostServersResponseBody201ServerImageOsFlavorEnumStringDebian) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "debian"
          toJSON (PostServersResponseBody201ServerImageOsFlavorEnumStringFedora) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "fedora"
          toJSON (PostServersResponseBody201ServerImageOsFlavorEnumStringUbuntu) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "ubuntu"
          toJSON (PostServersResponseBody201ServerImageOsFlavorEnumStringUnknown) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "unknown"
instance Data.Aeson.FromJSON PostServersResponseBody201ServerImageOsFlavor
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "centos")
                                          then PostServersResponseBody201ServerImageOsFlavorEnumStringCentos
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "debian")
                                                then PostServersResponseBody201ServerImageOsFlavorEnumStringDebian
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "fedora")
                                                      then PostServersResponseBody201ServerImageOsFlavorEnumStringFedora
                                                      else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "ubuntu")
                                                            then PostServersResponseBody201ServerImageOsFlavorEnumStringUbuntu
                                                            else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "unknown")
                                                                  then PostServersResponseBody201ServerImageOsFlavorEnumStringUnknown
                                                                  else PostServersResponseBody201ServerImageOsFlavorEnumOther val)
-- | Defines the data type for the schema PostServersResponseBody201ServerImageProtection
-- 
-- Protection configuration for the Resource
data PostServersResponseBody201ServerImageProtection = PostServersResponseBody201ServerImageProtection {
  -- | delete: If true, prevents the Resource from being deleted
  postServersResponseBody201ServerImageProtectionDelete :: GHC.Types.Bool
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerImageProtection
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "delete" (postServersResponseBody201ServerImageProtectionDelete obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "delete" (postServersResponseBody201ServerImageProtectionDelete obj))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ServerImageProtection
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ServerImageProtection" (\obj -> GHC.Base.pure PostServersResponseBody201ServerImageProtection GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "delete"))
-- | Defines the enum schema PostServersResponseBody201ServerImageStatus
-- 
-- Whether the Image can be used or if it\'s still being created or unavailable
data PostServersResponseBody201ServerImageStatus
    = PostServersResponseBody201ServerImageStatusEnumOther Data.Aeson.Types.Internal.Value
    | PostServersResponseBody201ServerImageStatusEnumTyped Data.Text.Internal.Text
    | PostServersResponseBody201ServerImageStatusEnumStringAvailable
    | PostServersResponseBody201ServerImageStatusEnumStringCreating
    | PostServersResponseBody201ServerImageStatusEnumStringUnavailable
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerImageStatus
    where toJSON (PostServersResponseBody201ServerImageStatusEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PostServersResponseBody201ServerImageStatusEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PostServersResponseBody201ServerImageStatusEnumStringAvailable) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "available"
          toJSON (PostServersResponseBody201ServerImageStatusEnumStringCreating) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "creating"
          toJSON (PostServersResponseBody201ServerImageStatusEnumStringUnavailable) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "unavailable"
instance Data.Aeson.FromJSON PostServersResponseBody201ServerImageStatus
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "available")
                                          then PostServersResponseBody201ServerImageStatusEnumStringAvailable
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "creating")
                                                then PostServersResponseBody201ServerImageStatusEnumStringCreating
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "unavailable")
                                                      then PostServersResponseBody201ServerImageStatusEnumStringUnavailable
                                                      else PostServersResponseBody201ServerImageStatusEnumOther val)
-- | Defines the enum schema PostServersResponseBody201ServerImageType
-- 
-- Type of the Image
data PostServersResponseBody201ServerImageType
    = PostServersResponseBody201ServerImageTypeEnumOther Data.Aeson.Types.Internal.Value
    | PostServersResponseBody201ServerImageTypeEnumTyped Data.Text.Internal.Text
    | PostServersResponseBody201ServerImageTypeEnumStringApp
    | PostServersResponseBody201ServerImageTypeEnumStringBackup
    | PostServersResponseBody201ServerImageTypeEnumStringSnapshot
    | PostServersResponseBody201ServerImageTypeEnumStringSystem
    | PostServersResponseBody201ServerImageTypeEnumStringTemporary
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerImageType
    where toJSON (PostServersResponseBody201ServerImageTypeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PostServersResponseBody201ServerImageTypeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PostServersResponseBody201ServerImageTypeEnumStringApp) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "app"
          toJSON (PostServersResponseBody201ServerImageTypeEnumStringBackup) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "backup"
          toJSON (PostServersResponseBody201ServerImageTypeEnumStringSnapshot) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "snapshot"
          toJSON (PostServersResponseBody201ServerImageTypeEnumStringSystem) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "system"
          toJSON (PostServersResponseBody201ServerImageTypeEnumStringTemporary) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "temporary"
instance Data.Aeson.FromJSON PostServersResponseBody201ServerImageType
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "app")
                                          then PostServersResponseBody201ServerImageTypeEnumStringApp
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "backup")
                                                then PostServersResponseBody201ServerImageTypeEnumStringBackup
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "snapshot")
                                                      then PostServersResponseBody201ServerImageTypeEnumStringSnapshot
                                                      else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "system")
                                                            then PostServersResponseBody201ServerImageTypeEnumStringSystem
                                                            else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "temporary")
                                                                  then PostServersResponseBody201ServerImageTypeEnumStringTemporary
                                                                  else PostServersResponseBody201ServerImageTypeEnumOther val)
-- | Defines the data type for the schema PostServersResponseBody201ServerIso
-- 
-- ISO Image that is attached to this Server. Null if no ISO is attached.
data PostServersResponseBody201ServerIso = PostServersResponseBody201ServerIso {
  -- | deprecated: ISO 8601 timestamp of deprecation, null if ISO is still available. After the deprecation time it will no longer be possible to attach the ISO to Servers.
  postServersResponseBody201ServerIsoDeprecated :: Data.Text.Internal.Text
  -- | description: Description of the ISO
  , postServersResponseBody201ServerIsoDescription :: Data.Text.Internal.Text
  -- | id: ID of the Resource
  , postServersResponseBody201ServerIsoId :: GHC.Integer.Type.Integer
  -- | name: Unique identifier of the ISO. Only set for public ISOs
  , postServersResponseBody201ServerIsoName :: Data.Text.Internal.Text
  -- | type: Type of the ISO
  , postServersResponseBody201ServerIsoType :: PostServersResponseBody201ServerIsoType
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerIso
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "deprecated" (postServersResponseBody201ServerIsoDeprecated obj) : (Data.Aeson..=) "description" (postServersResponseBody201ServerIsoDescription obj) : (Data.Aeson..=) "id" (postServersResponseBody201ServerIsoId obj) : (Data.Aeson..=) "name" (postServersResponseBody201ServerIsoName obj) : (Data.Aeson..=) "type" (postServersResponseBody201ServerIsoType obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "deprecated" (postServersResponseBody201ServerIsoDeprecated obj) GHC.Base.<> ((Data.Aeson..=) "description" (postServersResponseBody201ServerIsoDescription obj) GHC.Base.<> ((Data.Aeson..=) "id" (postServersResponseBody201ServerIsoId obj) GHC.Base.<> ((Data.Aeson..=) "name" (postServersResponseBody201ServerIsoName obj) GHC.Base.<> (Data.Aeson..=) "type" (postServersResponseBody201ServerIsoType obj)))))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ServerIso
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ServerIso" (\obj -> ((((GHC.Base.pure PostServersResponseBody201ServerIso GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deprecated")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "type"))
-- | Defines the enum schema PostServersResponseBody201ServerIsoType
-- 
-- Type of the ISO
data PostServersResponseBody201ServerIsoType
    = PostServersResponseBody201ServerIsoTypeEnumOther Data.Aeson.Types.Internal.Value
    | PostServersResponseBody201ServerIsoTypeEnumTyped Data.Text.Internal.Text
    | PostServersResponseBody201ServerIsoTypeEnumStringPrivate
    | PostServersResponseBody201ServerIsoTypeEnumStringPublic
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerIsoType
    where toJSON (PostServersResponseBody201ServerIsoTypeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PostServersResponseBody201ServerIsoTypeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PostServersResponseBody201ServerIsoTypeEnumStringPrivate) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "private"
          toJSON (PostServersResponseBody201ServerIsoTypeEnumStringPublic) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "public"
instance Data.Aeson.FromJSON PostServersResponseBody201ServerIsoType
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "private")
                                          then PostServersResponseBody201ServerIsoTypeEnumStringPrivate
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "public")
                                                then PostServersResponseBody201ServerIsoTypeEnumStringPublic
                                                else PostServersResponseBody201ServerIsoTypeEnumOther val)
-- | Defines the data type for the schema PostServersResponseBody201ServerLabels
-- 
-- User-defined labels (key-value pairs)
data PostServersResponseBody201ServerLabels = PostServersResponseBody201ServerLabels {
  
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerLabels
    where toJSON obj = Data.Aeson.object []
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "string" ("string" :: GHC.Base.String))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ServerLabels
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ServerLabels" (\obj -> GHC.Base.pure PostServersResponseBody201ServerLabels)
-- | Defines the data type for the schema PostServersResponseBody201ServerPlacement_group
-- 
-- 
data PostServersResponseBody201ServerPlacementGroup = PostServersResponseBody201ServerPlacementGroup {
  -- | created: Point in time when the Resource was created (in ISO-8601 format)
  postServersResponseBody201ServerPlacementGroupCreated :: Data.Text.Internal.Text
  -- | id: ID of the Resource
  , postServersResponseBody201ServerPlacementGroupId :: GHC.Integer.Type.Integer
  -- | labels: User-defined labels (key-value pairs)
  , postServersResponseBody201ServerPlacementGroupLabels :: PostServersResponseBody201ServerPlacementGroupLabels
  -- | name: Name of the Resource. Must be unique per Project.
  , postServersResponseBody201ServerPlacementGroupName :: Data.Text.Internal.Text
  -- | servers: Array of IDs of Servers that are part of this Placement Group
  , postServersResponseBody201ServerPlacementGroupServers :: ([] GHC.Integer.Type.Integer)
  -- | type: Type of the Placement Group
  , postServersResponseBody201ServerPlacementGroupType :: PostServersResponseBody201ServerPlacementGroupType
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerPlacementGroup
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "created" (postServersResponseBody201ServerPlacementGroupCreated obj) : (Data.Aeson..=) "id" (postServersResponseBody201ServerPlacementGroupId obj) : (Data.Aeson..=) "labels" (postServersResponseBody201ServerPlacementGroupLabels obj) : (Data.Aeson..=) "name" (postServersResponseBody201ServerPlacementGroupName obj) : (Data.Aeson..=) "servers" (postServersResponseBody201ServerPlacementGroupServers obj) : (Data.Aeson..=) "type" (postServersResponseBody201ServerPlacementGroupType obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "created" (postServersResponseBody201ServerPlacementGroupCreated obj) GHC.Base.<> ((Data.Aeson..=) "id" (postServersResponseBody201ServerPlacementGroupId obj) GHC.Base.<> ((Data.Aeson..=) "labels" (postServersResponseBody201ServerPlacementGroupLabels obj) GHC.Base.<> ((Data.Aeson..=) "name" (postServersResponseBody201ServerPlacementGroupName obj) GHC.Base.<> ((Data.Aeson..=) "servers" (postServersResponseBody201ServerPlacementGroupServers obj) GHC.Base.<> (Data.Aeson..=) "type" (postServersResponseBody201ServerPlacementGroupType obj))))))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ServerPlacementGroup
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ServerPlacementGroup" (\obj -> (((((GHC.Base.pure PostServersResponseBody201ServerPlacementGroup GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "labels")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "servers")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "type"))
-- | Defines the data type for the schema PostServersResponseBody201ServerPlacement_groupLabels
-- 
-- User-defined labels (key-value pairs)
data PostServersResponseBody201ServerPlacementGroupLabels = PostServersResponseBody201ServerPlacementGroupLabels {
  
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerPlacementGroupLabels
    where toJSON obj = Data.Aeson.object []
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "string" ("string" :: GHC.Base.String))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ServerPlacementGroupLabels
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ServerPlacementGroupLabels" (\obj -> GHC.Base.pure PostServersResponseBody201ServerPlacementGroupLabels)
-- | Defines the enum schema PostServersResponseBody201ServerPlacement_groupType
-- 
-- Type of the Placement Group
data PostServersResponseBody201ServerPlacementGroupType
    = PostServersResponseBody201ServerPlacementGroupTypeEnumOther Data.Aeson.Types.Internal.Value
    | PostServersResponseBody201ServerPlacementGroupTypeEnumTyped Data.Text.Internal.Text
    | PostServersResponseBody201ServerPlacementGroupTypeEnumStringSpread
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerPlacementGroupType
    where toJSON (PostServersResponseBody201ServerPlacementGroupTypeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PostServersResponseBody201ServerPlacementGroupTypeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PostServersResponseBody201ServerPlacementGroupTypeEnumStringSpread) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "spread"
instance Data.Aeson.FromJSON PostServersResponseBody201ServerPlacementGroupType
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "spread")
                                          then PostServersResponseBody201ServerPlacementGroupTypeEnumStringSpread
                                          else PostServersResponseBody201ServerPlacementGroupTypeEnumOther val)
-- | Defines the data type for the schema PostServersResponseBody201ServerPrivate_net
-- 
-- 
data PostServersResponseBody201ServerPrivateNet = PostServersResponseBody201ServerPrivateNet {
  -- | alias_ips
  postServersResponseBody201ServerPrivateNetAliasIps :: (GHC.Maybe.Maybe ([] Data.Text.Internal.Text))
  -- | ip
  , postServersResponseBody201ServerPrivateNetIp :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | mac_address
  , postServersResponseBody201ServerPrivateNetMacAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | network
  , postServersResponseBody201ServerPrivateNetNetwork :: (GHC.Maybe.Maybe GHC.Integer.Type.Integer)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerPrivateNet
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "alias_ips" (postServersResponseBody201ServerPrivateNetAliasIps obj) : (Data.Aeson..=) "ip" (postServersResponseBody201ServerPrivateNetIp obj) : (Data.Aeson..=) "mac_address" (postServersResponseBody201ServerPrivateNetMacAddress obj) : (Data.Aeson..=) "network" (postServersResponseBody201ServerPrivateNetNetwork obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "alias_ips" (postServersResponseBody201ServerPrivateNetAliasIps obj) GHC.Base.<> ((Data.Aeson..=) "ip" (postServersResponseBody201ServerPrivateNetIp obj) GHC.Base.<> ((Data.Aeson..=) "mac_address" (postServersResponseBody201ServerPrivateNetMacAddress obj) GHC.Base.<> (Data.Aeson..=) "network" (postServersResponseBody201ServerPrivateNetNetwork obj))))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ServerPrivateNet
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ServerPrivateNet" (\obj -> (((GHC.Base.pure PostServersResponseBody201ServerPrivateNet GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "alias_ips")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "ip")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "mac_address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "network"))
-- | Defines the data type for the schema PostServersResponseBody201ServerProtection
-- 
-- Protection configuration for the Server
data PostServersResponseBody201ServerProtection = PostServersResponseBody201ServerProtection {
  -- | delete: If true, prevents the Server from being deleted
  postServersResponseBody201ServerProtectionDelete :: GHC.Types.Bool
  -- | rebuild: If true, prevents the Server from being rebuilt
  , postServersResponseBody201ServerProtectionRebuild :: GHC.Types.Bool
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerProtection
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "delete" (postServersResponseBody201ServerProtectionDelete obj) : (Data.Aeson..=) "rebuild" (postServersResponseBody201ServerProtectionRebuild obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "delete" (postServersResponseBody201ServerProtectionDelete obj) GHC.Base.<> (Data.Aeson..=) "rebuild" (postServersResponseBody201ServerProtectionRebuild obj))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ServerProtection
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ServerProtection" (\obj -> (GHC.Base.pure PostServersResponseBody201ServerProtection GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "delete")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "rebuild"))
-- | Defines the data type for the schema PostServersResponseBody201ServerPublic_net
-- 
-- Public network information. The Server\'s IPv4 address can be found in \`public_net->ipv4->ip\`
data PostServersResponseBody201ServerPublicNet = PostServersResponseBody201ServerPublicNet {
  -- | firewalls: Firewalls applied to the public network interface of this Server
  postServersResponseBody201ServerPublicNetFirewalls :: (GHC.Maybe.Maybe ([] PostServersResponseBody201ServerPublicNetFirewalls))
  -- | floating_ips: IDs of Floating IPs assigned to this Server
  , postServersResponseBody201ServerPublicNetFloatingIps :: ([] GHC.Integer.Type.Integer)
  -- | ipv4: IP address (v4) and its reverse DNS entry of this Server
  , postServersResponseBody201ServerPublicNetIpv4 :: PostServersResponseBody201ServerPublicNetIpv4
  -- | ipv6: IPv6 network assigned to this Server and its reverse DNS entry
  , postServersResponseBody201ServerPublicNetIpv6 :: PostServersResponseBody201ServerPublicNetIpv6
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerPublicNet
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "firewalls" (postServersResponseBody201ServerPublicNetFirewalls obj) : (Data.Aeson..=) "floating_ips" (postServersResponseBody201ServerPublicNetFloatingIps obj) : (Data.Aeson..=) "ipv4" (postServersResponseBody201ServerPublicNetIpv4 obj) : (Data.Aeson..=) "ipv6" (postServersResponseBody201ServerPublicNetIpv6 obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "firewalls" (postServersResponseBody201ServerPublicNetFirewalls obj) GHC.Base.<> ((Data.Aeson..=) "floating_ips" (postServersResponseBody201ServerPublicNetFloatingIps obj) GHC.Base.<> ((Data.Aeson..=) "ipv4" (postServersResponseBody201ServerPublicNetIpv4 obj) GHC.Base.<> (Data.Aeson..=) "ipv6" (postServersResponseBody201ServerPublicNetIpv6 obj))))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ServerPublicNet
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ServerPublicNet" (\obj -> (((GHC.Base.pure PostServersResponseBody201ServerPublicNet GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "firewalls")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "floating_ips")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ipv4")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ipv6"))
-- | Defines the data type for the schema PostServersResponseBody201ServerPublic_netFirewalls
-- 
-- 
data PostServersResponseBody201ServerPublicNetFirewalls = PostServersResponseBody201ServerPublicNetFirewalls {
  -- | id: ID of the Resource
  postServersResponseBody201ServerPublicNetFirewallsId :: (GHC.Maybe.Maybe GHC.Integer.Type.Integer)
  -- | status: Status of the Firewall on the Server
  , postServersResponseBody201ServerPublicNetFirewallsStatus :: (GHC.Maybe.Maybe PostServersResponseBody201ServerPublicNetFirewallsStatus)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerPublicNetFirewalls
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "id" (postServersResponseBody201ServerPublicNetFirewallsId obj) : (Data.Aeson..=) "status" (postServersResponseBody201ServerPublicNetFirewallsStatus obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "id" (postServersResponseBody201ServerPublicNetFirewallsId obj) GHC.Base.<> (Data.Aeson..=) "status" (postServersResponseBody201ServerPublicNetFirewallsStatus obj))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ServerPublicNetFirewalls
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ServerPublicNetFirewalls" (\obj -> (GHC.Base.pure PostServersResponseBody201ServerPublicNetFirewalls GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "status"))
-- | Defines the enum schema PostServersResponseBody201ServerPublic_netFirewallsStatus
-- 
-- Status of the Firewall on the Server
data PostServersResponseBody201ServerPublicNetFirewallsStatus
    = PostServersResponseBody201ServerPublicNetFirewallsStatusEnumOther Data.Aeson.Types.Internal.Value
    | PostServersResponseBody201ServerPublicNetFirewallsStatusEnumTyped Data.Text.Internal.Text
    | PostServersResponseBody201ServerPublicNetFirewallsStatusEnumStringApplied
    | PostServersResponseBody201ServerPublicNetFirewallsStatusEnumStringPending
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerPublicNetFirewallsStatus
    where toJSON (PostServersResponseBody201ServerPublicNetFirewallsStatusEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PostServersResponseBody201ServerPublicNetFirewallsStatusEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PostServersResponseBody201ServerPublicNetFirewallsStatusEnumStringApplied) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "applied"
          toJSON (PostServersResponseBody201ServerPublicNetFirewallsStatusEnumStringPending) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "pending"
instance Data.Aeson.FromJSON PostServersResponseBody201ServerPublicNetFirewallsStatus
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "applied")
                                          then PostServersResponseBody201ServerPublicNetFirewallsStatusEnumStringApplied
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "pending")
                                                then PostServersResponseBody201ServerPublicNetFirewallsStatusEnumStringPending
                                                else PostServersResponseBody201ServerPublicNetFirewallsStatusEnumOther val)
-- | Defines the data type for the schema PostServersResponseBody201ServerPublic_netIpv4
-- 
-- IP address (v4) and its reverse DNS entry of this Server
data PostServersResponseBody201ServerPublicNetIpv4 = PostServersResponseBody201ServerPublicNetIpv4 {
  -- | blocked: If the IP is blocked by our anti abuse dept
  postServersResponseBody201ServerPublicNetIpv4Blocked :: GHC.Types.Bool
  -- | dns_ptr: Reverse DNS PTR entry for the IPv4 addresses of this Server
  , postServersResponseBody201ServerPublicNetIpv4DnsPtr :: Data.Text.Internal.Text
  -- | ip: IP address (v4) of this Server
  , postServersResponseBody201ServerPublicNetIpv4Ip :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerPublicNetIpv4
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "blocked" (postServersResponseBody201ServerPublicNetIpv4Blocked obj) : (Data.Aeson..=) "dns_ptr" (postServersResponseBody201ServerPublicNetIpv4DnsPtr obj) : (Data.Aeson..=) "ip" (postServersResponseBody201ServerPublicNetIpv4Ip obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "blocked" (postServersResponseBody201ServerPublicNetIpv4Blocked obj) GHC.Base.<> ((Data.Aeson..=) "dns_ptr" (postServersResponseBody201ServerPublicNetIpv4DnsPtr obj) GHC.Base.<> (Data.Aeson..=) "ip" (postServersResponseBody201ServerPublicNetIpv4Ip obj)))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ServerPublicNetIpv4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ServerPublicNetIpv4" (\obj -> ((GHC.Base.pure PostServersResponseBody201ServerPublicNetIpv4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "blocked")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "dns_ptr")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ip"))
-- | Defines the data type for the schema PostServersResponseBody201ServerPublic_netIpv6
-- 
-- IPv6 network assigned to this Server and its reverse DNS entry
data PostServersResponseBody201ServerPublicNetIpv6 = PostServersResponseBody201ServerPublicNetIpv6 {
  -- | blocked: If the IP is blocked by our anti abuse dept
  postServersResponseBody201ServerPublicNetIpv6Blocked :: GHC.Types.Bool
  -- | dns_ptr: Reverse DNS PTR entries for the IPv6 addresses of this Server, \`null\` by default
  , postServersResponseBody201ServerPublicNetIpv6DnsPtr :: ([] PostServersResponseBody201ServerPublicNetIpv6DnsPtr)
  -- | ip: IP address (v4) of this Server
  , postServersResponseBody201ServerPublicNetIpv6Ip :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerPublicNetIpv6
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "blocked" (postServersResponseBody201ServerPublicNetIpv6Blocked obj) : (Data.Aeson..=) "dns_ptr" (postServersResponseBody201ServerPublicNetIpv6DnsPtr obj) : (Data.Aeson..=) "ip" (postServersResponseBody201ServerPublicNetIpv6Ip obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "blocked" (postServersResponseBody201ServerPublicNetIpv6Blocked obj) GHC.Base.<> ((Data.Aeson..=) "dns_ptr" (postServersResponseBody201ServerPublicNetIpv6DnsPtr obj) GHC.Base.<> (Data.Aeson..=) "ip" (postServersResponseBody201ServerPublicNetIpv6Ip obj)))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ServerPublicNetIpv6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ServerPublicNetIpv6" (\obj -> ((GHC.Base.pure PostServersResponseBody201ServerPublicNetIpv6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "blocked")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "dns_ptr")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ip"))
-- | Defines the data type for the schema PostServersResponseBody201ServerPublic_netIpv6Dns_ptr
-- 
-- 
data PostServersResponseBody201ServerPublicNetIpv6DnsPtr = PostServersResponseBody201ServerPublicNetIpv6DnsPtr {
  -- | dns_ptr: DNS pointer for the specific IP address
  postServersResponseBody201ServerPublicNetIpv6DnsPtrDnsPtr :: Data.Text.Internal.Text
  -- | ip: Single IPv6 address of this Server for which the reverse DNS entry has been set up
  , postServersResponseBody201ServerPublicNetIpv6DnsPtrIp :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerPublicNetIpv6DnsPtr
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "dns_ptr" (postServersResponseBody201ServerPublicNetIpv6DnsPtrDnsPtr obj) : (Data.Aeson..=) "ip" (postServersResponseBody201ServerPublicNetIpv6DnsPtrIp obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "dns_ptr" (postServersResponseBody201ServerPublicNetIpv6DnsPtrDnsPtr obj) GHC.Base.<> (Data.Aeson..=) "ip" (postServersResponseBody201ServerPublicNetIpv6DnsPtrIp obj))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ServerPublicNetIpv6DnsPtr
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ServerPublicNetIpv6DnsPtr" (\obj -> (GHC.Base.pure PostServersResponseBody201ServerPublicNetIpv6DnsPtr GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "dns_ptr")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ip"))
-- | Defines the data type for the schema PostServersResponseBody201ServerServer_type
-- 
-- Type of Server - determines how much ram, disk and cpu a Server has
data PostServersResponseBody201ServerServerType = PostServersResponseBody201ServerServerType {
  -- | cores: Number of cpu cores a Server of this type will have
  postServersResponseBody201ServerServerTypeCores :: GHC.Types.Double
  -- | cpu_type: Type of cpu
  , postServersResponseBody201ServerServerTypeCpuType :: PostServersResponseBody201ServerServerTypeCpuType
  -- | deprecated: True if Server type is deprecated
  , postServersResponseBody201ServerServerTypeDeprecated :: GHC.Types.Bool
  -- | description: Description of the Server type
  , postServersResponseBody201ServerServerTypeDescription :: Data.Text.Internal.Text
  -- | disk: Disk size a Server of this type will have in GB
  , postServersResponseBody201ServerServerTypeDisk :: GHC.Types.Double
  -- | id: ID of the Server type
  , postServersResponseBody201ServerServerTypeId :: GHC.Integer.Type.Integer
  -- | memory: Memory a Server of this type will have in GB
  , postServersResponseBody201ServerServerTypeMemory :: GHC.Types.Double
  -- | name: Unique identifier of the Server type
  , postServersResponseBody201ServerServerTypeName :: Data.Text.Internal.Text
  -- | prices: Prices in different Locations
  , postServersResponseBody201ServerServerTypePrices :: ([] PostServersResponseBody201ServerServerTypePrices)
  -- | storage_type: Type of Server boot drive. Local has higher speed. Network has better availability.
  , postServersResponseBody201ServerServerTypeStorageType :: PostServersResponseBody201ServerServerTypeStorageType
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerServerType
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "cores" (postServersResponseBody201ServerServerTypeCores obj) : (Data.Aeson..=) "cpu_type" (postServersResponseBody201ServerServerTypeCpuType obj) : (Data.Aeson..=) "deprecated" (postServersResponseBody201ServerServerTypeDeprecated obj) : (Data.Aeson..=) "description" (postServersResponseBody201ServerServerTypeDescription obj) : (Data.Aeson..=) "disk" (postServersResponseBody201ServerServerTypeDisk obj) : (Data.Aeson..=) "id" (postServersResponseBody201ServerServerTypeId obj) : (Data.Aeson..=) "memory" (postServersResponseBody201ServerServerTypeMemory obj) : (Data.Aeson..=) "name" (postServersResponseBody201ServerServerTypeName obj) : (Data.Aeson..=) "prices" (postServersResponseBody201ServerServerTypePrices obj) : (Data.Aeson..=) "storage_type" (postServersResponseBody201ServerServerTypeStorageType obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "cores" (postServersResponseBody201ServerServerTypeCores obj) GHC.Base.<> ((Data.Aeson..=) "cpu_type" (postServersResponseBody201ServerServerTypeCpuType obj) GHC.Base.<> ((Data.Aeson..=) "deprecated" (postServersResponseBody201ServerServerTypeDeprecated obj) GHC.Base.<> ((Data.Aeson..=) "description" (postServersResponseBody201ServerServerTypeDescription obj) GHC.Base.<> ((Data.Aeson..=) "disk" (postServersResponseBody201ServerServerTypeDisk obj) GHC.Base.<> ((Data.Aeson..=) "id" (postServersResponseBody201ServerServerTypeId obj) GHC.Base.<> ((Data.Aeson..=) "memory" (postServersResponseBody201ServerServerTypeMemory obj) GHC.Base.<> ((Data.Aeson..=) "name" (postServersResponseBody201ServerServerTypeName obj) GHC.Base.<> ((Data.Aeson..=) "prices" (postServersResponseBody201ServerServerTypePrices obj) GHC.Base.<> (Data.Aeson..=) "storage_type" (postServersResponseBody201ServerServerTypeStorageType obj))))))))))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ServerServerType
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ServerServerType" (\obj -> (((((((((GHC.Base.pure PostServersResponseBody201ServerServerType GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "cores")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "cpu_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deprecated")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "disk")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "memory")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "prices")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "storage_type"))
-- | Defines the enum schema PostServersResponseBody201ServerServer_typeCpu_type
-- 
-- Type of cpu
data PostServersResponseBody201ServerServerTypeCpuType
    = PostServersResponseBody201ServerServerTypeCpuTypeEnumOther Data.Aeson.Types.Internal.Value
    | PostServersResponseBody201ServerServerTypeCpuTypeEnumTyped Data.Text.Internal.Text
    | PostServersResponseBody201ServerServerTypeCpuTypeEnumStringDedicated
    | PostServersResponseBody201ServerServerTypeCpuTypeEnumStringShared
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerServerTypeCpuType
    where toJSON (PostServersResponseBody201ServerServerTypeCpuTypeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PostServersResponseBody201ServerServerTypeCpuTypeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PostServersResponseBody201ServerServerTypeCpuTypeEnumStringDedicated) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "dedicated"
          toJSON (PostServersResponseBody201ServerServerTypeCpuTypeEnumStringShared) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "shared"
instance Data.Aeson.FromJSON PostServersResponseBody201ServerServerTypeCpuType
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "dedicated")
                                          then PostServersResponseBody201ServerServerTypeCpuTypeEnumStringDedicated
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "shared")
                                                then PostServersResponseBody201ServerServerTypeCpuTypeEnumStringShared
                                                else PostServersResponseBody201ServerServerTypeCpuTypeEnumOther val)
-- | Defines the data type for the schema PostServersResponseBody201ServerServer_typePrices
-- 
-- 
data PostServersResponseBody201ServerServerTypePrices = PostServersResponseBody201ServerServerTypePrices {
  -- | location: Name of the Location the price is for
  postServersResponseBody201ServerServerTypePricesLocation :: Data.Text.Internal.Text
  -- | price_hourly: Hourly costs for a Server type in this Location
  , postServersResponseBody201ServerServerTypePricesPriceHourly :: PostServersResponseBody201ServerServerTypePricesPriceHourly
  -- | price_monthly: Monthly costs for a Server type in this Location
  , postServersResponseBody201ServerServerTypePricesPriceMonthly :: PostServersResponseBody201ServerServerTypePricesPriceMonthly
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerServerTypePrices
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "location" (postServersResponseBody201ServerServerTypePricesLocation obj) : (Data.Aeson..=) "price_hourly" (postServersResponseBody201ServerServerTypePricesPriceHourly obj) : (Data.Aeson..=) "price_monthly" (postServersResponseBody201ServerServerTypePricesPriceMonthly obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "location" (postServersResponseBody201ServerServerTypePricesLocation obj) GHC.Base.<> ((Data.Aeson..=) "price_hourly" (postServersResponseBody201ServerServerTypePricesPriceHourly obj) GHC.Base.<> (Data.Aeson..=) "price_monthly" (postServersResponseBody201ServerServerTypePricesPriceMonthly obj)))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ServerServerTypePrices
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ServerServerTypePrices" (\obj -> ((GHC.Base.pure PostServersResponseBody201ServerServerTypePrices GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "location")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "price_hourly")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "price_monthly"))
-- | Defines the data type for the schema PostServersResponseBody201ServerServer_typePricesPrice_hourly
-- 
-- Hourly costs for a Server type in this Location
data PostServersResponseBody201ServerServerTypePricesPriceHourly = PostServersResponseBody201ServerServerTypePricesPriceHourly {
  -- | gross: Price with VAT added
  postServersResponseBody201ServerServerTypePricesPriceHourlyGross :: Data.Text.Internal.Text
  -- | net: Price without VAT
  , postServersResponseBody201ServerServerTypePricesPriceHourlyNet :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerServerTypePricesPriceHourly
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "gross" (postServersResponseBody201ServerServerTypePricesPriceHourlyGross obj) : (Data.Aeson..=) "net" (postServersResponseBody201ServerServerTypePricesPriceHourlyNet obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "gross" (postServersResponseBody201ServerServerTypePricesPriceHourlyGross obj) GHC.Base.<> (Data.Aeson..=) "net" (postServersResponseBody201ServerServerTypePricesPriceHourlyNet obj))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ServerServerTypePricesPriceHourly
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ServerServerTypePricesPriceHourly" (\obj -> (GHC.Base.pure PostServersResponseBody201ServerServerTypePricesPriceHourly GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "gross")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "net"))
-- | Defines the data type for the schema PostServersResponseBody201ServerServer_typePricesPrice_monthly
-- 
-- Monthly costs for a Server type in this Location
data PostServersResponseBody201ServerServerTypePricesPriceMonthly = PostServersResponseBody201ServerServerTypePricesPriceMonthly {
  -- | gross: Price with VAT added
  postServersResponseBody201ServerServerTypePricesPriceMonthlyGross :: Data.Text.Internal.Text
  -- | net: Price without VAT
  , postServersResponseBody201ServerServerTypePricesPriceMonthlyNet :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerServerTypePricesPriceMonthly
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "gross" (postServersResponseBody201ServerServerTypePricesPriceMonthlyGross obj) : (Data.Aeson..=) "net" (postServersResponseBody201ServerServerTypePricesPriceMonthlyNet obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "gross" (postServersResponseBody201ServerServerTypePricesPriceMonthlyGross obj) GHC.Base.<> (Data.Aeson..=) "net" (postServersResponseBody201ServerServerTypePricesPriceMonthlyNet obj))
instance Data.Aeson.Types.FromJSON.FromJSON PostServersResponseBody201ServerServerTypePricesPriceMonthly
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostServersResponseBody201ServerServerTypePricesPriceMonthly" (\obj -> (GHC.Base.pure PostServersResponseBody201ServerServerTypePricesPriceMonthly GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "gross")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "net"))
-- | Defines the enum schema PostServersResponseBody201ServerServer_typeStorage_type
-- 
-- Type of Server boot drive. Local has higher speed. Network has better availability.
data PostServersResponseBody201ServerServerTypeStorageType
    = PostServersResponseBody201ServerServerTypeStorageTypeEnumOther Data.Aeson.Types.Internal.Value
    | PostServersResponseBody201ServerServerTypeStorageTypeEnumTyped Data.Text.Internal.Text
    | PostServersResponseBody201ServerServerTypeStorageTypeEnumStringLocal
    | PostServersResponseBody201ServerServerTypeStorageTypeEnumStringNetwork
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerServerTypeStorageType
    where toJSON (PostServersResponseBody201ServerServerTypeStorageTypeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PostServersResponseBody201ServerServerTypeStorageTypeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PostServersResponseBody201ServerServerTypeStorageTypeEnumStringLocal) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "local"
          toJSON (PostServersResponseBody201ServerServerTypeStorageTypeEnumStringNetwork) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "network"
instance Data.Aeson.FromJSON PostServersResponseBody201ServerServerTypeStorageType
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "local")
                                          then PostServersResponseBody201ServerServerTypeStorageTypeEnumStringLocal
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "network")
                                                then PostServersResponseBody201ServerServerTypeStorageTypeEnumStringNetwork
                                                else PostServersResponseBody201ServerServerTypeStorageTypeEnumOther val)
-- | Defines the enum schema PostServersResponseBody201ServerStatus
-- 
-- Status of the Server
data PostServersResponseBody201ServerStatus
    = PostServersResponseBody201ServerStatusEnumOther Data.Aeson.Types.Internal.Value
    | PostServersResponseBody201ServerStatusEnumTyped Data.Text.Internal.Text
    | PostServersResponseBody201ServerStatusEnumStringDeleting
    | PostServersResponseBody201ServerStatusEnumStringInitializing
    | PostServersResponseBody201ServerStatusEnumStringMigrating
    | PostServersResponseBody201ServerStatusEnumStringOff
    | PostServersResponseBody201ServerStatusEnumStringRebuilding
    | PostServersResponseBody201ServerStatusEnumStringRunning
    | PostServersResponseBody201ServerStatusEnumStringStarting
    | PostServersResponseBody201ServerStatusEnumStringStopping
    | PostServersResponseBody201ServerStatusEnumStringUnknown
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON PostServersResponseBody201ServerStatus
    where toJSON (PostServersResponseBody201ServerStatusEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PostServersResponseBody201ServerStatusEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (PostServersResponseBody201ServerStatusEnumStringDeleting) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "deleting"
          toJSON (PostServersResponseBody201ServerStatusEnumStringInitializing) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "initializing"
          toJSON (PostServersResponseBody201ServerStatusEnumStringMigrating) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "migrating"
          toJSON (PostServersResponseBody201ServerStatusEnumStringOff) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "off"
          toJSON (PostServersResponseBody201ServerStatusEnumStringRebuilding) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "rebuilding"
          toJSON (PostServersResponseBody201ServerStatusEnumStringRunning) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "running"
          toJSON (PostServersResponseBody201ServerStatusEnumStringStarting) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "starting"
          toJSON (PostServersResponseBody201ServerStatusEnumStringStopping) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "stopping"
          toJSON (PostServersResponseBody201ServerStatusEnumStringUnknown) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "unknown"
instance Data.Aeson.FromJSON PostServersResponseBody201ServerStatus
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "deleting")
                                          then PostServersResponseBody201ServerStatusEnumStringDeleting
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "initializing")
                                                then PostServersResponseBody201ServerStatusEnumStringInitializing
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "migrating")
                                                      then PostServersResponseBody201ServerStatusEnumStringMigrating
                                                      else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "off")
                                                            then PostServersResponseBody201ServerStatusEnumStringOff
                                                            else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "rebuilding")
                                                                  then PostServersResponseBody201ServerStatusEnumStringRebuilding
                                                                  else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "running")
                                                                        then PostServersResponseBody201ServerStatusEnumStringRunning
                                                                        else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "starting")
                                                                              then PostServersResponseBody201ServerStatusEnumStringStarting
                                                                              else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "stopping")
                                                                                    then PostServersResponseBody201ServerStatusEnumStringStopping
                                                                                    else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "unknown")
                                                                                          then PostServersResponseBody201ServerStatusEnumStringUnknown
                                                                                          else PostServersResponseBody201ServerStatusEnumOther val)
