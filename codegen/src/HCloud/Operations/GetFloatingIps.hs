-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE DeriveGeneric #-}

-- | Contains the different functions to run the operation getFloatingIps
module HCloud.Operations.GetFloatingIps where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Either
import qualified Data.Functor
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Generics
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified HCloud.Common
import HCloud.Types

-- | > GET /floating_ips
-- 
-- Returns all Floating IP objects.
getFloatingIps :: forall m s . (HCloud.Common.MonadHTTP m, HCloud.Common.SecurityScheme s) => HCloud.Common.Configuration s  -- ^ The configuration to use in the request
  -> GHC.Maybe.Maybe Data.Text.Internal.Text                                                                                    -- ^ name: Can be used to filter Floating IPs by their name. The response will only contain the Floating IP matching the specified name.
  -> GHC.Maybe.Maybe Data.Text.Internal.Text                                                                                    -- ^ label_selector: Can be used to filter Floating IPs by labels. The response will only contain Floating IPs matching the label selector.
  -> GHC.Maybe.Maybe Data.Text.Internal.Text                                                                                    -- ^ sort: Can be used multiple times. Choices id id:asc id:desc created created:asc created:desc
  -> m (Data.Either.Either Network.HTTP.Client.Types.HttpException (Network.HTTP.Client.Types.Response GetFloatingIpsResponse)) -- ^ Monad containing the result of the operation
getFloatingIps config
               name
               labelSelector
               sort = GHC.Base.fmap (GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either GetFloatingIpsResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetFloatingIpsResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                            GetFloatingIpsResponseBody200)
                                                                                                                                                                              | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0)) (HCloud.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack "/floating_ips") ((Data.Text.pack "name",
                                                                                                                                                                                                                                                                                                                                                                                                                       HCloud.Common.stringifyModel Data.Functor.<$> name) : ((Data.Text.pack "label_selector",
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                HCloud.Common.stringifyModel Data.Functor.<$> labelSelector) : ((Data.Text.pack "sort",
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  HCloud.Common.stringifyModel Data.Functor.<$> sort) : []))))
-- | > GET /floating_ips
-- 
-- The same as 'getFloatingIps' but returns the raw 'Data.ByteString.Char8.ByteString'
getFloatingIpsRaw :: forall m s . (HCloud.Common.MonadHTTP m,
                                   HCloud.Common.SecurityScheme s) =>
                     HCloud.Common.Configuration s ->
                     GHC.Maybe.Maybe Data.Text.Internal.Text ->
                     GHC.Maybe.Maybe Data.Text.Internal.Text ->
                     GHC.Maybe.Maybe Data.Text.Internal.Text ->
                     m (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                           (Network.HTTP.Client.Types.Response Data.ByteString.Internal.ByteString))
getFloatingIpsRaw config
                  name
                  labelSelector
                  sort = GHC.Base.id (HCloud.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack "/floating_ips") ((Data.Text.pack "name",
                                                                                                                                                                           HCloud.Common.stringifyModel Data.Functor.<$> name) : ((Data.Text.pack "label_selector",
                                                                                                                                                                                                                                    HCloud.Common.stringifyModel Data.Functor.<$> labelSelector) : ((Data.Text.pack "sort",
                                                                                                                                                                                                                                                                                                      HCloud.Common.stringifyModel Data.Functor.<$> sort) : []))))
-- | > GET /floating_ips
-- 
-- Monadic version of 'getFloatingIps' (use with 'HCloud.Common.runWithConfiguration')
getFloatingIpsM :: forall m s . (HCloud.Common.MonadHTTP m,
                                 HCloud.Common.SecurityScheme s) =>
                   GHC.Maybe.Maybe Data.Text.Internal.Text ->
                   GHC.Maybe.Maybe Data.Text.Internal.Text ->
                   GHC.Maybe.Maybe Data.Text.Internal.Text ->
                   Control.Monad.Trans.Reader.ReaderT (HCloud.Common.Configuration s)
                                                      m
                                                      (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                                                          (Network.HTTP.Client.Types.Response GetFloatingIpsResponse))
getFloatingIpsM name
                labelSelector
                sort = GHC.Base.fmap (GHC.Base.fmap (\response_2 -> GHC.Base.fmap (Data.Either.either GetFloatingIpsResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetFloatingIpsResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                             GetFloatingIpsResponseBody200)
                                                                                                                                                                               | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_2) response_2)) (HCloud.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack "/floating_ips") ((Data.Text.pack "name",
                                                                                                                                                                                                                                                                                                                                                                                                                  HCloud.Common.stringifyModel Data.Functor.<$> name) : ((Data.Text.pack "label_selector",
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           HCloud.Common.stringifyModel Data.Functor.<$> labelSelector) : ((Data.Text.pack "sort",
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             HCloud.Common.stringifyModel Data.Functor.<$> sort) : []))))
-- | > GET /floating_ips
-- 
-- Monadic version of 'getFloatingIpsRaw' (use with 'HCloud.Common.runWithConfiguration')
getFloatingIpsRawM :: forall m s . (HCloud.Common.MonadHTTP m,
                                    HCloud.Common.SecurityScheme s) =>
                      GHC.Maybe.Maybe Data.Text.Internal.Text ->
                      GHC.Maybe.Maybe Data.Text.Internal.Text ->
                      GHC.Maybe.Maybe Data.Text.Internal.Text ->
                      Control.Monad.Trans.Reader.ReaderT (HCloud.Common.Configuration s)
                                                         m
                                                         (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                                                             (Network.HTTP.Client.Types.Response Data.ByteString.Internal.ByteString))
getFloatingIpsRawM name
                   labelSelector
                   sort = GHC.Base.id (HCloud.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") (Data.Text.pack "/floating_ips") ((Data.Text.pack "name",
                                                                                                                                                                      HCloud.Common.stringifyModel Data.Functor.<$> name) : ((Data.Text.pack "label_selector",
                                                                                                                                                                                                                               HCloud.Common.stringifyModel Data.Functor.<$> labelSelector) : ((Data.Text.pack "sort",
                                                                                                                                                                                                                                                                                                 HCloud.Common.stringifyModel Data.Functor.<$> sort) : []))))
-- | Represents a response of the operation 'getFloatingIps'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'GetFloatingIpsResponseError' is used.
data GetFloatingIpsResponse =                                
   GetFloatingIpsResponseError GHC.Base.String               -- ^ Means either no matching case available or a parse error
  | GetFloatingIpsResponse200 GetFloatingIpsResponseBody200  -- ^ The \`floating_ips\` key in the reply contains an array of Floating IP objects with this structure
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the data type for the schema GetFloatingIpsResponseBody200
-- 
-- 
data GetFloatingIpsResponseBody200 = GetFloatingIpsResponseBody200 {
  -- | floating_ips
  getFloatingIpsResponseBody200FloatingIps :: ([] GetFloatingIpsResponseBody200FloatingIps)
  -- | meta
  , getFloatingIpsResponseBody200Meta :: (GHC.Maybe.Maybe GetFloatingIpsResponseBody200Meta)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFloatingIpsResponseBody200
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "floating_ips" (getFloatingIpsResponseBody200FloatingIps obj) : (Data.Aeson..=) "meta" (getFloatingIpsResponseBody200Meta obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "floating_ips" (getFloatingIpsResponseBody200FloatingIps obj) GHC.Base.<> (Data.Aeson..=) "meta" (getFloatingIpsResponseBody200Meta obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetFloatingIpsResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFloatingIpsResponseBody200" (\obj -> (GHC.Base.pure GetFloatingIpsResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "floating_ips")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "meta"))
-- | Defines the data type for the schema GetFloatingIpsResponseBody200Floating_ips
-- 
-- 
data GetFloatingIpsResponseBody200FloatingIps = GetFloatingIpsResponseBody200FloatingIps {
  -- | blocked: Whether the IP is blocked
  getFloatingIpsResponseBody200FloatingIpsBlocked :: GHC.Types.Bool
  -- | created: Point in time when the Resource was created (in ISO-8601 format)
  , getFloatingIpsResponseBody200FloatingIpsCreated :: Data.Text.Internal.Text
  -- | description: Description of the Resource
  , getFloatingIpsResponseBody200FloatingIpsDescription :: Data.Text.Internal.Text
  -- | dns_ptr: Array of reverse DNS entries
  , getFloatingIpsResponseBody200FloatingIpsDnsPtr :: ([] GetFloatingIpsResponseBody200FloatingIpsDnsPtr)
  -- | home_location: Location the Floating IP was created in. Routing is optimized for this Location.
  , getFloatingIpsResponseBody200FloatingIpsHomeLocation :: GetFloatingIpsResponseBody200FloatingIpsHomeLocation
  -- | id: ID of the Resource
  , getFloatingIpsResponseBody200FloatingIpsId :: GHC.Integer.Type.Integer
  -- | ip: IP address
  , getFloatingIpsResponseBody200FloatingIpsIp :: Data.Text.Internal.Text
  -- | labels: User-defined labels (key-value pairs)
  , getFloatingIpsResponseBody200FloatingIpsLabels :: GetFloatingIpsResponseBody200FloatingIpsLabels
  -- | name: Name of the Resource. Must be unique per Project.
  , getFloatingIpsResponseBody200FloatingIpsName :: Data.Text.Internal.Text
  -- | protection: Protection configuration for the Resource
  , getFloatingIpsResponseBody200FloatingIpsProtection :: GetFloatingIpsResponseBody200FloatingIpsProtection
  -- | server: ID of the Server the Floating IP is assigned to, null if it is not assigned at all
  , getFloatingIpsResponseBody200FloatingIpsServer :: GHC.Integer.Type.Integer
  -- | type: Type of the Floating IP
  , getFloatingIpsResponseBody200FloatingIpsType :: GetFloatingIpsResponseBody200FloatingIpsType
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFloatingIpsResponseBody200FloatingIps
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "blocked" (getFloatingIpsResponseBody200FloatingIpsBlocked obj) : (Data.Aeson..=) "created" (getFloatingIpsResponseBody200FloatingIpsCreated obj) : (Data.Aeson..=) "description" (getFloatingIpsResponseBody200FloatingIpsDescription obj) : (Data.Aeson..=) "dns_ptr" (getFloatingIpsResponseBody200FloatingIpsDnsPtr obj) : (Data.Aeson..=) "home_location" (getFloatingIpsResponseBody200FloatingIpsHomeLocation obj) : (Data.Aeson..=) "id" (getFloatingIpsResponseBody200FloatingIpsId obj) : (Data.Aeson..=) "ip" (getFloatingIpsResponseBody200FloatingIpsIp obj) : (Data.Aeson..=) "labels" (getFloatingIpsResponseBody200FloatingIpsLabels obj) : (Data.Aeson..=) "name" (getFloatingIpsResponseBody200FloatingIpsName obj) : (Data.Aeson..=) "protection" (getFloatingIpsResponseBody200FloatingIpsProtection obj) : (Data.Aeson..=) "server" (getFloatingIpsResponseBody200FloatingIpsServer obj) : (Data.Aeson..=) "type" (getFloatingIpsResponseBody200FloatingIpsType obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "blocked" (getFloatingIpsResponseBody200FloatingIpsBlocked obj) GHC.Base.<> ((Data.Aeson..=) "created" (getFloatingIpsResponseBody200FloatingIpsCreated obj) GHC.Base.<> ((Data.Aeson..=) "description" (getFloatingIpsResponseBody200FloatingIpsDescription obj) GHC.Base.<> ((Data.Aeson..=) "dns_ptr" (getFloatingIpsResponseBody200FloatingIpsDnsPtr obj) GHC.Base.<> ((Data.Aeson..=) "home_location" (getFloatingIpsResponseBody200FloatingIpsHomeLocation obj) GHC.Base.<> ((Data.Aeson..=) "id" (getFloatingIpsResponseBody200FloatingIpsId obj) GHC.Base.<> ((Data.Aeson..=) "ip" (getFloatingIpsResponseBody200FloatingIpsIp obj) GHC.Base.<> ((Data.Aeson..=) "labels" (getFloatingIpsResponseBody200FloatingIpsLabels obj) GHC.Base.<> ((Data.Aeson..=) "name" (getFloatingIpsResponseBody200FloatingIpsName obj) GHC.Base.<> ((Data.Aeson..=) "protection" (getFloatingIpsResponseBody200FloatingIpsProtection obj) GHC.Base.<> ((Data.Aeson..=) "server" (getFloatingIpsResponseBody200FloatingIpsServer obj) GHC.Base.<> (Data.Aeson..=) "type" (getFloatingIpsResponseBody200FloatingIpsType obj))))))))))))
instance Data.Aeson.Types.FromJSON.FromJSON GetFloatingIpsResponseBody200FloatingIps
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFloatingIpsResponseBody200FloatingIps" (\obj -> (((((((((((GHC.Base.pure GetFloatingIpsResponseBody200FloatingIps GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "blocked")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "dns_ptr")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "home_location")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ip")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "labels")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "protection")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "server")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "type"))
-- | Defines the data type for the schema GetFloatingIpsResponseBody200Floating_ipsDns_ptr
-- 
-- 
data GetFloatingIpsResponseBody200FloatingIpsDnsPtr = GetFloatingIpsResponseBody200FloatingIpsDnsPtr {
  -- | dns_ptr: DNS pointer for the specific IP address
  getFloatingIpsResponseBody200FloatingIpsDnsPtrDnsPtr :: Data.Text.Internal.Text
  -- | ip: Single IPv4 or IPv6 address
  , getFloatingIpsResponseBody200FloatingIpsDnsPtrIp :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFloatingIpsResponseBody200FloatingIpsDnsPtr
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "dns_ptr" (getFloatingIpsResponseBody200FloatingIpsDnsPtrDnsPtr obj) : (Data.Aeson..=) "ip" (getFloatingIpsResponseBody200FloatingIpsDnsPtrIp obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "dns_ptr" (getFloatingIpsResponseBody200FloatingIpsDnsPtrDnsPtr obj) GHC.Base.<> (Data.Aeson..=) "ip" (getFloatingIpsResponseBody200FloatingIpsDnsPtrIp obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetFloatingIpsResponseBody200FloatingIpsDnsPtr
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFloatingIpsResponseBody200FloatingIpsDnsPtr" (\obj -> (GHC.Base.pure GetFloatingIpsResponseBody200FloatingIpsDnsPtr GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "dns_ptr")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ip"))
-- | Defines the data type for the schema GetFloatingIpsResponseBody200Floating_ipsHome_location
-- 
-- Location the Floating IP was created in. Routing is optimized for this Location.
data GetFloatingIpsResponseBody200FloatingIpsHomeLocation = GetFloatingIpsResponseBody200FloatingIpsHomeLocation {
  -- | city: City the Location is closest to
  getFloatingIpsResponseBody200FloatingIpsHomeLocationCity :: Data.Text.Internal.Text
  -- | country: ISO 3166-1 alpha-2 code of the country the Location resides in
  , getFloatingIpsResponseBody200FloatingIpsHomeLocationCountry :: Data.Text.Internal.Text
  -- | description: Description of the Location
  , getFloatingIpsResponseBody200FloatingIpsHomeLocationDescription :: Data.Text.Internal.Text
  -- | id: ID of the Location
  , getFloatingIpsResponseBody200FloatingIpsHomeLocationId :: GHC.Types.Double
  -- | latitude: Latitude of the city closest to the Location
  , getFloatingIpsResponseBody200FloatingIpsHomeLocationLatitude :: GHC.Types.Double
  -- | longitude: Longitude of the city closest to the Location
  , getFloatingIpsResponseBody200FloatingIpsHomeLocationLongitude :: GHC.Types.Double
  -- | name: Unique identifier of the Location
  , getFloatingIpsResponseBody200FloatingIpsHomeLocationName :: Data.Text.Internal.Text
  -- | network_zone: Name of network zone this Location resides in
  , getFloatingIpsResponseBody200FloatingIpsHomeLocationNetworkZone :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFloatingIpsResponseBody200FloatingIpsHomeLocation
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "city" (getFloatingIpsResponseBody200FloatingIpsHomeLocationCity obj) : (Data.Aeson..=) "country" (getFloatingIpsResponseBody200FloatingIpsHomeLocationCountry obj) : (Data.Aeson..=) "description" (getFloatingIpsResponseBody200FloatingIpsHomeLocationDescription obj) : (Data.Aeson..=) "id" (getFloatingIpsResponseBody200FloatingIpsHomeLocationId obj) : (Data.Aeson..=) "latitude" (getFloatingIpsResponseBody200FloatingIpsHomeLocationLatitude obj) : (Data.Aeson..=) "longitude" (getFloatingIpsResponseBody200FloatingIpsHomeLocationLongitude obj) : (Data.Aeson..=) "name" (getFloatingIpsResponseBody200FloatingIpsHomeLocationName obj) : (Data.Aeson..=) "network_zone" (getFloatingIpsResponseBody200FloatingIpsHomeLocationNetworkZone obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "city" (getFloatingIpsResponseBody200FloatingIpsHomeLocationCity obj) GHC.Base.<> ((Data.Aeson..=) "country" (getFloatingIpsResponseBody200FloatingIpsHomeLocationCountry obj) GHC.Base.<> ((Data.Aeson..=) "description" (getFloatingIpsResponseBody200FloatingIpsHomeLocationDescription obj) GHC.Base.<> ((Data.Aeson..=) "id" (getFloatingIpsResponseBody200FloatingIpsHomeLocationId obj) GHC.Base.<> ((Data.Aeson..=) "latitude" (getFloatingIpsResponseBody200FloatingIpsHomeLocationLatitude obj) GHC.Base.<> ((Data.Aeson..=) "longitude" (getFloatingIpsResponseBody200FloatingIpsHomeLocationLongitude obj) GHC.Base.<> ((Data.Aeson..=) "name" (getFloatingIpsResponseBody200FloatingIpsHomeLocationName obj) GHC.Base.<> (Data.Aeson..=) "network_zone" (getFloatingIpsResponseBody200FloatingIpsHomeLocationNetworkZone obj))))))))
instance Data.Aeson.Types.FromJSON.FromJSON GetFloatingIpsResponseBody200FloatingIpsHomeLocation
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFloatingIpsResponseBody200FloatingIpsHomeLocation" (\obj -> (((((((GHC.Base.pure GetFloatingIpsResponseBody200FloatingIpsHomeLocation GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "city")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "country")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "latitude")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "longitude")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "network_zone"))
-- | Defines the data type for the schema GetFloatingIpsResponseBody200Floating_ipsLabels
-- 
-- User-defined labels (key-value pairs)
data GetFloatingIpsResponseBody200FloatingIpsLabels = GetFloatingIpsResponseBody200FloatingIpsLabels {
  
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFloatingIpsResponseBody200FloatingIpsLabels
    where toJSON obj = Data.Aeson.object []
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "string" ("string" :: GHC.Base.String))
instance Data.Aeson.Types.FromJSON.FromJSON GetFloatingIpsResponseBody200FloatingIpsLabels
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFloatingIpsResponseBody200FloatingIpsLabels" (\obj -> GHC.Base.pure GetFloatingIpsResponseBody200FloatingIpsLabels)
-- | Defines the data type for the schema GetFloatingIpsResponseBody200Floating_ipsProtection
-- 
-- Protection configuration for the Resource
data GetFloatingIpsResponseBody200FloatingIpsProtection = GetFloatingIpsResponseBody200FloatingIpsProtection {
  -- | delete: If true, prevents the Resource from being deleted
  getFloatingIpsResponseBody200FloatingIpsProtectionDelete :: GHC.Types.Bool
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFloatingIpsResponseBody200FloatingIpsProtection
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "delete" (getFloatingIpsResponseBody200FloatingIpsProtectionDelete obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "delete" (getFloatingIpsResponseBody200FloatingIpsProtectionDelete obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetFloatingIpsResponseBody200FloatingIpsProtection
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFloatingIpsResponseBody200FloatingIpsProtection" (\obj -> GHC.Base.pure GetFloatingIpsResponseBody200FloatingIpsProtection GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "delete"))
-- | Defines the enum schema GetFloatingIpsResponseBody200Floating_ipsType
-- 
-- Type of the Floating IP
data GetFloatingIpsResponseBody200FloatingIpsType
    = GetFloatingIpsResponseBody200FloatingIpsTypeEnumOther Data.Aeson.Types.Internal.Value
    | GetFloatingIpsResponseBody200FloatingIpsTypeEnumTyped Data.Text.Internal.Text
    | GetFloatingIpsResponseBody200FloatingIpsTypeEnumStringIpv4
    | GetFloatingIpsResponseBody200FloatingIpsTypeEnumStringIpv6
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFloatingIpsResponseBody200FloatingIpsType
    where toJSON (GetFloatingIpsResponseBody200FloatingIpsTypeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetFloatingIpsResponseBody200FloatingIpsTypeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (GetFloatingIpsResponseBody200FloatingIpsTypeEnumStringIpv4) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "ipv4"
          toJSON (GetFloatingIpsResponseBody200FloatingIpsTypeEnumStringIpv6) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "ipv6"
instance Data.Aeson.FromJSON GetFloatingIpsResponseBody200FloatingIpsType
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "ipv4")
                                          then GetFloatingIpsResponseBody200FloatingIpsTypeEnumStringIpv4
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "ipv6")
                                                then GetFloatingIpsResponseBody200FloatingIpsTypeEnumStringIpv6
                                                else GetFloatingIpsResponseBody200FloatingIpsTypeEnumOther val)
-- | Defines the data type for the schema GetFloatingIpsResponseBody200Meta
-- 
-- 
data GetFloatingIpsResponseBody200Meta = GetFloatingIpsResponseBody200Meta {
  -- | pagination
  getFloatingIpsResponseBody200MetaPagination :: GetFloatingIpsResponseBody200MetaPagination
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFloatingIpsResponseBody200Meta
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "pagination" (getFloatingIpsResponseBody200MetaPagination obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "pagination" (getFloatingIpsResponseBody200MetaPagination obj))
instance Data.Aeson.Types.FromJSON.FromJSON GetFloatingIpsResponseBody200Meta
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFloatingIpsResponseBody200Meta" (\obj -> GHC.Base.pure GetFloatingIpsResponseBody200Meta GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pagination"))
-- | Defines the data type for the schema GetFloatingIpsResponseBody200MetaPagination
-- 
-- 
data GetFloatingIpsResponseBody200MetaPagination = GetFloatingIpsResponseBody200MetaPagination {
  -- | last_page: ID of the last page available. Can be null if the current page is the last one.
  getFloatingIpsResponseBody200MetaPaginationLastPage :: GHC.Types.Double
  -- | next_page: ID of the next page. Can be null if the current page is the last one.
  , getFloatingIpsResponseBody200MetaPaginationNextPage :: GHC.Types.Double
  -- | page: Current page number
  , getFloatingIpsResponseBody200MetaPaginationPage :: GHC.Types.Double
  -- | per_page: Maximum number of items shown per page in the response
  , getFloatingIpsResponseBody200MetaPaginationPerPage :: GHC.Types.Double
  -- | previous_page: ID of the previous page. Can be null if the current page is the first one.
  , getFloatingIpsResponseBody200MetaPaginationPreviousPage :: GHC.Types.Double
  -- | total_entries: The total number of entries that exist in the database for this query. Nullable if unknown.
  , getFloatingIpsResponseBody200MetaPaginationTotalEntries :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON GetFloatingIpsResponseBody200MetaPagination
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "last_page" (getFloatingIpsResponseBody200MetaPaginationLastPage obj) : (Data.Aeson..=) "next_page" (getFloatingIpsResponseBody200MetaPaginationNextPage obj) : (Data.Aeson..=) "page" (getFloatingIpsResponseBody200MetaPaginationPage obj) : (Data.Aeson..=) "per_page" (getFloatingIpsResponseBody200MetaPaginationPerPage obj) : (Data.Aeson..=) "previous_page" (getFloatingIpsResponseBody200MetaPaginationPreviousPage obj) : (Data.Aeson..=) "total_entries" (getFloatingIpsResponseBody200MetaPaginationTotalEntries obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "last_page" (getFloatingIpsResponseBody200MetaPaginationLastPage obj) GHC.Base.<> ((Data.Aeson..=) "next_page" (getFloatingIpsResponseBody200MetaPaginationNextPage obj) GHC.Base.<> ((Data.Aeson..=) "page" (getFloatingIpsResponseBody200MetaPaginationPage obj) GHC.Base.<> ((Data.Aeson..=) "per_page" (getFloatingIpsResponseBody200MetaPaginationPerPage obj) GHC.Base.<> ((Data.Aeson..=) "previous_page" (getFloatingIpsResponseBody200MetaPaginationPreviousPage obj) GHC.Base.<> (Data.Aeson..=) "total_entries" (getFloatingIpsResponseBody200MetaPaginationTotalEntries obj))))))
instance Data.Aeson.Types.FromJSON.FromJSON GetFloatingIpsResponseBody200MetaPagination
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetFloatingIpsResponseBody200MetaPagination" (\obj -> (((((GHC.Base.pure GetFloatingIpsResponseBody200MetaPagination GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "last_page")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "next_page")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "page")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "per_page")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "previous_page")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "total_entries"))
